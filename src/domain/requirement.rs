use std::collections::BTreeSet;
use std::collections::HashMap;
use std::io;
use std::path::Path;

use borsh::BorshSerialize;
use chrono::{DateTime, Utc};
use sha2::Digest;
use sha2::Sha256;
use uuid::Uuid;

use crate::domain::Hrid;
pub use crate::domain::requirement::storage::LoadError;
use crate::domain::requirement::storage::MarkdownRequirement;

mod storage;

/// A requirement is a document used to describe a system.
///
/// It can represent a user requirement, a specification, etc.
/// Requirements can have dependencies between them, such that one requirement
/// satisfies, fulfils, verifies (etc.) another requirement.
#[derive(Debug, Clone, PartialEq)]
pub struct Requirement {
    content: Content,
    metadata: Metadata,
}

/// The semantically important content of the requirement.
///
/// This contributes to the 'fingerprint' of the requirement
#[derive(Debug, BorshSerialize, Clone, PartialEq)]
struct Content {
    content: String,
    tags: BTreeSet<String>,
}

impl Content {
    fn fingerprint(&self) -> String {
        // encode using [borsh](https://borsh.io/)
        let encoded = borsh::to_vec(self).expect("this should never fail");

        // generate a SHA256 hash
        let hash = Sha256::digest(encoded);

        // Convert to hex string
        format!("{hash:x}")
    }
}

/// Requirement metadata.
///
/// Does not contribute to the requirement fingerprint.
#[derive(Debug, Clone, PartialEq)]
struct Metadata {
    /// Globally unique, perpetually stable identifier
    uuid: Uuid,

    /// Globally unique, human readable identifier.
    ///
    /// This should in general change, however it is possible to
    /// change it if needed.
    hrid: Hrid,
    created: DateTime<Utc>,
    parents: HashMap<Uuid, Parent>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Parent {
    pub hrid: Hrid,
    pub fingerprint: String,
}

impl Requirement {
    /// Construct a new [`Requirement`] from a human-readable ID and its content.
    ///
    /// A new UUID is automatically generated.
    #[must_use]
    pub fn new(hrid: Hrid, content: String) -> Self {
        Self::new_with_uuid(hrid, content, Uuid::new_v4())
    }

    pub(crate) fn new_with_uuid(hrid: Hrid, content: String, uuid: Uuid) -> Self {
        let content = Content {
            content,
            tags: BTreeSet::default(),
        };

        let metadata = Metadata {
            uuid,
            hrid,
            created: Utc::now(),
            parents: HashMap::new(),
        };

        Self { content, metadata }
    }

    /// The body of the requirement.
    ///
    /// This should be a markdown document.
    #[must_use]
    pub fn content(&self) -> &str {
        &self.content.content
    }

    /// The tags on the requirement
    #[must_use]
    pub const fn tags(&self) -> &BTreeSet<String> {
        &self.content.tags
    }

    /// Set the tags on the requirement.
    ///
    /// this replaces any existing tags.
    pub fn set_tags(&mut self, tags: BTreeSet<String>) {
        self.content.tags = tags;
    }

    /// Add a tag to the requirement.
    ///
    /// returns 'true' if a new tag was inserted, or 'false' if it was already present.
    pub fn add_tag(&mut self, tag: String) -> bool {
        self.content.tags.insert(tag)
    }

    /// The human-readable identifier for this requirement.
    ///
    /// In normal usage these should be stable
    #[must_use]
    pub const fn hrid(&self) -> &Hrid {
        &self.metadata.hrid
    }

    /// The unique, stable identifier of this requirement
    #[must_use]
    pub const fn uuid(&self) -> Uuid {
        self.metadata.uuid
    }

    /// When the requirement was first created
    #[must_use]
    pub const fn created(&self) -> DateTime<Utc> {
        self.metadata.created
    }

    /// Returns a value generated by hashing the content of the Requirement.
    ///
    /// Any change to the requirement will change the fingerprint. This is used
    /// to determine when links are 'suspect'. Meaning that because a requirement
    /// has been modified, related or dependent requirements also need to be reviewed
    /// to ensure consistency.
    #[must_use]
    pub fn fingerprint(&self) -> String {
        self.content.fingerprint()
    }

    /// Add a parent to the requirement, keyed by UUID.
    pub fn add_parent(&mut self, parent_id: Uuid, parent_info: Parent) -> Option<Parent> {
        self.metadata.parents.insert(parent_id, parent_info)
    }

    /// Return an iterator over the requirement's 'parents'
    pub fn parents(&self) -> impl Iterator<Item = (Uuid, &Parent)> {
        self.metadata
            .parents
            .iter()
            .map(|(&id, parent)| (id, parent))
    }

    /// Return a mutable iterator over the requirement's 'parents'
    pub fn parents_mut(&mut self) -> impl Iterator<Item = (Uuid, &mut Parent)> {
        self.metadata
            .parents
            .iter_mut()
            .map(|(&id, parent)| (id, parent))
    }

    /// Reads a requirement from the given file path.
    ///
    /// Note the path here is the path to the directory. The filename is determined by the HRID
    ///
    /// # Errors
    ///
    /// Returns an error if the file does not exist, cannot be read from, or has malformed YAML frontmatter.
    pub fn load(path: &Path, hrid: String) -> Result<Self, LoadError> {
        Ok(MarkdownRequirement::load(path, hrid)?.try_into()?)
    }

    /// Writes the requirement to the given file path.
    /// Creates the file if it doesn't exist, or overwrites it if it does.
    ///
    /// Note the path here is the path to the directory. The filename is determined by the HRID.
    ///
    /// # Errors
    ///
    /// This method returns an error if the path cannot be written to.
    pub fn save(&self, path: &Path) -> io::Result<()> {
        MarkdownRequirement::from(self.clone()).save(path)
    }
}

#[cfg(test)]
mod tests {
    use std::collections::BTreeSet;

    use super::Content;

    #[test]
    fn fingerprint_does_not_panic() {
        let content = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        content.fingerprint();
    }

    #[test]
    fn fingerprint_is_stable_with_tag_order() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag2".to_string(), "tag1".to_string()].into(),
        };
        assert_eq!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn tags_affect_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn content_affects_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: BTreeSet::default(),
        };
        let content2 = Content {
            content: "Other string".to_string(),
            tags: BTreeSet::default(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }
}
