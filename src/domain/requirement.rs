use std::collections::BTreeSet;
use std::io;
use std::path::Path;

use borsh::BorshSerialize;
use chrono::{DateTime, Utc};
use sha2::Digest;
use sha2::Sha256;
use uuid::Uuid;

use crate::domain::requirement::storage::LoadError;
use crate::domain::requirement::storage::MarkdownRequirement;

mod storage;

#[derive(Debug, Clone)]
pub struct Requirement {
    content: Content,
    metadata: Metadata,
}

/// The semantically important content of the requirement.
///
/// This contributes to the 'fingerprint' of the requirement
#[derive(Debug, BorshSerialize, Clone)]
struct Content {
    content: String,
    tags: BTreeSet<String>,
}

impl Content {
    fn fingerprint(&self) -> String {
        // encode using [borsh](https://borsh.io/)
        let encoded = borsh::to_vec(self).expect("this should never fail");

        // generate a SHA256 hash
        let hash = Sha256::digest(encoded);

        // Convert to hex string
        format!("{hash:x}")
    }
}

/// Requirement metadata.
///
/// Does not contribute to the requirement fingerprint.
#[derive(Debug, Clone)]
struct Metadata {
    /// Globally unique, perpetually stable identifier
    uuid: Uuid,

    /// Globally unique, human readable identifier.
    ///
    /// This should in general change, however it is possible to
    /// change it if needed.
    hrid: String,
    created: DateTime<Utc>,
}

impl Requirement {
    #[must_use]
    pub fn new(hrid: String, content: String) -> Self {
        let content = Content {
            content,
            tags: BTreeSet::default(),
        };

        let metadata = Metadata {
            uuid: Uuid::new_v4(),
            hrid,
            created: Utc::now(),
        };

        Self { content, metadata }
    }

    #[must_use]
    pub const fn from_parts(
        uuid: Uuid,
        created: DateTime<Utc>,
        hrid: String,
        content: String,
        tags: BTreeSet<String>,
    ) -> Self {
        Self {
            content: Content { content, tags },
            metadata: Metadata {
                uuid,
                hrid,
                created,
            },
        }
    }

    #[must_use]
    pub fn content(&self) -> &str {
        &self.content.content
    }

    #[must_use]
    pub const fn tags(&self) -> &BTreeSet<String> {
        &self.content.tags
    }

    pub fn set_tags(&mut self, tags: BTreeSet<String>) {
        self.content.tags = tags;
    }

    pub fn add_tag(&mut self, tag: String) -> bool {
        self.content.tags.insert(tag)
    }

    #[must_use]
    pub fn hrid(&self) -> &str {
        &self.metadata.hrid
    }

    #[must_use]
    pub const fn uuid(&self) -> Uuid {
        self.metadata.uuid
    }

    #[must_use]
    pub const fn created(&self) -> DateTime<Utc> {
        self.metadata.created
    }

    /// Returns a value generated by hashing the content of the Requirement.
    ///
    /// Any change to the requirement will change the fingerprint. This is used
    /// to determine when links are 'suspect'. Meaning that because a requirement
    /// has been modified, related or dependent requirements also need to be reviewed
    /// to ensure consistency.
    #[must_use]
    pub fn fingerprint(&self) -> String {
        self.content.fingerprint()
    }

    pub fn load(path: &Path, hrid: String) -> Result<Self, LoadError> {
        Ok(MarkdownRequirement::load(path, hrid)?.into())
    }

    pub fn save(&self, path: &Path) -> io::Result<()> {
        MarkdownRequirement::from(self.clone()).save(path)
    }
}

#[cfg(test)]
mod tests {
    use std::collections::BTreeSet;

    use super::Content;

    #[test]
    fn fingerprint_doesnt_panic() {
        let content = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        content.fingerprint();
    }

    #[test]
    fn fingerprint_is_stable_with_tag_order() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag2".to_string(), "tag1".to_string()].into(),
        };
        assert_eq!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn tags_affect_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn content_affects_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: BTreeSet::default(),
        };
        let content2 = Content {
            content: "Other string".to_string(),
            tags: BTreeSet::default(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }
}
