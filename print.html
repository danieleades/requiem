<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Requiem User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to plain-text requirements management with Requiem">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Requiem User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/danieleades/requirements-manager" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Requiem, a modern plain-text requirements management tool designed for software and systems engineers who value simplicity, speed, and integration with their existing workflows.</p>
<h2 id="what-is-requiem"><a class="header" href="#what-is-requiem">What is Requiem?</a></h2>
<p>Requiem (package name: <code>requirements-manager</code>, CLI: <code>req</code>) is a spiritual successor to <a href="https://github.com/doorstop-dev/doorstop">Doorstop</a>, reimagined for the modern development landscape. It enables teams to:</p>
<ul>
<li><strong>Manage requirements as plain text</strong> - Store requirements as markdown files with YAML frontmatter, making them human-readable, version-controllable, and diff-friendly</li>
<li><strong>Build traceable requirement hierarchies</strong> - Link requirements together to form directed acyclic graphs (DAGs) that trace from high-level user needs down to detailed specifications</li>
<li><strong>Support multiple parents</strong> - Unlike many tools, Requiem allows a single requirement to satisfy multiple parent requirements, reflecting real-world complexity</li>
<li><strong>Integrate seamlessly</strong> - Works alongside documentation tools like <a href="https://github.com/sphinx-doc/sphinx">Sphinx</a> and <a href="https://github.com/rust-lang/mdBook">MdBook</a>, fitting naturally into your existing documentation workflow</li>
<li><strong>Scale with performance</strong> - Built in Rust with parallel processing, Requiem is designed to be much, much faster than its predecessors</li>
</ul>
<h2 id="when-to-use-requirements-management"><a class="header" href="#when-to-use-requirements-management">When to Use Requirements Management</a></h2>
<p>Requirements management is essential when:</p>
<ul>
<li><strong>Traceability is critical</strong> - Regulated industries (aerospace, medical devices, automotive) often require proof that each requirement is implemented and tested</li>
<li><strong>Teams need alignment</strong> - Multiple stakeholders (users, developers, testers, managers) need a shared understanding of what's being built</li>
<li><strong>Systems are complex</strong> - Large projects with many interconnected components benefit from formal requirement tracking</li>
<li><strong>Change management matters</strong> - Understanding the impact of requirement changes across dependent systems is crucial</li>
<li><strong>Documentation must be maintained</strong> - Requirements serve as the foundation for design documents, test plans, and user manuals</li>
</ul>
<h2 id="project-status"><a class="header" href="#project-status">Project Status</a></h2>
<p>Requiem is in <strong>early development</strong> and not yet ready for production use. Current status:</p>
<p><strong>Implemented:</strong></p>
<ul>
<li>‚úÖ Manage requirements, specifications, and documents in plain text</li>
<li>‚úÖ Create and link requirements with human-readable IDs</li>
<li>‚úÖ Support multiple parent relationships</li>
<li>‚úÖ Content fingerprinting for change detection</li>
<li>‚úÖ Integration with MdBook and Sphinx</li>
<li>‚úÖ Parallel loading for performance</li>
</ul>
<p><strong>Planned:</strong></p>
<ul>
<li>üöß Detect cycles in requirement graphs</li>
<li>üöß Trigger reviews when dependent requirements change</li>
<li>üöß Generate coverage reports (requirement ‚Üí implementation ‚Üí test)</li>
<li>üöß Import and export in standard formats</li>
</ul>
<p>Contributions are welcome! See the <a href="https://github.com/danieleades/requirements-manager">GitHub repository</a> for more information.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>Requiem is built on several core principles:</p>
<ol>
<li><strong>Plain text first</strong> - Requirements are markdown files that can be read, edited, and reviewed without special tools</li>
<li><strong>Git-friendly</strong> - Every requirement change creates a meaningful diff that's easy to review in pull requests</li>
<li><strong>Dual identifiers</strong> - Stable UUIDs for machine processing, human-readable IDs (like <code>USR-001</code>) for people</li>
<li><strong>Fast by default</strong> - Parallel processing and efficient data structures mean Requiem scales to large projects</li>
<li><strong>Composable</strong> - Works alongside your existing documentation tools rather than replacing them</li>
</ol>
<h2 id="who-this-guide-is-for"><a class="header" href="#who-this-guide-is-for">Who This Guide Is For</a></h2>
<p>This guide is designed for:</p>
<ul>
<li><strong>Requirements engineers</strong> managing formal requirement sets</li>
<li><strong>Technical writers</strong> documenting software systems</li>
<li><strong>Developers</strong> working in regulated environments</li>
<li><strong>Project managers</strong> needing traceability and impact analysis</li>
<li><strong>QA engineers</strong> mapping requirements to test cases</li>
</ul>
<p>You should be comfortable with:</p>
<ul>
<li>Command-line tools</li>
<li>Text editors</li>
<li>Basic version control (Git)</li>
<li>Markdown formatting</li>
</ul>
<h2 id="whats-in-this-guide"><a class="header" href="#whats-in-this-guide">What's in This Guide</a></h2>
<p>This guide includes:</p>
<ul>
<li><strong>User Guide</strong>: Learn how to use Requiem effectively</li>
<li><strong>Reference</strong>: Detailed CLI and file format specifications</li>
<li><strong>Example Project</strong>: See Requiem managing its own requirements as a real-world example</li>
</ul>
<p>The <a href="./requirements.html">Example Project</a> contains all 21 requirements that define what Requiem does, demonstrating traceability, proper structure, and best practices.</p>
<p>Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section will help you install Requiem and create your first requirements project. By the end, you'll understand the basic workflow and be ready to manage your own requirements.</p>
<p>The following chapters cover:</p>
<ul>
<li><strong><a href="./getting-started/installation.html">Installation</a></strong> - How to install Requiem on your system</li>
<li><strong><a href="./getting-started/quick-start.html">Quick Start Tutorial</a></strong> - A 5-minute introduction to basic commands</li>
<li><strong><a href="./getting-started/first-project.html">Your First Requirements Project</a></strong> - Creating a complete requirements hierarchy from scratch</li>
</ul>
<p>If you're eager to dive in, start with the Quick Start Tutorial. If you prefer a more thorough understanding, read through all three chapters in order.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Requiem is distributed as a Rust crate and can be installed using Cargo, Rust's package manager.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You'll need Rust installed on your system. If you don't have it yet:</p>
<h3 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h3>
<p>Visit <a href="https://rustup.rs/">rustup.rs</a> or run:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>After installation, verify Rust is available:</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<h2 id="installing-requiem"><a class="header" href="#installing-requiem">Installing Requiem</a></h2>
<h3 id="from-cratesio"><a class="header" href="#from-cratesio">From crates.io</a></h3>
<p>Once Rust is installed, install Requiem using Cargo:</p>
<pre><code class="language-bash">cargo install requirements-manager
</code></pre>
<p>This will download, compile, and install the <code>req</code> command-line tool.</p>
<h3 id="from-source"><a class="header" href="#from-source">From Source</a></h3>
<p>To install the latest development version from the GitHub repository:</p>
<pre><code class="language-bash">cargo install --git https://github.com/danieleades/requirements-manager
</code></pre>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<p>Confirm Requiem is installed correctly:</p>
<pre><code class="language-bash">req --version
</code></pre>
<p>You should see output like:</p>
<pre><code>req 0.1.0
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>To see all available commands:</p>
<pre><code class="language-bash">req --help
</code></pre>
<p>For help with a specific command:</p>
<pre><code class="language-bash">req add --help
req link --help
</code></pre>
<h2 id="updating-requiem"><a class="header" href="#updating-requiem">Updating Requiem</a></h2>
<p>To update to the latest version:</p>
<pre><code class="language-bash">cargo install requirements-manager --force
</code></pre>
<p>The <code>--force</code> flag tells Cargo to reinstall even if a version is already present.</p>
<h2 id="uninstalling"><a class="header" href="#uninstalling">Uninstalling</a></h2>
<p>To remove Requiem:</p>
<pre><code class="language-bash">cargo uninstall requirements-manager
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that Requiem is installed, proceed to the <a href="getting-started/./quick-start.html">Quick Start Tutorial</a> to learn the basic commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-tutorial"><a class="header" href="#quick-start-tutorial">Quick Start Tutorial</a></h1>
<p>This 5-minute tutorial introduces Requiem's basic workflow. You'll create a simple set of requirements and link them together.</p>
<h2 id="creating-a-requirements-directory"><a class="header" href="#creating-a-requirements-directory">Creating a Requirements Directory</a></h2>
<p>First, create a directory for your requirements:</p>
<pre><code class="language-bash">mkdir my-requirements
cd my-requirements
</code></pre>
<p>Requiem works with any directory - there's no special initialization needed. Requirements are simply markdown files with YAML frontmatter.</p>
<h2 id="adding-your-first-requirement"><a class="header" href="#adding-your-first-requirement">Adding Your First Requirement</a></h2>
<p>Let's create a user requirement using the <code>add</code> command:</p>
<pre><code class="language-bash">req add USR
</code></pre>
<p>This creates a file named <code>USR-001.md</code> with automatically generated metadata. Output:</p>
<pre><code>Added requirement USR-001
</code></pre>
<p>The file contains:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---


</code></pre>
<p>The YAML frontmatter includes:</p>
<ul>
<li><code>_version</code>: Format version for future compatibility</li>
<li><code>uuid</code>: A globally unique, stable identifier</li>
<li><code>created</code>: Timestamp of creation</li>
</ul>
<p>The body (currently empty) is where you'll write the requirement text.</p>
<h2 id="editing-the-requirement"><a class="header" href="#editing-the-requirement">Editing the Requirement</a></h2>
<p>Open <code>USR-001.md</code> in your text editor and add content:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---

The system shall support plain-text requirements that can be edited with any text editor.
</code></pre>
<p>Save the file. That's it! You've created your first requirement.</p>
<h2 id="adding-more-requirements"><a class="header" href="#adding-more-requirements">Adding More Requirements</a></h2>
<p>Create a few more user requirements:</p>
<pre><code class="language-bash">req add USR  # Creates USR-002
req add USR  # Creates USR-003
</code></pre>
<p>Edit these files to add meaningful content. For example:</p>
<p><strong>USR-002.md:</strong></p>
<pre><code class="language-markdown">The system shall integrate with version control systems like Git.
</code></pre>
<p><strong>USR-003.md:</strong></p>
<pre><code class="language-markdown">The system shall support requirement traceability and linkage.
</code></pre>
<h2 id="creating-system-requirements"><a class="header" href="#creating-system-requirements">Creating System Requirements</a></h2>
<p>Now let's create system-level requirements that satisfy the user requirements:</p>
<pre><code class="language-bash">req add SYS  # Creates SYS-001
</code></pre>
<h2 id="linking-requirements"><a class="header" href="#linking-requirements">Linking Requirements</a></h2>
<p>Link <code>SYS-001</code> to its parent <code>USR-001</code>:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
</code></pre>
<p>Output:</p>
<pre><code>Linked SYS-001 to USR-001
</code></pre>
<p>Now if you open <code>SYS-001.md</code>, you'll see the parent relationship in the frontmatter:</p>
<pre><code class="language-yaml">---
_version: '1'
uuid: 81e63bac-4035-47b5-b273-ac13e47a2ff6
created: 2025-07-22T13:14:40.510075462Z
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
---

Each requirement shall be stored as a markdown file with YAML frontmatter.
</code></pre>
<p>The <code>parents</code> section contains:</p>
<ul>
<li><code>uuid</code>: The stable identifier of the parent</li>
<li><code>hrid</code>: The human-readable ID (for your convenience)</li>
<li><code>fingerprint</code>: A hash of the parent's content (for change detection)</li>
</ul>
<h2 id="creating-requirements-with-multiple-parents"><a class="header" href="#creating-requirements-with-multiple-parents">Creating Requirements with Multiple Parents</a></h2>
<p>You can link a requirement to multiple parents when creating it:</p>
<pre><code class="language-bash">req add SYS --parents USR-001,USR-002
</code></pre>
<p>This creates <code>SYS-002</code> already linked to both <code>USR-001</code> and <code>USR-002</code>.</p>
<h2 id="viewing-requirements"><a class="header" href="#viewing-requirements">Viewing Requirements</a></h2>
<p>Requirements are just markdown files, so you can view them with any tool:</p>
<pre><code class="language-bash">ls *.md
cat USR-001.md
</code></pre>
<p>Or use your favorite text editor, IDE, or markdown viewer.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You've learned the three core commands:</p>
<ol>
<li><strong><code>req add &lt;KIND&gt;</code></strong> - Create a new requirement</li>
<li><strong><code>req link &lt;CHILD&gt; &lt;PARENT&gt;</code></strong> - Link two requirements</li>
<li><strong><code>req add &lt;KIND&gt; --parents &lt;PARENT1&gt;,&lt;PARENT2&gt;</code></strong> - Create with parents</li>
</ol>
<p>These commands form the foundation of requirements management with Requiem.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Continue to <a href="getting-started/./first-project.html">Your First Requirements Project</a> to build a complete requirement hierarchy and learn more advanced techniques.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-requirements-project"><a class="header" href="#your-first-requirements-project">Your First Requirements Project</a></h1>
<p>In this chapter, we'll build a complete requirements hierarchy for a simple project: a task management application. You'll learn how to structure requirements across multiple levels and establish traceability.</p>
<h2 id="planning-the-hierarchy"><a class="header" href="#planning-the-hierarchy">Planning the Hierarchy</a></h2>
<p>A typical requirements hierarchy has multiple levels:</p>
<ol>
<li><strong>User Requirements (USR)</strong> - High-level needs from the user's perspective</li>
<li><strong>System Requirements (SYS)</strong> - Technical specifications that satisfy user needs</li>
<li><strong>Software Requirements (SWR)</strong> - Detailed implementation requirements (optional)</li>
<li><strong>Test Requirements (TST)</strong> - Test cases that verify requirements (optional)</li>
</ol>
<p>For our task app, we'll use USR and SYS levels.</p>
<h2 id="setting-up-the-project"><a class="header" href="#setting-up-the-project">Setting Up the Project</a></h2>
<p>Create and enter a new directory:</p>
<pre><code class="language-bash">mkdir task-app-requirements
cd task-app-requirements
</code></pre>
<h2 id="creating-user-requirements"><a class="header" href="#creating-user-requirements">Creating User Requirements</a></h2>
<p>User requirements describe what users need, not how it's implemented.</p>
<pre><code class="language-bash">req add USR  # USR-001
req add USR  # USR-002
req add USR  # USR-003
</code></pre>
<p>Edit each file to add content:</p>
<p><strong>USR-001.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
---

Users shall be able to create tasks with a title and description.
</code></pre>
<p><strong>USR-002.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
---

Users shall be able to mark tasks as complete.
</code></pre>
<p><strong>USR-003.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
---

Users shall be able to filter tasks by completion status.
</code></pre>
<h2 id="creating-system-requirements-1"><a class="header" href="#creating-system-requirements-1">Creating System Requirements</a></h2>
<p>System requirements break down user requirements into technical specifications.</p>
<p>For <code>USR-001</code> (creating tasks), we need:</p>
<pre><code class="language-bash">req add SYS --parents USR-001  # SYS-001
req add SYS --parents USR-001  # SYS-002
</code></pre>
<p><strong>SYS-001.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
parents:
- uuid: &lt;USR-001 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-001
---

The system shall provide a Task data structure with fields: id, title, description, completed, created_at.
</code></pre>
<p><strong>SYS-002.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
parents:
- uuid: &lt;USR-001 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-001
---

The system shall validate that task titles are non-empty strings with maximum 100 characters.
</code></pre>
<p>For <code>USR-002</code> (marking complete):</p>
<pre><code class="language-bash">req add SYS --parents USR-002  # SYS-003
</code></pre>
<p><strong>SYS-003.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
parents:
- uuid: &lt;USR-002 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-002
---

The system shall provide a method to toggle the completed status of a task.
</code></pre>
<p>For <code>USR-003</code> (filtering):</p>
<pre><code class="language-bash">req add SYS --parents USR-003  # SYS-004
</code></pre>
<p><strong>SYS-004.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
parents:
- uuid: &lt;USR-003 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-003
---

The system shall provide a method to filter tasks returning only those matching the specified completion status.
</code></pre>
<h2 id="creating-cross-cutting-requirements"><a class="header" href="#creating-cross-cutting-requirements">Creating Cross-Cutting Requirements</a></h2>
<p>Some requirements affect multiple user needs. For example, persistence:</p>
<pre><code class="language-bash">req add SYS --parents USR-001,USR-002,USR-003  # SYS-005
</code></pre>
<p><strong>SYS-005.md:</strong></p>
<pre><code class="language-markdown">---
_version: '1'
uuid: &lt;auto-generated&gt;
created: &lt;auto-generated&gt;
parents:
- uuid: &lt;USR-001 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-001
- uuid: &lt;USR-002 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-002
- uuid: &lt;USR-003 uuid&gt;
  fingerprint: &lt;auto-generated&gt;
  hrid: USR-003
---

The system shall persist all tasks to disk and load them on startup.
</code></pre>
<p>This requirement has three parents because it affects creating, completing, and filtering tasks.</p>
<h2 id="reviewing-your-requirements-structure"><a class="header" href="#reviewing-your-requirements-structure">Reviewing Your Requirements Structure</a></h2>
<p>Your directory now contains:</p>
<pre><code>task-app-requirements/
‚îú‚îÄ‚îÄ USR-001.md  (Create tasks)
‚îú‚îÄ‚îÄ USR-002.md  (Mark complete)
‚îú‚îÄ‚îÄ USR-003.md  (Filter tasks)
‚îú‚îÄ‚îÄ SYS-001.md  ‚Üí USR-001 (Task data structure)
‚îú‚îÄ‚îÄ SYS-002.md  ‚Üí USR-001 (Title validation)
‚îú‚îÄ‚îÄ SYS-003.md  ‚Üí USR-002 (Toggle completed)
‚îú‚îÄ‚îÄ SYS-004.md  ‚Üí USR-003 (Filter method)
‚îî‚îÄ‚îÄ SYS-005.md  ‚Üí USR-001, USR-002, USR-003 (Persistence)
</code></pre>
<h2 id="version-control-integration"><a class="header" href="#version-control-integration">Version Control Integration</a></h2>
<p>Requirements are plain text, so they work great with Git:</p>
<pre><code class="language-bash">git init
git add *.md
git commit -m "Initial requirements for task management app"
</code></pre>
<p>Every requirement change will now show up in your Git history with clear diffs:</p>
<pre><code class="language-diff">--- a/USR-001.md
+++ b/USR-001.md
@@ -4,4 +4,4 @@
 created: 2025-07-22T12:19:56.950194157Z
 ---

-Users shall be able to create tasks with a title and description.
+Users shall be able to create tasks with a title, description, and due date.
</code></pre>
<h2 id="best-practices-demonstrated"><a class="header" href="#best-practices-demonstrated">Best Practices Demonstrated</a></h2>
<p>This example shows several best practices:</p>
<ol>
<li><strong>Start high-level</strong> - Begin with user requirements before diving into technical details</li>
<li><strong>One concept per requirement</strong> - Each requirement addresses a single, testable concept</li>
<li><strong>Use clear language</strong> - Requirements use "shall" to indicate mandatory behavior</li>
<li><strong>Establish traceability</strong> - Every system requirement traces to at least one user requirement</li>
<li><strong>Support multiple parents</strong> - Cross-cutting concerns can satisfy multiple needs</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand the basics, explore:</p>
<ul>
<li><a href="getting-started/../core-concepts.html">Core Concepts</a> - Deeper dive into requirements management principles</li>
<li><a href="getting-started/../working-with-requirements.html">Working with Requirements</a> - Advanced features and techniques</li>
<li><a href="getting-started/../configuration.html">Configuration</a> - Customizing Requiem for your project</li>
</ul>
<p>Continue reading to learn how Requiem supports advanced requirements management practices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Requirements management is a discipline with well-established principles and practices. This chapter explores these concepts and shows how Requiem implements them.</p>
<p>Understanding these principles will help you:</p>
<ul>
<li>Structure requirements effectively</li>
<li>Maintain traceability throughout the development lifecycle</li>
<li>Manage changes systematically</li>
<li>Collaborate effectively with stakeholders</li>
</ul>
<h2 id="chapters"><a class="header" href="#chapters">Chapters</a></h2>
<ul>
<li><strong><a href="./core-concepts/principles.html">Requirements Management Principles</a></strong> - Foundational concepts that underpin effective requirements management</li>
<li><strong><a href="./core-concepts/traceability.html">Traceability</a></strong> - How to track relationships between requirements, design, implementation, and tests</li>
<li><strong><a href="./core-concepts/change-management.html">Change Management</a></strong> - Managing requirement evolution and detecting impact</li>
<li><strong><a href="./core-concepts/requiem-approach.html">How Requiem Supports These Principles</a></strong> - Requiem's design decisions and how they enable best practices</li>
</ul>
<p>Whether you're new to requirements management or an experienced practitioner, these chapters will ground you in the "why" behind Requiem's features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements-management-principles"><a class="header" href="#requirements-management-principles">Requirements Management Principles</a></h1>
<p>Effective requirements management is built on several foundational principles. Understanding these helps you structure your requirements for maximum value.</p>
<h2 id="what-is-a-requirement"><a class="header" href="#what-is-a-requirement">What is a Requirement?</a></h2>
<p>A <strong>requirement</strong> is a documented statement of a need, constraint, or capability that a system must satisfy. Requirements answer the question: "What must the system do or be?"</p>
<p>Good requirements are:</p>
<ul>
<li><strong>Clear</strong> - Unambiguous and understandable by all stakeholders</li>
<li><strong>Testable</strong> - You can verify whether the system satisfies the requirement</li>
<li><strong>Necessary</strong> - The requirement addresses a genuine need</li>
<li><strong>Feasible</strong> - The requirement can realistically be implemented</li>
<li><strong>Traceable</strong> - The requirement can be tracked through the development lifecycle</li>
</ul>
<h2 id="requirement-levels"><a class="header" href="#requirement-levels">Requirement Levels</a></h2>
<p>Requirements typically exist at multiple levels of abstraction:</p>
<h3 id="user-requirements"><a class="header" href="#user-requirements">User Requirements</a></h3>
<p>High-level statements of user needs and goals. Written in user terminology, these describe <em>what</em> users need to accomplish, not <em>how</em>.</p>
<p>Example: "Users shall be able to export data in multiple formats."</p>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<p>Technical specifications derived from user requirements. These describe <em>how</em> the system will satisfy user needs.</p>
<p>Example: "The system shall provide export functionality supporting CSV, JSON, and XML formats."</p>
<h3 id="softwarehardware-requirements"><a class="header" href="#softwarehardware-requirements">Software/Hardware Requirements</a></h3>
<p>Detailed requirements for specific subsystems or components.</p>
<p>Example: "The export module shall use the serde library for JSON serialization."</p>
<h2 id="requirement-attributes"><a class="header" href="#requirement-attributes">Requirement Attributes</a></h2>
<p>Each requirement should have metadata:</p>
<ul>
<li><strong>Unique Identifier</strong> - A stable reference (e.g., USR-001)</li>
<li><strong>Status</strong> - Draft, approved, implemented, verified, etc.</li>
<li><strong>Priority</strong> - Critical, high, medium, low</li>
<li><strong>Owner</strong> - Person or team responsible</li>
<li><strong>Rationale</strong> - Why this requirement exists</li>
<li><strong>Source</strong> - Where the requirement came from</li>
</ul>
<p><em>Note: Requiem currently stores identifiers and timestamps. Status, priority, and other attributes can be added as tags or in the requirement body.</em></p>
<h2 id="traceability"><a class="header" href="#traceability">Traceability</a></h2>
<p><strong>Traceability</strong> is the ability to track relationships between requirements and other artifacts (design documents, code, tests). There are two types:</p>
<ul>
<li><strong>Forward traceability</strong> - From requirements to design, code, and tests</li>
<li><strong>Backward traceability</strong> - From code and tests back to requirements</li>
</ul>
<p>Traceability enables:</p>
<ul>
<li>Impact analysis (what breaks if we change this requirement?)</li>
<li>Coverage analysis (are all requirements implemented and tested?)</li>
<li>Compliance verification (can we prove we met all requirements?)</li>
</ul>
<h2 id="requirement-dependencies"><a class="header" href="#requirement-dependencies">Requirement Dependencies</a></h2>
<p>Requirements rarely exist in isolation. They form a <strong>directed graph</strong> where:</p>
<ul>
<li><strong>Parent (upstream) requirements</strong> - Higher-level needs that must be satisfied</li>
<li><strong>Child (downstream) requirements</strong> - Detailed specifications that satisfy parents</li>
</ul>
<p>Example:</p>
<pre><code>USR-001: "Users shall authenticate securely"
  ‚îî‚îÄ SYS-001: "System shall use OAuth 2.0"
       ‚îî‚îÄ SWR-001: "Use the oauth2-rs library"
</code></pre>
<h2 id="the-v-model"><a class="header" href="#the-v-model">The V-Model</a></h2>
<p>The <strong>V-Model</strong> visualizes how requirements flow through development:</p>
<pre><code>User Requirements  ‚Üê‚Üí  Acceptance Tests
       ‚Üì                      ‚Üë
System Requirements ‚Üê‚Üí Integration Tests
       ‚Üì                      ‚Üë
Software Requirements ‚Üê‚Üí Unit Tests
       ‚Üì                      ‚Üë
    Implementation
</code></pre>
<p>Each level of requirements corresponds to a level of testing that verifies those requirements.</p>
<h2 id="requirements-vs-design"><a class="header" href="#requirements-vs-design">Requirements vs. Design</a></h2>
<p>A common challenge is distinguishing requirements from design:</p>
<ul>
<li><strong>Requirement</strong> - WHAT the system must do</li>
<li><strong>Design</strong> - HOW the system will do it</li>
</ul>
<p>Example:</p>
<ul>
<li>‚ùå Requirement: "The system shall use a PostgreSQL database" (This is design)</li>
<li>‚úÖ Requirement: "The system shall persist data reliably across restarts" (This is a requirement)</li>
<li>‚úÖ Design: "We'll use PostgreSQL to satisfy the persistence requirement" (This is design)</li>
</ul>
<p>However, in some contexts (particularly lower levels), the line blurs. "System shall use OAuth 2.0" might be a legitimate requirement if it's mandated by stakeholders or regulations.</p>
<h2 id="change-management"><a class="header" href="#change-management">Change Management</a></h2>
<p>Requirements change. Good requirements management accepts this and provides mechanisms to:</p>
<ol>
<li><strong>Track changes</strong> - Know what changed, when, and why</li>
<li><strong>Analyze impact</strong> - Understand what's affected by a change</li>
<li><strong>Trigger reviews</strong> - Ensure dependent requirements and tests are updated</li>
<li><strong>Maintain history</strong> - Preserve the evolution of requirements</li>
</ol>
<h2 id="validation-vs-verification"><a class="header" href="#validation-vs-verification">Validation vs. Verification</a></h2>
<p>Two distinct but related concepts:</p>
<ul>
<li><strong>Validation</strong> - Are we building the right thing? (Do requirements match user needs?)</li>
<li><strong>Verification</strong> - Are we building the thing right? (Does implementation match requirements?)</li>
</ul>
<p>Validation often involves stakeholder reviews. Verification involves testing and inspection.</p>
<h2 id="why-these-principles-matter"><a class="header" href="#why-these-principles-matter">Why These Principles Matter</a></h2>
<p>Following these principles provides:</p>
<ul>
<li><strong>Clarity</strong> - Everyone understands what's being built</li>
<li><strong>Accountability</strong> - Clear ownership and traceability</li>
<li><strong>Quality</strong> - Testable requirements lead to better testing</li>
<li><strong>Agility</strong> - Understanding impact enables confident change</li>
<li><strong>Compliance</strong> - Proof that requirements are met</li>
</ul>
<h2 id="requiems-approach"><a class="header" href="#requiems-approach">Requiem's Approach</a></h2>
<p>Requiem embodies these principles through:</p>
<ul>
<li>Plain-text markdown for clarity and accessibility</li>
<li>YAML frontmatter for metadata and relationships</li>
<li>UUID-based traceability with human-readable aliases</li>
<li>Content fingerprinting for change detection</li>
<li>Multiple parent support for complex dependencies</li>
</ul>
<p>Continue to <a href="core-concepts/./traceability.html">Traceability</a> to see how Requiem implements these concepts in practice.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traceability-1"><a class="header" href="#traceability-1">Traceability</a></h1>
<p>Traceability is the cornerstone of requirements management. It's the ability to track relationships between requirements and other artifacts throughout the development lifecycle.</p>
<h2 id="why-traceability-matters"><a class="header" href="#why-traceability-matters">Why Traceability Matters</a></h2>
<p>Traceability enables:</p>
<ol>
<li><strong>Impact Analysis</strong> - If requirement X changes, what else is affected?</li>
<li><strong>Coverage Analysis</strong> - Are all requirements implemented? Tested?</li>
<li><strong>Compliance</strong> - Prove that every requirement has been satisfied</li>
<li><strong>Root Cause Analysis</strong> - Trace bugs back to requirements</li>
<li><strong>Change Management</strong> - Understand dependencies before making changes</li>
</ol>
<h2 id="types-of-traceability"><a class="header" href="#types-of-traceability">Types of Traceability</a></h2>
<h3 id="vertical-traceability"><a class="header" href="#vertical-traceability">Vertical Traceability</a></h3>
<p>Tracks relationships <strong>between levels</strong> of requirements:</p>
<pre><code>Stakeholder Needs
       ‚Üì
User Requirements (USR)
       ‚Üì
System Requirements (SYS)
       ‚Üì
Software Requirements (SWR)
</code></pre>
<p>Example:</p>
<ul>
<li>Stakeholder: "We need to reduce data entry errors"</li>
<li>USR-042: "Users shall receive validation feedback"</li>
<li>SYS-078: "Form inputs shall validate on blur events"</li>
<li>SWR-123: "Use the validator.js library for email validation"</li>
</ul>
<h3 id="horizontal-traceability"><a class="header" href="#horizontal-traceability">Horizontal Traceability</a></h3>
<p>Tracks relationships <strong>within the same level</strong>:</p>
<pre><code>USR-001 ‚Üê USR-005
USR-001 ‚Üê USR-012
</code></pre>
<p>Example: USR-005 and USR-012 might both depend on USR-001's authentication requirement.</p>
<h3 id="forward-traceability"><a class="header" href="#forward-traceability">Forward Traceability</a></h3>
<p>From requirements <strong>downstream</strong> to:</p>
<ul>
<li>Design documents</li>
<li>Source code</li>
<li>Test cases</li>
<li>User documentation</li>
</ul>
<p>Example: USR-001 ‚Üí SYS-042 ‚Üí test_authentication.rs</p>
<h3 id="backward-traceability"><a class="header" href="#backward-traceability">Backward Traceability</a></h3>
<p>From implementation artifacts <strong>upstream</strong> to requirements:</p>
<pre><code>test_login.py ‚Üí SYS-042 ‚Üí USR-001
</code></pre>
<p>This answers: "Why does this test exist?" or "Which requirement does this code satisfy?"</p>
<h2 id="traceability-in-requiem"><a class="header" href="#traceability-in-requiem">Traceability in Requiem</a></h2>
<h3 id="parent-child-links"><a class="header" href="#parent-child-links">Parent-Child Links</a></h3>
<p>Requiem implements vertical traceability through explicit parent-child relationships:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: ccdbddbe-d5d2-4656-b4fe-85e61c02cf63
created: 2025-07-22T13:15:27.996136510Z
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
---

The system shall validate user credentials using bcrypt hashing.
</code></pre>
<p>This SYS requirement explicitly traces to its parent USR-001.</p>
<h3 id="stable-identifiers-uuids"><a class="header" href="#stable-identifiers-uuids">Stable Identifiers (UUIDs)</a></h3>
<p>Each requirement has a UUID that never changes, even if the requirement is renumbered or renamed. This enables reliable traceability over time.</p>
<pre><code class="language-yaml">uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a  # Stable forever
hrid: USR-001                                # Might change
</code></pre>
<h3 id="human-readable-ids-hrids"><a class="header" href="#human-readable-ids-hrids">Human-Readable IDs (HRIDs)</a></h3>
<p>While UUIDs are stable, HRIDs like <code>USR-001</code> make traceability human-friendly:</p>
<ul>
<li>Easy to reference in conversations: "Did you implement USR-042?"</li>
<li>Clear in code comments: <code>// Satisfies SYS-078</code></li>
<li>Readable in reports: "Coverage: 45 of 52 SYS requirements implemented"</li>
</ul>
<h3 id="multiple-parents"><a class="header" href="#multiple-parents">Multiple Parents</a></h3>
<p>Unlike many tools, Requiem supports multiple parent requirements:</p>
<pre><code class="language-yaml">parents:
- uuid: &lt;uuid-1&gt;
  hrid: USR-001
- uuid: &lt;uuid-2&gt;
  hrid: USR-003
- uuid: &lt;uuid-3&gt;
  hrid: USR-007
</code></pre>
<p>This reflects reality: a single implementation often satisfies multiple needs.</p>
<p>Example: A logging system might satisfy requirements for debugging, auditing, and compliance - three different parent needs.</p>
<h2 id="traceability-beyond-requiem"><a class="header" href="#traceability-beyond-requiem">Traceability Beyond Requiem</a></h2>
<p>Requiem manages requirement-to-requirement traceability. For complete lifecycle traceability, you need:</p>
<h3 id="requirement--code"><a class="header" href="#requirement--code">Requirement ‚Üí Code</a></h3>
<p><strong>Manual approach:</strong> Add requirement IDs in comments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Satisfies: SYS-042, SYS-043
fn validate_email(email: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Automated approach:</strong> Use code analysis tools to extract these tags and build traceability matrices.</p>
<h3 id="requirement--tests"><a class="header" href="#requirement--tests">Requirement ‚Üí Tests</a></h3>
<p><strong>Manual approach:</strong> Reference requirements in test names or docstrings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_usr_042_email_validation() {
    // Verifies USR-042: Email validation feedback
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Automated approach:</strong> Tools can parse test names and generate coverage reports.</p>
<h3 id="requirement--documentation"><a class="header" href="#requirement--documentation">Requirement ‚Üí Documentation</a></h3>
<p>When using Requiem with MdBook or Sphinx, you can embed requirements directly in user documentation:</p>
<pre><code class="language-markdown">## Plain Text Storage

---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---
# Plain Text Storage

## Statement

The tool shall store requirements as plain-text files that can be read and edited with any text editor.

## Rationale

Plain text storage enables:
- Version control integration with Git and other VCS tools
- Human review without specialized software
- Long-term archival and accessibility
- Integration with existing text-based workflows

## Acceptance Criteria

- Requirements are stored as `.md` (Markdown) files
- Files can be opened and edited in any text editor
- No proprietary or binary formats are required
- Files are compatible with standard version control systems

Requirements are stored as simple markdown files.
</code></pre>
<p>This ensures documentation stays synchronized with requirements.</p>
<h2 id="traceability-challenges"><a class="header" href="#traceability-challenges">Traceability Challenges</a></h2>
<h3 id="maintaining-links"><a class="header" href="#maintaining-links">Maintaining Links</a></h3>
<p>Manual traceability is prone to drift:</p>
<ul>
<li>Code changes but requirement IDs in comments aren't updated</li>
<li>Tests are renamed and traceability is lost</li>
</ul>
<p><strong>Mitigation:</strong> Automate checks in CI. Use tools to validate that referenced requirement IDs exist.</p>
<h3 id="granularity"><a class="header" href="#granularity">Granularity</a></h3>
<p>How fine-grained should traceability be?</p>
<ul>
<li>Too coarse: "This module satisfies USR-001 through USR-050" (not helpful)</li>
<li>Too fine: "This line satisfies requirement X clause 2.3.1.4" (maintenance nightmare)</li>
</ul>
<p><strong>Balance:</strong> Trace at the function/class level for code, at the test case level for tests.</p>
<h3 id="many-to-many-relationships"><a class="header" href="#many-to-many-relationships">Many-to-Many Relationships</a></h3>
<p>Real systems have complex relationships:</p>
<ul>
<li>One requirement satisfied by multiple components</li>
<li>One component satisfying multiple requirements</li>
</ul>
<p>Requiem's multiple-parent support helps, but complete traceability requires additional tooling.</p>
<h2 id="traceability-reports"><a class="header" href="#traceability-reports">Traceability Reports</a></h2>
<p><em>Note: Automated report generation is planned but not yet implemented in Requiem.</em></p>
<p>Common traceability reports include:</p>
<h3 id="coverage-matrix"><a class="header" href="#coverage-matrix">Coverage Matrix</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Designed</th><th>Implemented</th><th>Tested</th><th>Status</th></tr></thead><tbody>
<tr><td>USR-001</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>Complete</td></tr>
<tr><td>USR-002</td><td>‚úì</td><td>‚úì</td><td>‚úó</td><td>Missing Tests</td></tr>
<tr><td>USR-003</td><td>‚úì</td><td>‚úó</td><td>‚úó</td><td>Not Implemented</td></tr>
</tbody></table>
</div>
<h3 id="dependency-graph"><a class="header" href="#dependency-graph">Dependency Graph</a></h3>
<p>Visual representation of requirement relationships, showing the complete hierarchy from stakeholder needs down to implementation.</p>
<h3 id="impact-report"><a class="header" href="#impact-report">Impact Report</a></h3>
<p>Given a changed requirement, list all downstream requirements, design documents, code, and tests that might be affected.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Link early</strong> - Establish traceability when creating requirements, not as an afterthought</li>
<li><strong>Use consistent formats</strong> - Standardize how you reference requirements in code and tests</li>
<li><strong>Automate verification</strong> - Add CI checks that validate traceability links</li>
<li><strong>Review regularly</strong> - Periodically audit traceability to catch drift</li>
<li><strong>Keep it simple</strong> - Traceability is valuable only if maintained; avoid overly complex schemes</li>
</ol>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Understanding traceability enables effective change management. Continue to <a href="core-concepts/./change-management.html">Change Management</a> to learn how Requiem helps you manage evolving requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="change-management-1"><a class="header" href="#change-management-1">Change Management</a></h1>
<p>Requirements change. Users discover new needs, technology evolves, regulations update, and understanding deepens. Effective requirements management doesn't fight change - it embraces and manages it.</p>
<h2 id="why-requirements-change"><a class="header" href="#why-requirements-change">Why Requirements Change</a></h2>
<p>Common drivers of change:</p>
<ul>
<li><strong>Evolving understanding</strong> - Stakeholders clarify needs as they see prototypes</li>
<li><strong>External factors</strong> - New regulations, competitor features, market shifts</li>
<li><strong>Technical discoveries</strong> - Implementation reveals previously unknown constraints</li>
<li><strong>Scope refinement</strong> - Priorities shift as the project progresses</li>
<li><strong>Error correction</strong> - Requirements contained mistakes or ambiguities</li>
</ul>
<h2 id="change-management-goals"><a class="header" href="#change-management-goals">Change Management Goals</a></h2>
<p>Effective change management aims to:</p>
<ol>
<li><strong>Track changes</strong> - Know what changed, when, and why</li>
<li><strong>Analyze impact</strong> - Understand ripple effects before committing</li>
<li><strong>Notify stakeholders</strong> - Alert affected parties</li>
<li><strong>Trigger reviews</strong> - Ensure dependent artifacts are updated</li>
<li><strong>Maintain history</strong> - Preserve the evolution for audit and learning</li>
</ol>
<h2 id="requiems-change-management-features"><a class="header" href="#requiems-change-management-features">Requiem's Change Management Features</a></h2>
<h3 id="content-fingerprinting"><a class="header" href="#content-fingerprinting">Content Fingerprinting</a></h3>
<p>Every requirement has a <strong>fingerprint</strong> - a SHA256 hash of its content:</p>
<pre><code class="language-yaml">parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
</code></pre>
<p>When a parent requirement changes, its fingerprint changes. This allows child requirements to detect that their parent has been modified.</p>
<h3 id="how-fingerprinting-works"><a class="header" href="#how-fingerprinting-works">How Fingerprinting Works</a></h3>
<p>The fingerprint is computed from:</p>
<ul>
<li>The requirement's text content (markdown body)</li>
<li>Any tags on the requirement</li>
</ul>
<p>It does <strong>not</strong> include:</p>
<ul>
<li>UUID (never changes)</li>
<li>HRID (might be renumbered)</li>
<li>Creation timestamp</li>
<li>Parent relationships</li>
</ul>
<p>This means fingerprints change <strong>only when meaningful content changes</strong>.</p>
<h3 id="detecting-changes"><a class="header" href="#detecting-changes">Detecting Changes</a></h3>
<p>When a parent requirement is edited, its fingerprint becomes stale in child requirements:</p>
<pre><code class="language-yaml"># Parent USR-001 was edited, fingerprint is now abc123...
# But child still references old fingerprint:
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda  # Old!
  hrid: USR-001
</code></pre>
<p><em>Note: Automated detection of stale fingerprints and triggering reviews is planned but not yet implemented.</em></p>
<h3 id="version-control-integration-1"><a class="header" href="#version-control-integration-1">Version Control Integration</a></h3>
<p>Requiem's plain-text format provides powerful change management through Git:</p>
<h4 id="viewing-changes"><a class="header" href="#viewing-changes">Viewing Changes</a></h4>
<pre><code class="language-bash">git diff USR-001.md
</code></pre>
<p>Shows exactly what changed:</p>
<pre><code class="language-diff">-Users shall be able to create tasks with a title and description.
+Users shall be able to create tasks with a title, description, and due date.
</code></pre>
<h4 id="change-history"><a class="header" href="#change-history">Change History</a></h4>
<pre><code class="language-bash">git log --follow USR-001.md
</code></pre>
<p>Shows complete history of a requirement, including:</p>
<ul>
<li>Who changed it</li>
<li>When it changed</li>
<li>Why (from commit messages)</li>
</ul>
<h4 id="blameannotate"><a class="header" href="#blameannotate">Blame/Annotate</a></h4>
<pre><code class="language-bash">git blame USR-001.md
</code></pre>
<p>Shows who last modified each line, useful for finding the source of specific clauses.</p>
<h2 id="change-workflow"><a class="header" href="#change-workflow">Change Workflow</a></h2>
<p>A typical requirement change workflow:</p>
<h3 id="1-propose-change"><a class="header" href="#1-propose-change">1. Propose Change</a></h3>
<p>Create a branch:</p>
<pre><code class="language-bash">git checkout -b update-authentication-requirements
</code></pre>
<p>Edit the requirement:</p>
<pre><code class="language-markdown"># USR-001.md
-Users shall authenticate using username and password.
+Users shall authenticate using username and password, or via OAuth providers (Google, GitHub).
</code></pre>
<h3 id="2-analyze-impact"><a class="header" href="#2-analyze-impact">2. Analyze Impact</a></h3>
<p>Identify affected requirements:</p>
<pre><code class="language-bash"># Find requirements that reference USR-001
grep -r "USR-001" *.md
</code></pre>
<p>Review child requirements to see if they need updates:</p>
<ul>
<li>SYS-042: "System shall hash passwords with bcrypt" - Still valid</li>
<li>SYS-043: "System shall rate-limit login attempts" - Needs OAuth rate limiting too!</li>
</ul>
<h3 id="3-update-dependent-requirements"><a class="header" href="#3-update-dependent-requirements">3. Update Dependent Requirements</a></h3>
<p>Update child requirements to reflect the change:</p>
<pre><code class="language-markdown"># SYS-043.md
-The system shall rate-limit password login attempts to 5 per minute.
+The system shall rate-limit authentication attempts to 5 per minute, including both password and OAuth flows.
</code></pre>
<h3 id="4-review-and-approve"><a class="header" href="#4-review-and-approve">4. Review and Approve</a></h3>
<p>Create a pull request:</p>
<pre><code class="language-bash">git add USR-001.md SYS-043.md
git commit -m "Add OAuth authentication to USR-001 and update rate limiting in SYS-043"
git push origin update-authentication-requirements
</code></pre>
<p>The PR shows:</p>
<ul>
<li>Exact changes (diff)</li>
<li>Affected requirements</li>
<li>Commit message explaining rationale</li>
</ul>
<p>Stakeholders review and approve.</p>
<h3 id="5-merge-and-notify"><a class="header" href="#5-merge-and-notify">5. Merge and Notify</a></h3>
<p>After approval, merge the PR. Git history preserves:</p>
<ul>
<li>What changed</li>
<li>When it changed</li>
<li>Who approved it</li>
<li>Why it changed (commit message)</li>
</ul>
<h2 id="change-impact-analysis"><a class="header" href="#change-impact-analysis">Change Impact Analysis</a></h2>
<p>Understanding the impact of a change is crucial. Requiem helps through:</p>
<h3 id="parent-child-relationships"><a class="header" href="#parent-child-relationships">Parent-Child Relationships</a></h3>
<p>If requirement X changes, all child requirements <strong>may</strong> be affected. Review each to determine if updates are needed.</p>
<h3 id="multiple-parents-1"><a class="header" href="#multiple-parents-1">Multiple Parents</a></h3>
<p>When a requirement has multiple parents and one changes, evaluate:</p>
<ul>
<li>Does the change conflict with other parents?</li>
<li>Do child requirements still satisfy all parents?</li>
</ul>
<p>Example:</p>
<pre><code>USR-001: "Fast performance"
USR-002: "Strong encryption"
   ‚îî‚îÄ SYS-042: "Use AES-256 encryption"
</code></pre>
<p>If USR-001 changes to require sub-millisecond response times, SYS-042's encryption choice might need reconsideration (encryption adds latency).</p>
<h2 id="review-triggers"><a class="header" href="#review-triggers">Review Triggers</a></h2>
<p><em>Note: Automated review triggering is planned but not yet implemented.</em></p>
<p>In the future, Requiem will support:</p>
<h3 id="automatic-review-flags"><a class="header" href="#automatic-review-flags">Automatic Review Flags</a></h3>
<p>When a requirement changes:</p>
<ol>
<li>Its fingerprint updates</li>
<li>Child requirements detect stale fingerprints</li>
<li>Those requirements are flagged for review</li>
<li>Reviews can be assigned to stakeholders</li>
<li>Requirements are approved or updated</li>
<li>Fingerprints are refreshed</li>
</ol>
<h3 id="review-states"><a class="header" href="#review-states">Review States</a></h3>
<p>Possible states:</p>
<ul>
<li><strong>Current</strong> - Fingerprint matches parent</li>
<li><strong>Suspect</strong> - Parent changed, review needed</li>
<li><strong>Under Review</strong> - Assigned for review</li>
<li><strong>Approved</strong> - Reviewed and still valid despite parent change</li>
</ul>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-write-meaningful-commit-messages"><a class="header" href="#1-write-meaningful-commit-messages">1. Write Meaningful Commit Messages</a></h3>
<pre><code class="language-bash"># Bad
git commit -m "Update requirements"

# Good
git commit -m "Add due date support to USR-001 per stakeholder feedback from 2025-10-15 meeting"
</code></pre>
<h3 id="2-link-changes-to-issues"><a class="header" href="#2-link-changes-to-issues">2. Link Changes to Issues</a></h3>
<p>Reference issue trackers in commits:</p>
<pre><code class="language-bash">git commit -m "Update authentication requirements (resolves #42)"
</code></pre>
<h3 id="3-review-dependent-requirements"><a class="header" href="#3-review-dependent-requirements">3. Review Dependent Requirements</a></h3>
<p>When changing a requirement, always:</p>
<ul>
<li>Search for references to its HRID</li>
<li>Review child requirements</li>
<li>Check related documentation</li>
<li>Update tests</li>
</ul>
<h3 id="4-use-branches-for-changes"><a class="header" href="#4-use-branches-for-changes">4. Use Branches for Changes</a></h3>
<p>Never modify requirements directly on main:</p>
<ul>
<li>Create a branch</li>
<li>Make changes</li>
<li>Get review</li>
<li>Merge</li>
</ul>
<p>This creates an audit trail and enables discussion before commitment.</p>
<h3 id="5-batch-related-changes"><a class="header" href="#5-batch-related-changes">5. Batch Related Changes</a></h3>
<p>If changing USR-001 requires updating SYS-042 and SYS-043, do it in one commit:</p>
<pre><code class="language-bash">git add USR-001.md SYS-042.md SYS-043.md
git commit -m "Extend authentication to support OAuth (USR-001, SYS-042, SYS-043)"
</code></pre>
<p>This preserves the logical relationship between changes.</p>
<h2 id="change-metrics"><a class="header" href="#change-metrics">Change Metrics</a></h2>
<p>Useful metrics for requirement stability:</p>
<ul>
<li><strong>Churn rate</strong> - How often requirements change</li>
<li><strong>Ripple effect</strong> - Average number of requirements affected by a change</li>
<li><strong>Review latency</strong> - Time from change to review completion</li>
<li><strong>Approval rate</strong> - Percentage of proposed changes accepted</li>
</ul>
<p>High churn in high-level requirements (USR) may indicate poor initial understanding. High churn in low-level requirements (SWR) may be normal as implementation details evolve.</p>
<h2 id="handling-breaking-changes"><a class="header" href="#handling-breaking-changes">Handling Breaking Changes</a></h2>
<p>Some changes invalidate child requirements:</p>
<p><strong>Example:</strong> USR-001 requires "single-user application," but later changes to "multi-user application."</p>
<p>SYS requirements assuming single-user (no authentication, shared global state) are now invalid.</p>
<p><strong>Process:</strong></p>
<ol>
<li>Mark affected requirements as "obsolete" or delete them</li>
<li>Create new requirements for multi-user scenario</li>
<li>Update traceability links</li>
<li>Document the change rationale</li>
</ol>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Now that you understand how requirements change, see how Requiem's design supports these practices: <a href="core-concepts/./requiem-approach.html">How Requiem Supports These Principles</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-requiem-supports-these-principles"><a class="header" href="#how-requiem-supports-these-principles">How Requiem Supports These Principles</a></h1>
<p>Now that you understand requirements management principles, let's explore how Requiem's design choices support these practices.</p>
<h2 id="plain-text-the-foundation"><a class="header" href="#plain-text-the-foundation">Plain Text: The Foundation</a></h2>
<p>Requiem's most fundamental decision is storing requirements as plain text (Markdown with YAML frontmatter).</p>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p><strong>Human Readable</strong>: Anyone with a text editor can read and edit requirements. No specialized tools required.</p>
<pre><code class="language-markdown">---
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
---

Users shall be able to export data in CSV format.
</code></pre>
<p>This is instantly understandable to developers, managers, and stakeholders alike.</p>
<p><strong>Version Control Native</strong>: Plain text integrates seamlessly with Git, providing:</p>
<ul>
<li>Line-by-line diffs showing exactly what changed</li>
<li>Complete history with blame and log</li>
<li>Pull request workflows for review</li>
<li>Branching and merging for parallel development</li>
</ul>
<p><strong>Tool Agnostic</strong>: Requirements aren't locked into proprietary formats. You can:</p>
<ul>
<li>Search with grep/ripgrep</li>
<li>Process with scripts (Python, Bash, etc.)</li>
<li>View in any text editor or IDE</li>
<li>Preview as rendered Markdown</li>
<li>Process with static site generators</li>
</ul>
<p><strong>Future Proof</strong>: Plain text files from 1970 are still readable today. Your requirements will outlive any proprietary tool.</p>
<h3 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h3>
<p><strong>No GUI</strong>: Requiem doesn't provide a graphical interface. Users must be comfortable with text editors and the command line.</p>
<p><strong>No Real-time Collaboration</strong>: Unlike cloud-based tools, Requiem doesn't support simultaneous editing. Use Git workflows instead.</p>
<h2 id="dual-identifiers-stability-and-usability"><a class="header" href="#dual-identifiers-stability-and-usability">Dual Identifiers: Stability and Usability</a></h2>
<p>Requiem uses both UUIDs and Human-Readable IDs (HRIDs).</p>
<h3 id="uuids-stable-references"><a class="header" href="#uuids-stable-references">UUIDs: Stable References</a></h3>
<pre><code class="language-yaml">uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
</code></pre>
<p><strong>Purpose</strong>: Permanent, globally unique identifier that never changes.</p>
<p><strong>Enables</strong>:</p>
<ul>
<li>Renumbering requirements without breaking links</li>
<li>Merging requirement sets from different sources</li>
<li>Machine processing and indexing</li>
</ul>
<p><strong>Example</strong>: You can rename <code>USR-001</code> to <code>AUTH-001</code> without breaking any parent references, because they use the UUID.</p>
<h3 id="hrids-human-communication"><a class="header" href="#hrids-human-communication">HRIDs: Human Communication</a></h3>
<pre><code class="language-yaml">hrid: USR-001
</code></pre>
<p><strong>Purpose</strong>: Short, memorable identifier for human use.</p>
<p><strong>Enables</strong>:</p>
<ul>
<li>Easy verbal communication: "Did you implement USR-042?"</li>
<li>Clear code comments: <code>// Satisfies SYS-078</code></li>
<li>Intuitive filenames: <code>USR-001.md</code></li>
</ul>
<p><strong>Example</strong>: In a meeting, saying "UUID 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a" is impractical. "USR-001" is clear and concise.</p>
<h3 id="best-of-both-worlds"><a class="header" href="#best-of-both-worlds">Best of Both Worlds</a></h3>
<p>Parent relationships use UUIDs but store HRIDs for convenience:</p>
<pre><code class="language-yaml">parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a  # For machine processing
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001  # For human readers
</code></pre>
<p>The <code>req clean</code> command corrects HRIDs if requirements are renumbered, maintaining human-readability while UUIDs ensure correctness.</p>
<h2 id="content-fingerprinting-change-detection"><a class="header" href="#content-fingerprinting-change-detection">Content Fingerprinting: Change Detection</a></h2>
<p>Every requirement's content is hashed to create a fingerprint:</p>
<pre><code class="language-yaml">fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>The fingerprint is a SHA256 hash of:</p>
<ul>
<li>The requirement text (markdown body)</li>
<li>Any tags</li>
</ul>
<p>This means:</p>
<ul>
<li>‚úì Changing the requirement text ‚Üí new fingerprint</li>
<li>‚úì Adding/removing tags ‚Üí new fingerprint</li>
<li>‚úó Changing HRID ‚Üí same fingerprint (HRID is just a label)</li>
<li>‚úó Adding parents ‚Üí same fingerprint (relationships are separate)</li>
</ul>
<h3 id="enables-change-detection"><a class="header" href="#enables-change-detection">Enables Change Detection</a></h3>
<p>When a parent requirement changes:</p>
<ol>
<li>Parent's fingerprint updates</li>
<li>Children still have old fingerprint</li>
<li>Children are "suspect" - they might need review</li>
</ol>
<p><em>Note: Automatic detection is planned but not yet implemented. Currently, you detect stale fingerprints manually or via scripts.</em></p>
<h3 id="future-review-workflows"><a class="header" href="#future-review-workflows">Future: Review Workflows</a></h3>
<p>Planned features:</p>
<ul>
<li>Automatically flag requirements with stale parent fingerprints</li>
<li>Assign reviews to stakeholders</li>
<li>Track review status (current, suspect, under review, approved)</li>
<li>Generate reports of suspect requirements</li>
</ul>
<h2 id="multiple-parents-modeling-reality"><a class="header" href="#multiple-parents-modeling-reality">Multiple Parents: Modeling Reality</a></h2>
<p>Many requirements management tools force a strict tree hierarchy. Requiem supports <strong>multiple parents</strong> because that's how real systems work.</p>
<h3 id="why-multiple-parents-matter"><a class="header" href="#why-multiple-parents-matter">Why Multiple Parents Matter</a></h3>
<p>Example: A logging system might satisfy:</p>
<ul>
<li>USR-042: "Debugging capability"</li>
<li>USR-078: "Audit trail for compliance"</li>
<li>USR-091: "Performance monitoring"</li>
</ul>
<p>Representing this as a tree forces artificial choices:</p>
<pre><code># Tree (artificial)
USR-042 (Debugging)
  ‚îî‚îÄ SYS-123 (Logging)  # Also satisfies USR-078 and USR-091, but structure doesn't show this
</code></pre>
<p>With multiple parents:</p>
<pre><code>SYS-123 (Logging)
  ‚îú‚îÄ USR-042 (Debugging)
  ‚îú‚îÄ USR-078 (Audit trail)
  ‚îî‚îÄ USR-091 (Performance monitoring)
</code></pre>
<p>This accurately models the requirement's purpose.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<pre><code class="language-yaml">parents:
- uuid: &lt;uuid-1&gt;
  hrid: USR-042
- uuid: &lt;uuid-2&gt;
  hrid: USR-078
- uuid: &lt;uuid-3&gt;
  hrid: USR-091
</code></pre>
<h3 id="trade-off-cycles"><a class="header" href="#trade-off-cycles">Trade-off: Cycles</a></h3>
<p>Multiple parents enable <strong>cycles</strong> (requirement A depends on B depends on A). Cycles are usually errors.</p>
<p><em>Note: Cycle detection is planned but not yet implemented.</em></p>
<h2 id="namespace-support-scaling-to-large-projects"><a class="header" href="#namespace-support-scaling-to-large-projects">Namespace Support: Scaling to Large Projects</a></h2>
<p>HRIDs support optional namespaces:</p>
<pre><code>USR-001              # Simple
COMPONENT-USR-001    # One namespace level
AUTH-LOGIN-SYS-042   # Multiple namespace levels
</code></pre>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<p><strong>Large projects</strong>: Partition requirements by subsystem</p>
<pre><code>AUTH-USR-001    # Authentication user requirements
AUTH-SYS-001
PAYMENT-USR-001 # Payment user requirements
PAYMENT-SYS-001
</code></pre>
<p><strong>Product families</strong>: Distinguish product-specific vs. shared requirements</p>
<pre><code>CORE-SYS-001    # Shared across all products
MOBILE-USR-001  # Mobile app specific
WEB-USR-001     # Web app specific
</code></pre>
<p><strong>Acquisitions/Mergers</strong>: Integrate requirement sets without renumbering</p>
<pre><code>LEGACY-SYS-001  # From acquired company
NEW-SYS-001     # Newly created
</code></pre>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<p>Namespaces are part of the HRID format:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Format: {NAMESPACE*}-{KIND}-{ID}
NAMESPACE-NAMESPACE-KIND-042
<span class="boring">}</span></code></pre></pre>
<p>Configure allowed namespaces in <code>config.toml</code> (optional).</p>
<h2 id="configuration-and-flexibility"><a class="header" href="#configuration-and-flexibility">Configuration and Flexibility</a></h2>
<p>Requiem provides sane defaults but allows customization:</p>
<h3 id="configtoml"><a class="header" href="#configtoml">config.toml</a></h3>
<pre><code class="language-toml">_version = "1"

# Restrict to specific requirement kinds
allowed_kinds = ["USR", "SYS", "SWR", "TST"]

# Digits in HRID numbering (e.g., 001 vs 0001)
digits = 3

# Allow markdown files that aren't requirements
allow_unrecognised = false

# Allow requirements with invalid format
allow_invalid = false
</code></pre>
<p>This balances flexibility (customize as needed) with safety (defaults prevent common errors).</p>
<h2 id="integration-philosophy-compose-dont-replace"><a class="header" href="#integration-philosophy-compose-dont-replace">Integration Philosophy: Compose, Don't Replace</a></h2>
<p>Requiem integrates with existing tools rather than replacing them:</p>
<h3 id="documentation-tools"><a class="header" href="#documentation-tools">Documentation Tools</a></h3>
<p>Use with <strong>MdBook</strong> or <strong>Sphinx</strong> to embed requirements in user documentation:</p>
<pre><code class="language-markdown"># User Guide - Data Export

---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---
# Plain Text Storage

## Statement

The tool shall store requirements as plain-text files that can be read and edited with any text editor.

## Rationale

Plain text storage enables:
- Version control integration with Git and other VCS tools
- Human review without specialized software
- Long-term archival and accessibility
- Integration with existing text-based workflows

## Acceptance Criteria

- Requirements are stored as `.md` (Markdown) files
- Files can be opened and edited in any text editor
- No proprietary or binary formats are required
- Files are compatible with standard version control systems

To export data, click the Export button...
</code></pre>
<p>Requirements stay synchronized with documentation automatically.</p>
<h3 id="version-control"><a class="header" href="#version-control">Version Control</a></h3>
<p>Works naturally with <strong>Git</strong> workflows:</p>
<ul>
<li>Feature branches for requirement changes</li>
<li>Pull requests for review</li>
<li>Merge commits for approval</li>
<li>Tags for releases/versions</li>
</ul>
<h3 id="static-analysis"><a class="header" href="#static-analysis">Static Analysis</a></h3>
<p>Plain-text enables custom tooling:</p>
<pre><code class="language-bash"># Find all USR requirements not linked by any SYS requirement
comm -23 \
  &lt;(ls USR-*.md | sort) \
  &lt;(grep -oh "USR-[0-9]*" SYS-*.md | sort -u)
</code></pre>
<h3 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h3>
<p>Add requirement validation to CI:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml
- name: Validate requirements
  run: req clean --dry-run  # Check HRIDs are correct
</code></pre>
<h2 id="performance-built-for-scale"><a class="header" href="#performance-built-for-scale">Performance: Built for Scale</a></h2>
<p>Requiem is written in Rust and uses parallelism for operations on large requirement sets.</p>
<h3 id="parallel-loading"><a class="header" href="#parallel-loading">Parallel Loading</a></h3>
<p>When loading a directory with thousands of requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Uses rayon for parallel iteration
let requirements: Vec&lt;_&gt; = md_paths
    .par_iter()
    .map(|path| load_requirement(path))
    .collect();
<span class="boring">}</span></code></pre></pre>
<p>This means Requiem scales to large projects (1000s of requirements) without becoming sluggish.</p>
<h3 id="efficient-indexing"><a class="header" href="#efficient-indexing">Efficient Indexing</a></h3>
<p>Requirements are indexed by UUID in a HashMap, enabling O(1) lookups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let req = tree.requirement(uuid);  // Constant time
<span class="boring">}</span></code></pre></pre>
<h2 id="design-trade-offs"><a class="header" href="#design-trade-offs">Design Trade-offs</a></h2>
<p>Every design involves trade-offs. Requiem prioritizes:</p>
<p><strong>Over</strong> graphical interfaces: <strong>Plain text and CLI</strong></p>
<ul>
<li>Pro: Version control, scripting, no vendor lock-in</li>
<li>Con: Steeper learning curve for non-technical users</li>
</ul>
<p><strong>Over</strong> centralized databases: <strong>Distributed files</strong></p>
<ul>
<li>Pro: Works offline, natural with Git, simple deployment</li>
<li>Con: No real-time collaboration, requires file system access</li>
</ul>
<p><strong>Over</strong> strict tree hierarchies: <strong>Multiple parents (DAGs)</strong></p>
<ul>
<li>Pro: Models reality accurately</li>
<li>Con: Enables cycles (requires detection)</li>
</ul>
<p><strong>Over</strong> comprehensive built-in features: <strong>Composability</strong></p>
<ul>
<li>Pro: Integrate with existing tools, stay focused</li>
<li>Con: Some features require external tools or scripts</li>
</ul>
<h2 id="summary-why-requiem"><a class="header" href="#summary-why-requiem">Summary: Why Requiem?</a></h2>
<p>Requiem's design supports requirements management principles through:</p>
<ol>
<li><strong>Plain text</strong> - Readable, versionable, future-proof</li>
<li><strong>Dual identifiers</strong> - Stable UUIDs + usable HRIDs</li>
<li><strong>Fingerprinting</strong> - Detect changes, enable reviews</li>
<li><strong>Multiple parents</strong> - Model complex dependencies accurately</li>
<li><strong>Namespace support</strong> - Scale to large, multi-component projects</li>
<li><strong>Composable</strong> - Works with Git, MdBook, Sphinx, custom tools</li>
<li><strong>Fast</strong> - Parallel processing for large requirement sets</li>
</ol>
<p>These choices make Requiem a powerful tool for teams that value:</p>
<ul>
<li>Version control integration</li>
<li>Plain-text workflows</li>
<li>Speed and scalability</li>
<li>Flexibility and composability</li>
</ul>
<p>Ready to dive deeper into practical usage? Continue to <a href="core-concepts/../working-with-requirements.html">Working with Requirements</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-requirements"><a class="header" href="#working-with-requirements">Working with Requirements</a></h1>
<p>This chapter covers the practical aspects of using Requiem day-to-day. You'll learn the requirement file format, how to create and link requirements, and how to manage complex requirement relationships.</p>
<h2 id="chapters-1"><a class="header" href="#chapters-1">Chapters</a></h2>
<ul>
<li><strong><a href="./working-with-requirements/file-format.html">Requirement File Format</a></strong> - Understanding the YAML frontmatter and markdown structure</li>
<li><strong><a href="./working-with-requirements/hrids.html">Human-Readable IDs (HRIDs)</a></strong> - Deep dive into HRID syntax and best practices</li>
<li><strong><a href="./working-with-requirements/creating.html">Creating Requirements</a></strong> - Using <code>req add</code> effectively</li>
<li><strong><a href="./working-with-requirements/linking.html">Linking Requirements</a></strong> - Establishing parent-child relationships</li>
<li><strong><a href="./working-with-requirements/relationships.html">Managing Relationships</a></strong> - Working with complex dependency graphs</li>
</ul>
<p>By the end of this chapter, you'll be proficient in all core Requiem operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirement-file-format"><a class="header" href="#requirement-file-format">Requirement File Format</a></h1>
<p>Requiem requirements are stored as markdown files with YAML frontmatter. This chapter explains the format in detail.</p>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<p>A requirement file has two parts:</p>
<ol>
<li><strong>YAML Frontmatter</strong> - Metadata enclosed in <code>---</code> delimiters</li>
<li><strong>Markdown Body</strong> - The requirement text</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
---

The system shall validate user email addresses according to RFC 5322.

Email validation must occur before account creation.
</code></pre>
<h2 id="yaml-frontmatter"><a class="header" href="#yaml-frontmatter">YAML Frontmatter</a></h2>
<p>The frontmatter contains structured metadata.</p>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<h4 id="_version"><a class="header" href="#_version"><code>_version</code></a></h4>
<pre><code class="language-yaml">_version: '1'
</code></pre>
<p><strong>Purpose</strong>: Format version for future compatibility.</p>
<p><strong>Value</strong>: Currently always <code>'1'</code> (quoted string).</p>
<p><strong>Why it matters</strong>: If Requiem's file format evolves, this field allows newer versions to handle older files correctly.</p>
<h4 id="uuid"><a class="header" href="#uuid"><code>uuid</code></a></h4>
<pre><code class="language-yaml">uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
</code></pre>
<p><strong>Purpose</strong>: Globally unique, stable identifier.</p>
<p><strong>Value</strong>: UUIDv4 (automatically generated by <code>req add</code>).</p>
<p><strong>Why it matters</strong>: This never changes, even if the requirement is renumbered. Parent-child relationships use UUIDs, ensuring links remain valid.</p>
<h4 id="created"><a class="header" href="#created"><code>created</code></a></h4>
<pre><code class="language-yaml">created: 2025-07-22T12:19:56.950194157Z
</code></pre>
<p><strong>Purpose</strong>: Timestamp of requirement creation.</p>
<p><strong>Value</strong>: ISO 8601 format with timezone (always UTC).</p>
<p><strong>Why it matters</strong>: Provides audit trail and helps understand requirement evolution.</p>
<h3 id="optional-fields"><a class="header" href="#optional-fields">Optional Fields</a></h3>
<h4 id="parents"><a class="header" href="#parents"><code>parents</code></a></h4>
<pre><code class="language-yaml">parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
- uuid: 7a8f9e2b-1c3d-4e5f-6a7b-8c9d0e1f2a3b
  fingerprint: a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456
  hrid: USR-003
</code></pre>
<p><strong>Purpose</strong>: Links to parent (upstream) requirements.</p>
<p><strong>Value</strong>: List of parent objects, each containing:</p>
<ul>
<li><code>uuid</code> - Parent's stable identifier</li>
<li><code>fingerprint</code> - SHA256 hash of parent's content</li>
<li><code>hrid</code> - Parent's human-readable ID (for convenience)</li>
</ul>
<p><strong>Why it matters</strong>: Establishes traceability. Multiple parents are supported.</p>
<p><strong>Note</strong>: This field is absent if the requirement has no parents (e.g., top-level user requirements).</p>
<h4 id="tags-planned"><a class="header" href="#tags-planned"><code>tags</code> (planned)</a></h4>
<pre><code class="language-yaml">tags:
- security
- authentication
- high-priority
</code></pre>
<p><strong>Purpose</strong>: Categorize and filter requirements.</p>
<p><strong>Status</strong>: The data structure supports tags, but there are no CLI commands to manage them yet. You can manually add tags to the YAML.</p>
<p><strong>Future</strong>: Commands like <code>req tag add USR-001 security</code> will manage tags.</p>
<h2 id="markdown-body"><a class="header" href="#markdown-body">Markdown Body</a></h2>
<p>The body contains the actual requirement text, written in Markdown.</p>
<h3 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h3>
<h4 id="use-clear-language"><a class="header" href="#use-clear-language">Use Clear Language</a></h4>
<pre><code class="language-markdown"># Good
The system shall validate email addresses before account creation.

# Less clear
Email validation is performed.
</code></pre>
<p>Use "shall" for mandatory requirements, "should" for recommended, "may" for optional.</p>
<h4 id="one-concept-per-requirement"><a class="header" href="#one-concept-per-requirement">One Concept Per Requirement</a></h4>
<pre><code class="language-markdown"># Bad (multiple concepts)
The system shall validate emails and passwords and usernames.

# Good (split into separate requirements)
# USR-001.md
The system shall validate email addresses.

# USR-002.md
The system shall validate passwords for minimum strength.

# USR-003.md
The system shall validate usernames for uniqueness.
</code></pre>
<h4 id="be-testable"><a class="header" href="#be-testable">Be Testable</a></h4>
<pre><code class="language-markdown"># Bad (not testable)
The system shall be fast.

# Good (testable)
The system shall respond to login requests within 200ms at the 95th percentile.
</code></pre>
<h4 id="include-context"><a class="header" href="#include-context">Include Context</a></h4>
<pre><code class="language-markdown">The system shall hash passwords using bcrypt with a cost factor of 12.

Rationale: Bcrypt is resistant to GPU-based attacks. Cost factor 12 provides
security while maintaining acceptable login performance (&lt; 200ms).
</code></pre>
<h3 id="markdown-features"><a class="header" href="#markdown-features">Markdown Features</a></h3>
<p>You can use any Markdown syntax:</p>
<h4 id="headings"><a class="header" href="#headings">Headings</a></h4>
<pre><code class="language-markdown">## Rationale

The requirement exists because...

## Acceptance Criteria

- Criterion 1
- Criterion 2
</code></pre>
<h4 id="lists"><a class="header" href="#lists">Lists</a></h4>
<pre><code class="language-markdown">The system shall support the following authentication methods:

1. Username and password
2. OAuth (Google, GitHub)
3. SAML SSO
</code></pre>
<h4 id="code-blocks"><a class="header" href="#code-blocks">Code Blocks</a></h4>
<pre><code class="language-markdown">Example API response:

\`\`\`json
{
  "user_id": "4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a",
  "email": "user@example.com"
}
\`\`\`
</code></pre>
<h4 id="emphasis"><a class="header" href="#emphasis">Emphasis</a></h4>
<pre><code class="language-markdown">The system **shall** validate emails. It *should* provide helpful error messages.
</code></pre>
<h2 id="filename-convention"><a class="header" href="#filename-convention">Filename Convention</a></h2>
<p>Filenames must match the requirement's HRID:</p>
<pre><code>USR-001.md
SYS-042.md
COMPONENT-SUBCOMPONENT-SWR-123.md
</code></pre>
<p><strong>Case sensitive</strong>: <code>USR-001.md</code> and <code>usr-001.md</code> are different files (though the latter won't be recognized as a requirement).</p>
<p><strong>Extension</strong>: Must be <code>.md</code>.</p>
<p>If the filename doesn't match the HRID format, Requiem will:</p>
<ul>
<li>Ignore the file (if <code>allow_unrecognised = true</code> in config)</li>
<li>Return an error (if <code>allow_unrecognised = false</code>, the default)</li>
</ul>
<h2 id="parsing-rules"><a class="header" href="#parsing-rules">Parsing Rules</a></h2>
<h3 id="frontmatter-delimiters"><a class="header" href="#frontmatter-delimiters">Frontmatter Delimiters</a></h3>
<p>The YAML frontmatter must:</p>
<ul>
<li>Start with <code>---</code> on the first line</li>
<li>End with <code>---</code> on a line by itself</li>
<li>Contain valid YAML</li>
</ul>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---

Requirement text here...
</code></pre>
<h3 id="whitespace"><a class="header" href="#whitespace">Whitespace</a></h3>
<ul>
<li>Leading/trailing whitespace in the body is preserved</li>
<li>Empty lines between frontmatter and body are ignored</li>
</ul>
<pre><code class="language-markdown">---
...frontmatter...
---


This is the first line of the body (empty lines above are ignored).
</code></pre>
<h2 id="editing-requirements"><a class="header" href="#editing-requirements">Editing Requirements</a></h2>
<h3 id="manual-editing"><a class="header" href="#manual-editing">Manual Editing</a></h3>
<p>You can edit requirements with any text editor:</p>
<pre><code class="language-bash">vim USR-001.md
code SYS-042.md
nano TST-003.md
</code></pre>
<p><strong>Caution</strong>: Don't modify the <code>uuid</code> field! This would break traceability.</p>
<p><strong>Safe to edit</strong>:</p>
<ul>
<li>The markdown body (requirement text)</li>
<li>Tags (if present)</li>
</ul>
<p><strong>Requiem manages</strong> (don't edit manually):</p>
<ul>
<li><code>created</code> timestamp</li>
<li>Parent <code>fingerprint</code> fields (updated by linking commands)</li>
</ul>
<h3 id="using-scripts"><a class="header" href="#using-scripts">Using Scripts</a></h3>
<p>Since requirements are plain text, you can process them with scripts:</p>
<pre><code class="language-python"># Add a tag to all USR requirements
import re
import glob

for filename in glob.glob("USR-*.md"):
    with open(filename, 'r') as f:
        content = f.read()

    # Add tag to frontmatter
    content = content.replace(
        "---\n",
        "---\ntags:\n- user-facing\n",
        1  # Only first occurrence
    )

    with open(filename, 'w') as f:
        f.write(content)
</code></pre>
<p><strong>Caution</strong>: Ensure scripts preserve YAML validity. Invalid YAML will cause parsing errors.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Requiem validates requirements when loading:</p>
<pre><code class="language-bash">req clean  # Loads all requirements, reports errors
</code></pre>
<p>Common validation errors:</p>
<ul>
<li><strong>Invalid YAML</strong>: Syntax errors in frontmatter</li>
<li><strong>Missing required fields</strong>: No <code>uuid</code>, <code>created</code>, or <code>_version</code></li>
<li><strong>Invalid UUID</strong>: Malformed UUID string</li>
<li><strong>Invalid timestamp</strong>: Malformed ISO 8601 date</li>
<li><strong>Duplicate UUIDs</strong>: Two requirements with the same UUID (serious error!)</li>
</ul>
<h2 id="file-format-evolution"><a class="header" href="#file-format-evolution">File Format Evolution</a></h2>
<p>The <code>_version</code> field allows future format changes:</p>
<p><strong>Version 1</strong> (current):</p>
<ul>
<li>Fields: <code>_version</code>, <code>uuid</code>, <code>created</code>, <code>parents</code>, <code>tags</code></li>
<li>Parents include UUID, fingerprint, and HRID</li>
</ul>
<p><strong>Version 2</strong> (hypothetical future):</p>
<ul>
<li>Might add: <code>status</code>, <code>priority</code>, <code>owner</code></li>
<li>Older Requiem versions can still read V1 files</li>
</ul>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<p>Want to see actual requirement files following this format? Browse the <a href="working-with-requirements/../requirements.html">Example Project</a> which contains 21 real requirements used by Requiem itself:</p>
<ul>
<li><a href="working-with-requirements/../requirements/USR-001.html">USR-001: Plain Text Storage</a> - Simple user requirement</li>
<li><a href="working-with-requirements/../requirements/SYS-001.html">SYS-001: Markdown File Format with YAML Frontmatter</a> - System requirement with parent link</li>
</ul>
<p>These demonstrate the file format in practice with proper frontmatter, parent links, and well-structured content.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>Now that you understand the file format, learn about <a href="working-with-requirements/./hrids.html">Human-Readable IDs (HRIDs)</a> and their syntax rules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="human-readable-ids-hrids-1"><a class="header" href="#human-readable-ids-hrids-1">Human-Readable IDs (HRIDs)</a></h1>
<p>Human-Readable IDs (HRIDs) are short, memorable identifiers like <code>USR-001</code> or <code>COMPONENT-SYS-042</code>. They make requirements easy to reference in conversations, code comments, and documentation.</p>
<h2 id="hrid-format"><a class="header" href="#hrid-format">HRID Format</a></h2>
<p>The general format is:</p>
<pre><code>{NAMESPACE*}-{KIND}-{ID}
</code></pre>
<p>Where:</p>
<ul>
<li><code>NAMESPACE*</code> = Zero or more namespace segments (optional)</li>
<li><code>KIND</code> = Requirement type/category</li>
<li><code>ID</code> = Numeric identifier</li>
</ul>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<h4 id="namespace-optional"><a class="header" href="#namespace-optional">Namespace (Optional)</a></h4>
<p>Zero or more segments separated by hyphens:</p>
<pre><code>USR-001                          # No namespace
COMPONENT-USR-001                # One namespace level
AUTH-LOGIN-SYS-042               # Two namespace levels
PRODUCT-FEATURE-MODULE-SWR-123   # Three namespace levels
</code></pre>
<p><strong>Purpose</strong>: Organize requirements in large projects or multi-component systems.</p>
<p><strong>Rules</strong>:</p>
<ul>
<li>Each segment must be non-empty</li>
<li>Segments are case-sensitive (by convention, use UPPERCASE)</li>
<li>No special characters (letters, numbers, underscores OK)</li>
</ul>
<h4 id="kind-required"><a class="header" href="#kind-required">Kind (Required)</a></h4>
<p>The requirement category or type:</p>
<pre><code>USR    # User requirements
SYS    # System requirements
SWR    # Software requirements
HWR    # Hardware requirements
TST    # Test requirements
</code></pre>
<p><strong>Purpose</strong>: Distinguish requirement levels in the hierarchy.</p>
<p><strong>Rules</strong>:</p>
<ul>
<li>Must be non-empty</li>
<li>Case-sensitive (by convention, use UPPERCASE)</li>
<li>No special characters</li>
</ul>
<p><strong>Common conventions</strong>:</p>
<ul>
<li><code>USR</code> - User requirements (what users need)</li>
<li><code>SYS</code> - System requirements (technical specifications)</li>
<li><code>SWR</code> - Software requirements (software-specific details)</li>
<li><code>HWR</code> - Hardware requirements (hardware-specific details)</li>
<li><code>TST</code> - Test requirements (test cases)</li>
</ul>
<p>You're free to use any KIND values that make sense for your project.</p>
<h4 id="id-required"><a class="header" href="#id-required">ID (Required)</a></h4>
<p>A positive integer:</p>
<pre><code>USR-1      # Valid
USR-001    # Valid (zero-padded)
USR-42     # Valid
USR-1000   # Valid
</code></pre>
<p><strong>Purpose</strong>: Unique number within the KIND (or NAMESPACE-KIND combination).</p>
<p><strong>Rules</strong>:</p>
<ul>
<li>Must be a positive integer (1, 2, 3, ...)</li>
<li>Zero is not allowed</li>
<li>Negative numbers are not allowed</li>
</ul>
<p><strong>Display format</strong>: IDs are zero-padded to a configurable width (default 3 digits):</p>
<pre><code>USR-001   # 3 digits (default)
USR-042
USR-123
USR-1000  # Exceeds padding, shows all digits
</code></pre>
<p>Configure padding in <code>config.toml</code>:</p>
<pre><code class="language-toml">digits = 3   # USR-001
# or
digits = 4   # USR-0001
</code></pre>
<h2 id="parsing-examples"><a class="header" href="#parsing-examples">Parsing Examples</a></h2>
<h3 id="valid-hrids"><a class="header" href="#valid-hrids">Valid HRIDs</a></h3>
<pre><code>USR-001                      # Simple: KIND-ID
SYS-042                      # Different kind
USR-1                        # No leading zeros
USR-1000                     # Large ID
COMPONENT-USR-001            # One namespace
AUTH-LOGIN-SYS-042           # Two namespaces
A-B-C-D-E-KIND-123           # Five namespaces
</code></pre>
<h3 id="invalid-hrids"><a class="header" href="#invalid-hrids">Invalid HRIDs</a></h3>
<pre><code>USR001                       # Missing hyphen
-USR-001                     # Leading hyphen
USR-001-                     # Trailing hyphen
USR--001                     # Double hyphen
USR-                         # Missing ID
-001                         # Missing KIND
USR-abc                      # Non-numeric ID
USR-0                        # Zero ID not allowed
USR--001                     # Empty segment
</code></pre>
<h2 id="namespaces-in-practice"><a class="header" href="#namespaces-in-practice">Namespaces in Practice</a></h2>
<h3 id="when-to-use-namespaces"><a class="header" href="#when-to-use-namespaces">When to Use Namespaces</a></h3>
<p><strong>Large projects</strong>: Organize by subsystem</p>
<pre><code>AUTH-USR-001     # Authentication subsystem user requirements
AUTH-SYS-001
PAYMENT-USR-001  # Payment subsystem user requirements
PAYMENT-SYS-001
</code></pre>
<p><strong>Product families</strong>: Distinguish shared vs. product-specific</p>
<pre><code>CORE-SYS-001    # Shared by all products
MOBILE-USR-001  # Mobile app specific
WEB-USR-001     # Web app specific
</code></pre>
<p><strong>Organizational structure</strong>: Match company divisions</p>
<pre><code>FRONTEND-DASHBOARD-USR-001
FRONTEND-REPORTS-USR-001
BACKEND-API-SYS-001
BACKEND-DATABASE-SYS-001
</code></pre>
<h3 id="when-not-to-use-namespaces"><a class="header" href="#when-not-to-use-namespaces">When Not to Use Namespaces</a></h3>
<p><strong>Small projects</strong>: Added complexity without benefit</p>
<pre><code># Overkill for a small project
TODO-APP-CORE-STORAGE-SYS-001

# Better
SYS-001
</code></pre>
<p><strong>Flat hierarchy</strong>: If you don't need organizational structure</p>
<pre><code>USR-001, USR-002, SYS-001, SYS-002
</code></pre>
<p>Use namespaces only when they add clarity, not as a default.</p>
<h2 id="hrid-assignment"><a class="header" href="#hrid-assignment">HRID Assignment</a></h2>
<h3 id="auto-incrementing"><a class="header" href="#auto-incrementing">Auto-Incrementing</a></h3>
<p><code>req add</code> automatically assigns the next available ID:</p>
<pre><code class="language-bash">req add USR    # Creates USR-001
req add USR    # Creates USR-002
req add SYS    # Creates SYS-001
req add USR    # Creates USR-003
</code></pre>
<p>The next ID is determined by examining existing requirements and incrementing the highest ID found.</p>
<h3 id="with-namespaces"><a class="header" href="#with-namespaces">With Namespaces</a></h3>
<p>Specify the namespace in the KIND argument:</p>
<pre><code class="language-bash">req add AUTH-USR        # Creates AUTH-USR-001
req add AUTH-SYS        # Creates AUTH-SYS-001
req add PAYMENT-USR     # Creates PAYMENT-USR-001
req add AUTH-USR        # Creates AUTH-USR-002
</code></pre>
<p>Each NAMESPACE-KIND combination has its own sequence.</p>
<h3 id="gaps-in-numbering"><a class="header" href="#gaps-in-numbering">Gaps in Numbering</a></h3>
<p>If you delete <code>USR-002</code>, creating a gap:</p>
<pre><code>USR-001.md  # Exists
# USR-002.md deleted
USR-003.md  # Exists
</code></pre>
<p>The next <code>req add USR</code> creates <code>USR-004</code>, not <code>USR-002</code>. Requiem always uses the next number after the highest existing ID.</p>
<p><strong>Rationale</strong>: Reusing deleted IDs could confuse people referring to old documentation or Git history that mentioned USR-002.</p>
<h2 id="hrid-best-practices"><a class="header" href="#hrid-best-practices">HRID Best Practices</a></h2>
<h3 id="use-consistent-naming"><a class="header" href="#use-consistent-naming">Use Consistent Naming</a></h3>
<p>Pick a convention and stick to it:</p>
<pre><code># Good (consistent)
USR-001, USR-002, SYS-001, SYS-002

# Bad (inconsistent)
USR-001, User-002, SYS-001, system-002
</code></pre>
<h3 id="keep-kinds-short"><a class="header" href="#keep-kinds-short">Keep KINDs Short</a></h3>
<pre><code># Good
USR, SYS, SWR, TST

# Less good (too verbose)
USER_REQUIREMENTS, SYSTEM_REQUIREMENTS
</code></pre>
<p>Short KINDs are easier to type and read.</p>
<h3 id="use-uppercase"><a class="header" href="#use-uppercase">Use UPPERCASE</a></h3>
<pre><code># Good
USR-001

# Works but unconventional
usr-001
Usr-001
</code></pre>
<p>UPPERCASE is the standard convention in requirements engineering.</p>
<h3 id="document-your-kind-meanings"><a class="header" href="#document-your-kind-meanings">Document Your KIND Meanings</a></h3>
<p>Create a glossary:</p>
<pre><code class="language-markdown"># Requirements Glossary

- **USR**: User requirements (stakeholder needs)
- **SYS**: System requirements (technical specifications)
- **SWR**: Software requirements (implementation details)
- **TST**: Test requirements (test cases)
</code></pre>
<h2 id="hrid-stability"><a class="header" href="#hrid-stability">HRID Stability</a></h2>
<h3 id="hrids-can-change"><a class="header" href="#hrids-can-change">HRIDs Can Change</a></h3>
<p>Unlike UUIDs, HRIDs are <strong>not guaranteed stable</strong>. They might change if:</p>
<ul>
<li>Requirements are renumbered</li>
<li>Namespaces are reorganized</li>
<li>Projects are merged</li>
</ul>
<h3 id="correcting-hrids"><a class="header" href="#correcting-hrids">Correcting HRIDs</a></h3>
<p>If you manually rename a requirement file, run:</p>
<pre><code class="language-bash">req clean
</code></pre>
<p>This updates parent <code>hrid</code> fields to reflect the new names, while UUIDs keep links valid.</p>
<p>Example:</p>
<pre><code class="language-bash"># Manually rename
mv USR-001.md AUTH-USR-001.md

# Update parent references
req clean

# Children that referenced USR-001 now show AUTH-USR-001
</code></pre>
<h3 id="referencing-requirements"><a class="header" href="#referencing-requirements">Referencing Requirements</a></h3>
<p>In documentation and code, always reference by HRID for readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Satisfies USR-042: Email validation
fn validate_email(email: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>But remember that HRIDs might change. For machine processing, use UUIDs.</p>
<h2 id="namespace-configuration"><a class="header" href="#namespace-configuration">Namespace Configuration</a></h2>
<p>Configure allowed namespaces and kinds in <code>config.toml</code>:</p>
<pre><code class="language-toml">_version = "1"

# Optional: Restrict allowed kinds
allowed_kinds = ["USR", "SYS", "SWR", "TST"]

# Optional: Set ID padding
digits = 3
</code></pre>
<p><strong>Note</strong>: Namespace validation is not yet implemented. You can use any namespace structure. Future versions may allow restricting namespaces.</p>
<h2 id="filename-matching"><a class="header" href="#filename-matching">Filename Matching</a></h2>
<p>Requirement filenames <strong>must</strong> match the HRID:</p>
<pre><code>USR-001.md              # Matches USR-001
COMPONENT-SYS-042.md    # Matches COMPONENT-SYS-042
</code></pre>
<p>Mismatches cause errors:</p>
<pre><code>USR-001.md containing HRID USR-002 ‚Üí Error!
</code></pre>
<p>The HRID in the filename is authoritative. Requiem derives the HRID from the filename, not from any field in the YAML.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>Now that you understand HRIDs, learn how to <a href="working-with-requirements/./creating.html">create requirements</a> with <code>req add</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-requirements"><a class="header" href="#creating-requirements">Creating Requirements</a></h1>
<p>The <code>req add</code> command creates new requirements with automatically generated metadata.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<pre><code class="language-bash">req add &lt;KIND&gt;
</code></pre>
<p>This creates a requirement with the next available ID for the specified KIND.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-bash"># Create USR-001
req add USR

# Create USR-002
req add USR

# Create SYS-001
req add SYS
</code></pre>
<p>Output:</p>
<pre><code>Added requirement USR-001
Added requirement USR-002
Added requirement SYS-001
</code></pre>
<h2 id="command-options"><a class="header" href="#command-options">Command Options</a></h2>
<h3 id="specify-parent-requirements"><a class="header" href="#specify-parent-requirements">Specify Parent Requirements</a></h3>
<p>Create a requirement already linked to parents:</p>
<pre><code class="language-bash">req add &lt;KIND&gt; --parents &lt;PARENT1&gt;,&lt;PARENT2&gt;,...
</code></pre>
<p><strong>Alias</strong>: <code>-p</code> for <code>--parents</code></p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<pre><code class="language-bash"># Create SYS-001 linked to USR-001
req add SYS --parents USR-001

# Create SYS-002 linked to both USR-001 and USR-002
req add SYS --parents USR-001,USR-002

# Using short form
req add SYS -p USR-001,USR-002
</code></pre>
<h3 id="specify-root-directory"><a class="header" href="#specify-root-directory">Specify Root Directory</a></h3>
<p>By default, <code>req</code> operates in the current directory. Use <code>--root</code> to specify a different directory:</p>
<pre><code class="language-bash">req --root /path/to/requirements add USR
</code></pre>
<p><strong>Alias</strong>: <code>-r</code> for <code>--root</code></p>
<p>This is useful when running Requiem from outside the requirements directory:</p>
<pre><code class="language-bash"># Run from project root
req --root ./docs/requirements add USR

# Using short form
req -r ./docs/requirements add USR
</code></pre>
<h3 id="verbosity"><a class="header" href="#verbosity">Verbosity</a></h3>
<p>Control log output:</p>
<pre><code class="language-bash">req -v add USR      # INFO level
req -vv add USR     # DEBUG level
req -vvv add USR    # TRACE level
</code></pre>
<p>More v's = more verbose. Useful for troubleshooting.</p>
<h2 id="generated-content"><a class="header" href="#generated-content">Generated Content</a></h2>
<p>When you run <code>req add USR</code>, a file <code>USR-001.md</code> is created with:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---


</code></pre>
<p><strong>Generated fields</strong>:</p>
<ul>
<li><code>_version</code>: Always <code>'1'</code> (current format version)</li>
<li><code>uuid</code>: A random UUIDv4</li>
<li><code>created</code>: Current timestamp in ISO 8601 format (UTC)</li>
</ul>
<p><strong>Empty body</strong>: You need to add the requirement text yourself.</p>
<h2 id="adding-content"><a class="header" href="#adding-content">Adding Content</a></h2>
<p>After creating a requirement, edit it to add content:</p>
<pre><code class="language-bash">req add USR
# Output: Added requirement USR-001

# Edit the file
vim USR-001.md
# or
code USR-001.md
</code></pre>
<p>Add your requirement text:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---

Users shall be able to export data in CSV format.

Rationale: CSV is a universally supported format for data interchange.
</code></pre>
<p>Save the file. Your requirement is now complete.</p>
<h2 id="creating-with-parents"><a class="header" href="#creating-with-parents">Creating with Parents</a></h2>
<p>When you specify parents, they're included in the frontmatter:</p>
<pre><code class="language-bash">req add SYS --parents USR-001
</code></pre>
<p>Creates <code>SYS-001.md</code>:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 81e63bac-4035-47b5-b273-ac13e47a2ff6
created: 2025-07-22T13:14:40.510075462Z
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
---


</code></pre>
<p><strong>Generated parent fields</strong>:</p>
<ul>
<li><code>uuid</code>: Copied from USR-001's UUID</li>
<li><code>fingerprint</code>: Computed from USR-001's current content</li>
<li><code>hrid</code>: USR-001 (for human readability)</li>
</ul>
<h3 id="multiple-parents-2"><a class="header" href="#multiple-parents-2">Multiple Parents</a></h3>
<pre><code class="language-bash">req add SYS --parents USR-001,USR-002,USR-003
</code></pre>
<p>Creates <code>SYS-001.md</code> with three parent entries:</p>
<pre><code class="language-yaml">parents:
- uuid: &lt;USR-001 UUID&gt;
  fingerprint: &lt;USR-001 fingerprint&gt;
  hrid: USR-001
- uuid: &lt;USR-002 UUID&gt;
  fingerprint: &lt;USR-002 fingerprint&gt;
  hrid: USR-002
- uuid: &lt;USR-003 UUID&gt;
  fingerprint: &lt;USR-003 fingerprint&gt;
  hrid: USR-003
</code></pre>
<h2 id="using-namespaces"><a class="header" href="#using-namespaces">Using Namespaces</a></h2>
<p>Create requirements with namespaces by including them in the KIND:</p>
<pre><code class="language-bash"># Create AUTH-USR-001
req add AUTH-USR

# Create AUTH-LOGIN-SYS-001
req add AUTH-LOGIN-SYS

# Create PAYMENT-API-SWR-001
req add PAYMENT-API-SWR
</code></pre>
<p>The filename matches the full HRID:</p>
<pre><code>AUTH-USR-001.md
AUTH-LOGIN-SYS-001.md
PAYMENT-API-SWR-001.md
</code></pre>
<h2 id="workflow-recommendations"><a class="header" href="#workflow-recommendations">Workflow Recommendations</a></h2>
<h3 id="create-high-level-first"><a class="header" href="#create-high-level-first">Create High-Level First</a></h3>
<p>Start with user requirements:</p>
<pre><code class="language-bash">req add USR
req add USR
req add USR
</code></pre>
<p>Edit them to add content. Then create system requirements that satisfy them:</p>
<pre><code class="language-bash">req add SYS --parents USR-001
req add SYS --parents USR-001
req add SYS --parents USR-002
</code></pre>
<p>This top-down approach ensures traceability from the start.</p>
<h3 id="create-in-batches"><a class="header" href="#create-in-batches">Create in Batches</a></h3>
<p>If you know you need five user requirements:</p>
<pre><code class="language-bash">for i in {1..5}; do req add USR; done
</code></pre>
<p>This creates <code>USR-001</code> through <code>USR-005</code>. Then edit each file to add content.</p>
<h3 id="use-version-control"><a class="header" href="#use-version-control">Use Version Control</a></h3>
<p>After creating requirements, commit them:</p>
<pre><code class="language-bash">req add USR
req add USR
git add USR-001.md USR-002.md
git commit -m "Add initial user requirements (placeholders)"

# Edit the files, then commit again
git add USR-001.md USR-002.md
git commit -m "Add content to USR-001 and USR-002"
</code></pre>
<p>This creates a clear history of requirement evolution.</p>
<h2 id="error-conditions"><a class="header" href="#error-conditions">Error Conditions</a></h2>
<h3 id="parent-not-found"><a class="header" href="#parent-not-found">Parent Not Found</a></h3>
<pre><code class="language-bash">req add SYS --parents USR-999
</code></pre>
<p>If <code>USR-999.md</code> doesn't exist, you'll get an error:</p>
<pre><code>Error: Failed to load requirement USR-999
</code></pre>
<p><strong>Solution</strong>: Ensure parent requirements exist before linking to them.</p>
<h3 id="invalid-hrid-format"><a class="header" href="#invalid-hrid-format">Invalid HRID Format</a></h3>
<pre><code class="language-bash">req add usr-001  # Trying to specify ID manually (not supported)
</code></pre>
<p>The KIND should not include the ID. Use:</p>
<pre><code class="language-bash">req add USR  # Correct - ID is auto-assigned
</code></pre>
<h3 id="malformed-parent-list"><a class="header" href="#malformed-parent-list">Malformed Parent List</a></h3>
<pre><code class="language-bash">req add SYS --parents USR-001, USR-002  # Space after comma
</code></pre>
<p>Don't include spaces in the parent list:</p>
<pre><code class="language-bash">req add SYS --parents USR-001,USR-002  # Correct
</code></pre>
<h2 id="advanced-scripting-requirement-creation"><a class="header" href="#advanced-scripting-requirement-creation">Advanced: Scripting Requirement Creation</a></h2>
<p>For bulk creation with structured content, use shell scripts:</p>
<pre><code class="language-bash">#!/bin/bash

# Create and populate multiple user requirements
requirements=(
  "Users shall authenticate via username and password"
  "Users shall reset forgotten passwords via email"
  "Users shall enable two-factor authentication"
)

for i in "${!requirements[@]}"; do
  req add USR
  hrid="USR-$(printf '%03d' $((i+1)))"

  # Append requirement text to the file
  echo "${requirements[$i]}" &gt;&gt; "$hrid.md"
done
</code></pre>
<p>This creates USR-001, USR-002, and USR-003 with predefined content.</p>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Once you've created requirements, you'll often need to link them together. Learn how in <a href="working-with-requirements/./linking.html">Linking Requirements</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>Templates provide default content when creating new requirements, helping maintain consistency across your requirements documentation.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>When you create a new requirement using <code>req add &lt;KIND&gt;</code>, the tool looks for a template file in the <code>.req/templates/</code> directory. If found, the template content is used as the initial content for the new requirement.</p>
<h2 id="template-location"><a class="header" href="#template-location">Template Location</a></h2>
<p>Templates are stored as markdown files in the <code>.req/templates/</code> directory:</p>
<pre><code>your-requirements/
‚îú‚îÄ‚îÄ .req/
‚îÇ   ‚îî‚îÄ‚îÄ templates/
‚îÇ       ‚îú‚îÄ‚îÄ USR.md          # Template for USR requirements
‚îÇ       ‚îú‚îÄ‚îÄ SYS.md          # Template for SYS requirements
‚îÇ       ‚îî‚îÄ‚îÄ AUTH-USR.md     # Template for AUTH-USR requirements
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ SYS-001.md
</code></pre>
<h2 id="template-matching"><a class="header" href="#template-matching">Template Matching</a></h2>
<p>When creating a requirement, templates are matched in order of specificity:</p>
<ol>
<li><strong>Full prefix match</strong>: If creating <code>AUTH-USR-001</code>, looks for <code>.req/templates/AUTH-USR.md</code></li>
<li><strong>KIND-only match</strong>: If not found, looks for <code>.req/templates/USR.md</code></li>
<li><strong>No template</strong>: If neither exists, creates empty content</li>
</ol>
<p>This allows you to:</p>
<ul>
<li>Define general templates for kinds (e.g., <code>USR.md</code> for all user requirements)</li>
<li>Override with namespace-specific templates (e.g., <code>AUTH-USR.md</code> for auth user requirements)</li>
</ul>
<h2 id="creating-templates"><a class="header" href="#creating-templates">Creating Templates</a></h2>
<h3 id="simple-text-template"><a class="header" href="#simple-text-template">Simple Text Template</a></h3>
<p>The simplest template is just plain text:</p>
<pre><code class="language-markdown">[Describe the requirement here]
</code></pre>
<p>Save this as <code>.req/templates/USR.md</code>.</p>
<h3 id="structured-template"><a class="header" href="#structured-template">Structured Template</a></h3>
<p>For more structure, use markdown headers and sections:</p>
<pre><code class="language-markdown"># Requirement Title

## Description

[Detailed description]

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Notes

[Additional notes]
</code></pre>
<h3 id="namespace-specific-template"><a class="header" href="#namespace-specific-template">Namespace-Specific Template</a></h3>
<p>Create specialized templates for namespaced requirements:</p>
<pre><code class="language-markdown"># Authentication Requirement

## Security Considerations

[Describe security implications]

## Implementation

[Authentication mechanism details]

## Test Strategy

[How to verify this auth requirement]
</code></pre>
<p>Save this as <code>.req/templates/AUTH-USR.md</code>.</p>
<h2 id="using-templates"><a class="header" href="#using-templates">Using Templates</a></h2>
<h3 id="automatic-template-application"><a class="header" href="#automatic-template-application">Automatic Template Application</a></h3>
<p>When you create a requirement without content flags, the template is automatically used:</p>
<pre><code class="language-bash">req add USR
# Creates USR-001.md with content from .req/templates/USR.md
</code></pre>
<h3 id="overriding-templates"><a class="header" href="#overriding-templates">Overriding Templates</a></h3>
<p>Templates are ignored when you provide content via CLI flags:</p>
<pre><code class="language-bash"># Template ignored - uses title and body from flags
req add USR -t "Custom Title" -b "Custom content"

# Template ignored - uses title from flag
req add USR -t "Custom Title"

# Template ignored - uses body from flag
req add USR -b "Custom content"
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="software-project-templates"><a class="header" href="#software-project-templates">Software Project Templates</a></h3>
<p><strong><code>.req/templates/USR.md</code></strong>:</p>
<pre><code class="language-markdown">[Describe the user-facing requirement]

**User Value**: [Why does the user need this?]

**Acceptance Criteria**:
- [ ] Criterion 1
</code></pre>
<p><strong><code>.req/templates/SYS.md</code></strong>:</p>
<pre><code class="language-markdown">[Describe the system-level implementation requirement]

**Technical Notes**: [Implementation details]

**Testing**: [How to verify]
</code></pre>
<h3 id="aerospace-project-templates"><a class="header" href="#aerospace-project-templates">Aerospace Project Templates</a></h3>
<p><strong><code>.req/templates/URQT.md</code></strong> (User Requirements):</p>
<pre><code class="language-markdown">## User Requirement

**Description**: [User requirement description]

**Rationale**: [Justification]

**Verification Method**: [Test, Analysis, Inspection, or Demonstration]
</code></pre>
<p><strong><code>.req/templates/SRQT.md</code></strong> (Software Requirements):</p>
<pre><code class="language-markdown">## Software Requirement

**Specification**: [Detailed technical specification]

**Derived From**: [Parent URQT reference]

**Verification Method**: [Test method]

**Criticality**: [DAL level]
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="keep-templates-simple"><a class="header" href="#keep-templates-simple">Keep Templates Simple</a></h3>
<p>Templates should provide structure without being overly prescriptive:</p>
<pre><code class="language-markdown">‚úì Good: [Describe the requirement]

‚úó Too prescriptive: The system SHALL [verb] [object] [condition]
</code></pre>
<h3 id="use-placeholders"><a class="header" href="#use-placeholders">Use Placeholders</a></h3>
<p>Use square brackets for clear placeholders:</p>
<pre><code class="language-markdown">[Describe the requirement here]

**Rationale**: [Why is this needed?]
</code></pre>
<h3 id="team-conventions"><a class="header" href="#team-conventions">Team Conventions</a></h3>
<p>Document your team's template conventions:</p>
<pre><code class="language-markdown">## Description
[One paragraph summary]

## Details
[Detailed specification with sub-sections as needed]

## Testing
[How to verify this requirement]
</code></pre>
<h3 id="version-control-1"><a class="header" href="#version-control-1">Version Control</a></h3>
<p>Commit templates to version control alongside your requirements:</p>
<pre><code class="language-bash">git add .req/templates/
git commit -m "Add requirement templates"
</code></pre>
<h2 id="updating-templates"><a class="header" href="#updating-templates">Updating Templates</a></h2>
<p>Templates only affect <em>new</em> requirements. To update existing requirements:</p>
<ol>
<li>Update the template file</li>
<li>Manually edit existing requirements to match (if desired)</li>
<li>Or use the template as a guide for new requirements only</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="minimal-templates"><a class="header" href="#minimal-templates">Minimal Templates</a></h3>
<p>For projects that prefer freeform text:</p>
<pre><code class="language-markdown">[Requirement description]
</code></pre>
<h3 id="structured-templates"><a class="header" href="#structured-templates">Structured Templates</a></h3>
<p>For projects requiring specific sections:</p>
<pre><code class="language-markdown">## Specification
[Technical details]

## Rationale
[Why this is needed]

## Verification
[How to test]
</code></pre>
<h3 id="compliance-templates"><a class="header" href="#compliance-templates">Compliance Templates</a></h3>
<p>For regulated industries:</p>
<pre><code class="language-markdown">## Requirement
[Requirement text]

## Compliance
**Standard**: [e.g., DO-178C]
**Criticality**: [e.g., DAL A]

## Verification
**Method**: [Test, Analysis, Inspection, Demonstration]
**Criteria**: [Pass/fail criteria]
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="template-not-being-used"><a class="header" href="#template-not-being-used">Template Not Being Used</a></h3>
<p><strong>Problem</strong>: Created requirement is empty even though template exists.</p>
<p><strong>Check</strong>:</p>
<ol>
<li>Template file is in <code>.req/templates/</code> directory</li>
<li>Template filename matches KIND exactly (case-sensitive)</li>
<li>Template file has <code>.md</code> extension</li>
<li>You didn't use <code>-t</code> or <code>-b</code> flags (which override templates)</li>
</ol>
<h3 id="wrong-template-being-used"><a class="header" href="#wrong-template-being-used">Wrong Template Being Used</a></h3>
<p><strong>Problem</strong>: Expected namespace-specific template but got general template.</p>
<p><strong>Reason</strong>: Namespace-specific template file doesn't exist.</p>
<p><strong>Solution</strong>: Create <code>.req/templates/&lt;NAMESPACE&gt;-&lt;KIND&gt;.md</code></p>
<p>Example: For <code>AUTH-USR-001</code>, create <code>.req/templates/AUTH-USR.md</code></p>
<h2 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h2>
<p>Want to see templates in action? Check out the templates used by the Requiem project itself:</p>
<ul>
<li><a href="working-with-requirements/../requirements/.req/templates/USR.html">USR Template</a> - User requirements template with Statement, Rationale, and Acceptance Criteria sections</li>
<li><a href="working-with-requirements/../requirements/.req/templates/SYS.html">SYS Template</a> - System requirements template with Statement, Implementation Notes, and Verification sections</li>
</ul>
<p>These templates are used to create all requirements in the <a href="working-with-requirements/../requirements.html">Example Project</a>, demonstrating professional structure and best practices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-requirements-1"><a class="header" href="#linking-requirements-1">Linking Requirements</a></h1>
<p>The <code>req link</code> command establishes parent-child relationships between requirements, creating traceability throughout your requirement hierarchy.</p>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-bash">req link &lt;CHILD&gt; &lt;PARENT&gt;
</code></pre>
<p>This adds PARENT to CHILD's parent list.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-bash">req link SYS-001 USR-001
</code></pre>
<p>Output:</p>
<pre><code>Linked SYS-001 to USR-001
</code></pre>
<p>Now <code>SYS-001.md</code> contains:</p>
<pre><code class="language-yaml">---
_version: '1'
uuid: 81e63bac-4035-47b5-b273-ac13e47a2ff6
created: 2025-07-22T13:14:40.510075462Z
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
---

...requirement content...
</code></pre>
<h2 id="multiple-parents-3"><a class="header" href="#multiple-parents-3">Multiple Parents</a></h2>
<p>You can link a child to multiple parents by running <code>req link</code> multiple times:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
req link SYS-001 USR-002
req link SYS-001 USR-003
</code></pre>
<p>Now <code>SYS-001.md</code> has three parents:</p>
<pre><code class="language-yaml">parents:
- uuid: &lt;USR-001 UUID&gt;
  fingerprint: &lt;USR-001 fingerprint&gt;
  hrid: USR-001
- uuid: &lt;USR-002 UUID&gt;
  fingerprint: &lt;USR-002 fingerprint&gt;
  hrid: USR-002
- uuid: &lt;USR-003 UUID&gt;
  fingerprint: &lt;USR-003 fingerprint&gt;
  hrid: USR-003
</code></pre>
<h2 id="linking-at-creation-time"><a class="header" href="#linking-at-creation-time">Linking at Creation Time</a></h2>
<p>Instead of linking after creation, you can specify parents when creating:</p>
<pre><code class="language-bash"># Instead of:
req add SYS
req link SYS-001 USR-001
req link SYS-001 USR-002

# Do:
req add SYS --parents USR-001,USR-002
</code></pre>
<p>This is more efficient and ensures traceability from the start.</p>
<h2 id="what-gets-updated"><a class="header" href="#what-gets-updated">What Gets Updated</a></h2>
<p>When you run <code>req link CHILD PARENT</code>:</p>
<ol>
<li><strong>CHILD file is modified</strong>: The parent entry is added to the YAML frontmatter</li>
<li><strong>PARENT file is NOT modified</strong>: Parent doesn't know about its children</li>
</ol>
<p>This is a directed relationship: children point to parents, not vice versa.</p>
<h3 id="finding-children"><a class="header" href="#finding-children">Finding Children</a></h3>
<p>To find all children of a requirement, search files:</p>
<pre><code class="language-bash">grep -l "hrid: USR-001" *.md
</code></pre>
<p>This shows all requirements that list USR-001 as a parent.</p>
<h2 id="parent-information"><a class="header" href="#parent-information">Parent Information</a></h2>
<p>Each parent entry contains three fields:</p>
<h3 id="uuid-required"><a class="header" href="#uuid-required">UUID (Required)</a></h3>
<pre><code class="language-yaml">uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
</code></pre>
<p>The stable, unique identifier of the parent. This is the canonical reference that enables reliable traceability even if the parent is renumbered.</p>
<h3 id="fingerprint-required"><a class="header" href="#fingerprint-required">Fingerprint (Required)</a></h3>
<pre><code class="language-yaml">fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
</code></pre>
<p>A SHA256 hash of the parent's content at the time of linking. This enables change detection:</p>
<ul>
<li>Parent content changes ‚Üí fingerprint changes</li>
<li>Child still has old fingerprint ‚Üí signals that parent has changed</li>
<li>Child should be reviewed to ensure it's still valid</li>
</ul>
<h3 id="hrid-required"><a class="header" href="#hrid-required">HRID (Required)</a></h3>
<pre><code class="language-yaml">hrid: USR-001
</code></pre>
<p>The human-readable ID of the parent. This is for convenience when reading the YAML. The actual relationship is based on the UUID.</p>
<p>If the parent is renumbered, the HRID can be corrected with <code>req clean</code> (covered in <a href="working-with-requirements/../maintaining.html">Maintaining Requirements</a>).</p>
<h2 id="linking-across-namespaces"><a class="header" href="#linking-across-namespaces">Linking Across Namespaces</a></h2>
<p>You can link requirements with different namespaces:</p>
<pre><code class="language-bash">req link PAYMENT-SYS-001 CORE-USR-001
</code></pre>
<p>The namespaces don't need to match. Links are based on UUIDs, which are globally unique across all namespaces.</p>
<h2 id="error-conditions-1"><a class="header" href="#error-conditions-1">Error Conditions</a></h2>
<h3 id="child-not-found"><a class="header" href="#child-not-found">Child Not Found</a></h3>
<pre><code class="language-bash">req link SYS-999 USR-001
</code></pre>
<p>If <code>SYS-999.md</code> doesn't exist:</p>
<pre><code>Error: Failed to load requirement SYS-999
</code></pre>
<h3 id="parent-not-found-1"><a class="header" href="#parent-not-found-1">Parent Not Found</a></h3>
<pre><code class="language-bash">req link SYS-001 USR-999
</code></pre>
<p>If <code>USR-999.md</code> doesn't exist:</p>
<pre><code>Error: Failed to load requirement USR-999
</code></pre>
<h3 id="duplicate-link"><a class="header" href="#duplicate-link">Duplicate Link</a></h3>
<p>Linking a child to the same parent twice:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
req link SYS-001 USR-001
</code></pre>
<p>This creates duplicate entries in the parent list. <strong>Avoid this</strong> by checking existing links before adding new ones.</p>
<p><em>Note: Duplicate detection is not currently implemented but may be added in future versions.</em></p>
<h2 id="typical-linking-patterns"><a class="header" href="#typical-linking-patterns">Typical Linking Patterns</a></h2>
<h3 id="one-to-many-parent--children"><a class="header" href="#one-to-many-parent--children">One-to-Many (Parent ‚Üí Children)</a></h3>
<p>One user requirement satisfied by multiple system requirements:</p>
<pre><code>USR-001
  ‚îú‚îÄ SYS-001
  ‚îú‚îÄ SYS-002
  ‚îî‚îÄ SYS-003
</code></pre>
<pre><code class="language-bash">req add USR
req add SYS --parents USR-001
req add SYS --parents USR-001
req add SYS --parents USR-001
</code></pre>
<h3 id="many-to-one-parents--child"><a class="header" href="#many-to-one-parents--child">Many-to-One (Parents ‚Üí Child)</a></h3>
<p>One system requirement satisfying multiple user requirements:</p>
<pre><code>USR-001 ‚îÄ‚îê
USR-002 ‚îÄ‚îº‚îÄ SYS-001
USR-003 ‚îÄ‚îò
</code></pre>
<pre><code class="language-bash">req add USR
req add USR
req add USR
req add SYS --parents USR-001,USR-002,USR-003
</code></pre>
<h3 id="many-to-many"><a class="header" href="#many-to-many">Many-to-Many</a></h3>
<p>Complex dependencies:</p>
<pre><code>USR-001 ‚îÄ‚î¨‚îÄ SYS-001
         ‚îî‚îÄ SYS-002
USR-002 ‚îÄ‚î¨‚îÄ SYS-002
         ‚îî‚îÄ SYS-003
</code></pre>
<pre><code class="language-bash">req add SYS --parents USR-001
req add SYS --parents USR-001,USR-002
req add SYS --parents USR-002
</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="link-during-creation-when-possible"><a class="header" href="#link-during-creation-when-possible">Link During Creation When Possible</a></h3>
<pre><code class="language-bash"># Preferred
req add SYS --parents USR-001

# Works but requires two commands
req add SYS
req link SYS-001 USR-001
</code></pre>
<h3 id="establish-traceability-early"><a class="header" href="#establish-traceability-early">Establish Traceability Early</a></h3>
<p>Link requirements as you create them, not as an afterthought. This ensures your hierarchy is always traceable.</p>
<h3 id="document-linking-rationale"><a class="header" href="#document-linking-rationale">Document Linking Rationale</a></h3>
<p>In the requirement body, explain why each parent link exists:</p>
<pre><code class="language-markdown">---
parents:
- hrid: USR-001
  ...
- hrid: USR-003
  ...
---

The system shall provide OAuth authentication.

Satisfies USR-001 (secure login) and USR-003 (third-party integration).
</code></pre>
<h3 id="validate-links-in-code-review"><a class="header" href="#validate-links-in-code-review">Validate Links in Code Review</a></h3>
<p>When reviewing requirement changes, check that:</p>
<ul>
<li>New requirements link to appropriate parents</li>
<li>Links are not duplicated</li>
<li>Parent requirements actually exist</li>
</ul>
<h2 id="unlinking-not-yet-supported"><a class="header" href="#unlinking-not-yet-supported">Unlinking (Not Yet Supported)</a></h2>
<p>Currently, there's no <code>req unlink</code> command. To remove a parent link, manually edit the child file:</p>
<pre><code class="language-yaml"># Before
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
- uuid: 7a8f9e2b-1c3d-4e5f-6a7b-8c9d0e1f2a3b
  fingerprint: a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456
  hrid: USR-002

# After (removed USR-002)
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
</code></pre>
<p>Be careful to preserve valid YAML syntax.</p>
<h2 id="visualizing-links"><a class="header" href="#visualizing-links">Visualizing Links</a></h2>
<p>Since links aren't bidirectional in the files, you may want to generate visual representations:</p>
<pre><code class="language-bash"># Simple script to list parent-child relationships
for file in *.md; do
  hrid=$(basename "$file" .md)
  parents=$(grep "hrid:" "$file" | awk '{print $2}')
  for parent in $parents; do
    echo "$parent -&gt; $hrid"
  done
done
</code></pre>
<p>Output:</p>
<pre><code>USR-001 -&gt; SYS-001
USR-001 -&gt; SYS-002
USR-002 -&gt; SYS-002
</code></pre>
<p>You can pipe this to graph visualization tools like Graphviz.</p>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Learn how to work with complex requirement relationships in <a href="working-with-requirements/./relationships.html">Managing Relationships</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-relationships"><a class="header" href="#managing-relationships">Managing Relationships</a></h1>
<p>As your requirements grow, the dependency graph becomes complex. This chapter covers strategies for managing intricate requirement relationships.</p>
<h2 id="understanding-requirement-graphs"><a class="header" href="#understanding-requirement-graphs">Understanding Requirement Graphs</a></h2>
<p>Requirements form a <strong>directed acyclic graph (DAG)</strong>:</p>
<ul>
<li><strong>Directed</strong>: Parent-child relationships have a direction (child ‚Üí parent)</li>
<li><strong>Acyclic</strong>: No circular dependencies (requirement A ‚Üí B ‚Üí C ‚Üí A)</li>
<li><strong>Graph</strong>: Nodes (requirements) connected by edges (parent-child links)</li>
</ul>
<p><em>Note: Cycle detection is planned but not yet implemented. Currently, you must avoid cycles manually.</em></p>
<h2 id="hierarchical-levels"><a class="header" href="#hierarchical-levels">Hierarchical Levels</a></h2>
<p>A typical hierarchy has 3-5 levels:</p>
<pre><code>Stakeholder Needs
        ‚Üì
User Requirements (USR)
        ‚Üì
System Requirements (SYS)
        ‚Üì
Software Requirements (SWR) / Hardware Requirements (HWR)
        ‚Üì
Test Requirements (TST)
</code></pre>
<p>Each level derives from the one above and is verified by the one below.</p>
<h2 id="complex-relationships"><a class="header" href="#complex-relationships">Complex Relationships</a></h2>
<h3 id="cross-cutting-requirements"><a class="header" href="#cross-cutting-requirements">Cross-Cutting Requirements</a></h3>
<p>Some requirements affect multiple areas:</p>
<pre><code>USR-001 (Login feature) ‚îÄ‚îê
USR-002 (Data export)    ‚îú‚îÄ SYS-042 (Logging)
USR-003 (Admin panel)    ‚îò

</code></pre>
<p>Logging satisfies needs from login (debug), export (audit), and admin (monitoring).</p>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-bash">req add SYS --parents USR-001,USR-002,USR-003
</code></pre>
<h3 id="derived-requirements"><a class="header" href="#derived-requirements">Derived Requirements</a></h3>
<p>One parent spawns many children:</p>
<pre><code>USR-001 (Secure authentication)
  ‚îú‚îÄ SYS-001 (Password hashing)
  ‚îú‚îÄ SYS-002 (Rate limiting)
  ‚îú‚îÄ SYS-003 (Session management)
  ‚îî‚îÄ SYS-004 (OAuth support)
</code></pre>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-bash">req add USR
req add SYS --parents USR-001  # SYS-001
req add SYS --parents USR-001  # SYS-002
req add SYS --parents USR-001  # SYS-003
req add SYS --parents USR-001  # SYS-004
</code></pre>
<h3 id="composite-requirements"><a class="header" href="#composite-requirements">Composite Requirements</a></h3>
<p>Multiple parents combine into one child:</p>
<pre><code>SYS-010 (User data API)   ‚îÄ‚îê
SYS-015 (Auth middleware) ‚îÄ‚îº‚îÄ SWR-042 (Protected endpoint implementation)
SYS-022 (JSON serialization)‚îÄ‚îò
</code></pre>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-bash">req add SWR --parents SYS-010,SYS-015,SYS-022
</code></pre>
<h2 id="traceability-queries"><a class="header" href="#traceability-queries">Traceability Queries</a></h2>
<p>Finding relationships in a large requirement set:</p>
<h3 id="find-all-children-of-a-requirement"><a class="header" href="#find-all-children-of-a-requirement">Find All Children of a Requirement</a></h3>
<pre><code class="language-bash">grep -l "hrid: USR-001" *.md
</code></pre>
<p>Lists all files that have USR-001 as a parent.</p>
<h3 id="find-all-parents-of-a-requirement"><a class="header" href="#find-all-parents-of-a-requirement">Find All Parents of a Requirement</a></h3>
<pre><code class="language-bash">grep "hrid:" SYS-042.md | awk '{print $2}'
</code></pre>
<p>Extracts parent HRIDs from SYS-042.</p>
<h3 id="find-requirements-without-parents"><a class="header" href="#find-requirements-without-parents">Find Requirements Without Parents</a></h3>
<pre><code class="language-bash">for file in SYS-*.md; do
  if ! grep -q "^parents:" "$file"; then
    echo "$file has no parents"
  fi
done
</code></pre>
<p>Identifies top-level requirements at a given level (might be an error).</p>
<h3 id="find-requirements-without-children"><a class="header" href="#find-requirements-without-children">Find Requirements Without Children</a></h3>
<pre><code class="language-bash">for usr in USR-*.md; do
  hrid=$(basename "$usr" .md)
  if ! grep -q "hrid: $hrid" SYS-*.md; then
    echo "$hrid has no children"
  fi
done
</code></pre>
<p>Finds user requirements not satisfied by any system requirements (coverage gap).</p>
<h2 id="avoiding-common-problems"><a class="header" href="#avoiding-common-problems">Avoiding Common Problems</a></h2>
<h3 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h3>
<p><strong>Problem</strong>: A ‚Üí B ‚Üí C ‚Üí A creates a cycle.</p>
<pre><code class="language-bash">req link B A
req link C B
req link A C  # Creates cycle!
</code></pre>
<p><strong>Detection</strong> (manual): Trace parent chains to ensure they terminate.</p>
<p><strong>Prevention</strong>: Enforce strict hierarchy levels (USR ‚Üí SYS ‚Üí SWR ‚Üí TST, never backward).</p>
<p><em>Note: Automatic cycle detection is planned.</em></p>
<h3 id="orphaned-requirements"><a class="header" href="#orphaned-requirements">Orphaned Requirements</a></h3>
<p><strong>Problem</strong>: Requirements with no parents or children.</p>
<p><strong>USR with no children</strong>: Unimplemented user needs (coverage gap).</p>
<p><strong>SYS with no parents</strong>: Requirements without justification (why does this exist?).</p>
<p><strong>Detection</strong>: Use the scripts above to find orphans.</p>
<h3 id="wrong-level-links"><a class="header" href="#wrong-level-links">Wrong-Level Links</a></h3>
<p><strong>Problem</strong>: Skipping levels in the hierarchy.</p>
<pre><code>USR-001 ‚Üí SWR-042  # Skips SYS level!
</code></pre>
<p><strong>Prevention</strong>: Enforce that USR links only to SYS, SYS links only to SWR, etc.</p>
<p><strong>Exception</strong>: Sometimes justified in small projects, but generally avoided.</p>
<h3 id="excessively-granular-links"><a class="header" href="#excessively-granular-links">Excessively Granular Links</a></h3>
<p><strong>Problem</strong>: Too many fine-grained requirements with complex links.</p>
<pre><code>SYS-001 (Email validation)
  ‚îú‚îÄ SWR-001 (Regex pattern)
  ‚îú‚îÄ SWR-002 (Error message)
  ‚îú‚îÄ SWR-003 (UI feedback)
  ‚îú‚îÄ SWR-004 (Logging)
  ‚îî‚îÄ SWR-005 (Internationalization)
</code></pre>
<p><strong>Solution</strong>: Combine related low-level requirements or accept coarser traceability.</p>
<h2 id="refactoring-requirements"><a class="header" href="#refactoring-requirements">Refactoring Requirements</a></h2>
<p>As understanding evolves, you may need to restructure:</p>
<h3 id="splitting-a-requirement"><a class="header" href="#splitting-a-requirement">Splitting a Requirement</a></h3>
<p>Original:</p>
<pre><code>USR-001: Users shall authenticate and manage their profiles.
</code></pre>
<p>Split into:</p>
<pre><code>USR-001: Users shall authenticate securely.
USR-002: Users shall manage their profile information.
</code></pre>
<p><strong>Process</strong>:</p>
<ol>
<li>Create new requirement (USR-002)</li>
<li>Update child requirements to link to appropriate parent</li>
<li>Update original requirement text</li>
<li>Mark as obsolete or delete if no longer needed</li>
</ol>
<h3 id="merging-requirements"><a class="header" href="#merging-requirements">Merging Requirements</a></h3>
<p>Two requirements are redundant:</p>
<pre><code>USR-001: Users shall export data.
USR-003: Users shall download reports.
</code></pre>
<p><strong>Process</strong>:</p>
<ol>
<li>Choose one to keep (USR-001)</li>
<li>Update its text to cover both concepts</li>
<li>Relink children of USR-003 to USR-001</li>
<li>Delete USR-003</li>
</ol>
<h3 id="reorganizing-hierarchy"><a class="header" href="#reorganizing-hierarchy">Reorganizing Hierarchy</a></h3>
<p>Moving requirements between levels or namespaces:</p>
<p><strong>Before</strong>:</p>
<pre><code>SYS-042: OAuth integration
</code></pre>
<p><strong>After</strong>:</p>
<pre><code>AUTH-SYS-042: OAuth integration
</code></pre>
<p><strong>Process</strong>:</p>
<ol>
<li>Rename file: <code>mv SYS-042.md AUTH-SYS-042.md</code></li>
<li>Run <code>req clean</code> to update HRIDs in child requirements</li>
<li>Manually update any external references (documentation, code comments)</li>
</ol>
<h2 id="documentation-strategies"><a class="header" href="#documentation-strategies">Documentation Strategies</a></h2>
<h3 id="requirement-specification-documents"><a class="header" href="#requirement-specification-documents">Requirement Specification Documents</a></h3>
<p>Generate human-readable specs from requirements:</p>
<pre><code class="language-bash"># Simple concatenation
cat USR-*.md &gt; user-requirements.md
cat SYS-*.md &gt; system-requirements.md
</code></pre>
<h3 id="traceability-matrices"><a class="header" href="#traceability-matrices">Traceability Matrices</a></h3>
<p>Create tables showing parent-child relationships:</p>
<div class="table-wrapper"><table><thead><tr><th>User Req</th><th>System Reqs</th></tr></thead><tbody>
<tr><td>USR-001</td><td>SYS-001, SYS-002, SYS-003</td></tr>
<tr><td>USR-002</td><td>SYS-002, SYS-004</td></tr>
<tr><td>USR-003</td><td>SYS-005</td></tr>
</tbody></table>
</div>
<p>Generate with scripts:</p>
<pre><code class="language-bash">for usr in USR-*.md; do
  hrid=$(basename "$usr" .md)
  children=$(grep -l "hrid: $hrid" SYS-*.md | sed 's/.md//' | paste -sd,)
  echo "| $hrid | $children |"
done
</code></pre>
<h3 id="visual-dependency-graphs"><a class="header" href="#visual-dependency-graphs">Visual Dependency Graphs</a></h3>
<p>Use Graphviz to visualize relationships:</p>
<pre><code class="language-bash">echo "digraph requirements {"
for file in *.md; do
  child=$(basename "$file" .md)
  grep "hrid:" "$file" | awk -v child="$child" '{print "  " $2 " -&gt; " child}'
done
echo "}"
</code></pre>
<p>Output:</p>
<pre><code class="language-dot">digraph requirements {
  USR-001 -&gt; SYS-001
  USR-001 -&gt; SYS-002
  USR-002 -&gt; SYS-002
  USR-002 -&gt; SYS-003
}
</code></pre>
<p>Render with:</p>
<pre><code class="language-bash">./generate-graph.sh | dot -Tpng &gt; requirements-graph.png
</code></pre>
<h2 id="scalability-considerations"><a class="header" href="#scalability-considerations">Scalability Considerations</a></h2>
<h3 id="large-projects-100s-of-requirements"><a class="header" href="#large-projects-100s-of-requirements">Large Projects (100s of requirements)</a></h3>
<ul>
<li>Use namespaces to partition by component</li>
<li>Generate indexes and matrices automatically</li>
<li>Consider directory structure: <code>auth/USR-*.md</code>, <code>payment/USR-*.md</code></li>
</ul>
<h3 id="very-large-projects-1000s-of-requirements"><a class="header" href="#very-large-projects-1000s-of-requirements">Very Large Projects (1000s of requirements)</a></h3>
<ul>
<li>Parallel loading (Requiem does this automatically)</li>
<li>External database for complex queries</li>
<li>Dedicated requirements management integration tools</li>
</ul>
<h3 id="multi-product-families"><a class="header" href="#multi-product-families">Multi-Product Families</a></h3>
<ul>
<li>Shared requirements in <code>CORE-*</code></li>
<li>Product-specific in <code>MOBILE-*</code>, <code>WEB-*</code>, etc.</li>
<li>Cross-reference shared requirements from product-specific ones</li>
</ul>
<h2 id="best-practices-summary"><a class="header" href="#best-practices-summary">Best Practices Summary</a></h2>
<ol>
<li><strong>Maintain strict hierarchy</strong> - USR ‚Üí SYS ‚Üí SWR ‚Üí TST</li>
<li><strong>Document cross-cutting concerns</strong> - Explain why a requirement has many parents</li>
<li><strong>Avoid cycles</strong> - Keep relationships acyclic</li>
<li><strong>Review orphans regularly</strong> - Find requirements without links</li>
<li><strong>Refactor thoughtfully</strong> - Restructure as understanding evolves</li>
<li><strong>Automate traceability checks</strong> - Use scripts in CI</li>
<li><strong>Visualize complex graphs</strong> - Generate diagrams for stakeholder review</li>
</ol>
<h2 id="real-world-example-1"><a class="header" href="#real-world-example-1">Real-World Example</a></h2>
<p>See traceability in action in the <a href="working-with-requirements/../requirements.html">Example Project</a>, where you can explore:</p>
<ul>
<li><strong>USR-006</strong> (Requirement Templates) traces to 5 system requirements (SYS-011 through SYS-015)</li>
<li><strong>USR-004</strong> (Graph Analysis) traces to 5 system requirements (SYS-004, 005, 008, 009, 010)</li>
<li>Multiple requirements with single parents, demonstrating various relationship patterns</li>
</ul>
<p>Browse the <a href="working-with-requirements/../requirements/user-requirements.html">User Requirements</a> page to see the complete traceability tree visualized.</p>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>Learn how to configure Requiem for your project in <a href="working-with-requirements/../configuration.html">Configuration</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Requiem provides sensible defaults but allows customization through configuration files and directory structure.</p>
<p>This chapter covers:</p>
<ul>
<li><strong><a href="./configuration/config-file.html">Configuration File</a></strong> - The <code>config.toml</code> format and options</li>
<li><strong><a href="./configuration/directory-structure.html">Directory Structure</a></strong> - Organizing requirements on disk</li>
<li><strong><a href="./configuration/namespaces.html">Namespaces</a></strong> - Using namespaces for large projects</li>
</ul>
<p>Proper configuration helps Requiem adapt to your project's needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h1>
<p>Requiem uses a TOML configuration file named <code>config.toml</code> in the root of your requirements directory to customize behavior.</p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<p>The configuration file must be named <code>config.toml</code> and placed in the root directory where your requirements are stored:</p>
<pre><code>my-requirements/
‚îú‚îÄ‚îÄ config.toml       ‚Üê Configuration file
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îî‚îÄ‚îÄ SYS-001.md
</code></pre>
<p>If no configuration file exists, Requiem uses sensible defaults and continues without error.</p>
<h2 id="file-format"><a class="header" href="#file-format">File Format</a></h2>
<p>The configuration file is written in TOML (Tom's Obvious Minimal Language), a simple, human-readable format.</p>
<h3 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h3>
<p>The simplest valid configuration:</p>
<pre><code class="language-toml">_version = "1"
</code></pre>
<p>This accepts all defaults. The <code>_version</code> field is required for future format compatibility.</p>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<p>A configuration using all available options:</p>
<pre><code class="language-toml">_version = "1"

# Restrict requirement kinds
allowed_kinds = ["USR", "SYS", "SWR", "TST"]

# Number of digits in HRID numbering
digits = 3

# Allow non-requirement markdown files
allow_unrecognised = false

# Allow requirements with invalid formatting
allow_invalid = false
</code></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="_version-required"><a class="header" href="#_version-required"><code>_version</code> (required)</a></h3>
<pre><code class="language-toml">_version = "1"
</code></pre>
<p><strong>Type</strong>: String (quoted)</p>
<p><strong>Default</strong>: N/A (required field)</p>
<p><strong>Purpose</strong>: Specifies the configuration format version. This enables future format changes while maintaining backward compatibility.</p>
<p><strong>Current version</strong>: <code>"1"</code> (as a string, not a number)</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">_version = "1"  # Correct
</code></pre>
<p><strong>Invalid</strong>:</p>
<pre><code class="language-toml">_version = 1    # Wrong: must be a quoted string
</code></pre>
<h3 id="allowed_kinds-optional"><a class="header" href="#allowed_kinds-optional"><code>allowed_kinds</code> (optional)</a></h3>
<pre><code class="language-toml">allowed_kinds = ["USR", "SYS", "SWR", "TST"]
</code></pre>
<p><strong>Type</strong>: Array of strings</p>
<p><strong>Default</strong>: <code>[]</code> (empty array = all kinds allowed)</p>
<p><strong>Purpose</strong>: Restricts which requirement kinds (the KIND component of HRIDs) are permitted in your project.</p>
<p><strong>When to use</strong>:</p>
<ul>
<li>Enforce project standards (e.g., only USR, SYS, TST requirements allowed)</li>
<li>Prevent typos (USR-001 vs. UST-001)</li>
<li>Document your requirement taxonomy</li>
</ul>
<p><strong>Behavior</strong>:</p>
<ul>
<li><strong>Empty array</strong> (default): Any kind is accepted</li>
<li><strong>Non-empty array</strong>: Only listed kinds are valid</li>
</ul>
<p><strong>Example - Aerospace project</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["URQT", "SRQT", "SWRQT", "HWRQT", "TEST"]
# User Requirements (URQT), System Requirements (SRQT), etc.
</code></pre>
<p><strong>Example - Software project</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["USR", "SYS", "SWR", "TST", "DOC"]
</code></pre>
<p><strong>Enforcement</strong>:
When <code>allowed_kinds</code> is non-empty, attempting to create a requirement with a disallowed kind will fail:</p>
<pre><code class="language-bash">$ req add INVALID
Error: Kind 'INVALID' is not in the allowed list
</code></pre>
<h3 id="digits-optional"><a class="header" href="#digits-optional"><code>digits</code> (optional)</a></h3>
<pre><code class="language-toml">digits = 3
</code></pre>
<p><strong>Type</strong>: Unsigned integer</p>
<p><strong>Default</strong>: <code>3</code></p>
<p><strong>Purpose</strong>: Specifies the minimum number of digits used in HRID numbering. IDs are zero-padded to this width.</p>
<p><strong>Valid values</strong>: Any positive integer, though 3 or 4 are most common.</p>
<p><strong>Behavior</strong>:</p>
<p>With <code>digits = 3</code>:</p>
<pre><code>USR-001
USR-002
...
USR-099
USR-100  # Exceeds 3 digits when needed
</code></pre>
<p>With <code>digits = 4</code>:</p>
<pre><code>USR-0001
USR-0002
...
USR-9999
USR-10000  # Exceeds 4 digits when needed
</code></pre>
<p><strong>Choosing a value</strong>:</p>
<ul>
<li><code>digits = 3</code>: Projects with &lt; 1000 requirements per kind</li>
<li><code>digits = 4</code>: Projects with 1000+ requirements per kind</li>
<li><code>digits = 5</code>: Very large projects</li>
</ul>
<p><strong>Note</strong>: This setting affects display format only. Parsing accepts any number of digits:</p>
<ul>
<li><code>USR-1</code>, <code>USR-01</code>, <code>USR-001</code> all parse as ID 1</li>
<li>Display format uses the configured padding</li>
</ul>
<p><strong>Example - Large project</strong>:</p>
<pre><code class="language-toml">digits = 4
# Requirements display as USR-0001, USR-0002, etc.
</code></pre>
<h3 id="allow_unrecognised-optional"><a class="header" href="#allow_unrecognised-optional"><code>allow_unrecognised</code> (optional)</a></h3>
<pre><code class="language-toml">allow_unrecognised = false
</code></pre>
<p><strong>Type</strong>: Boolean</p>
<p><strong>Default</strong>: <code>false</code></p>
<p><strong>Purpose</strong>: Controls whether markdown files that don't match the HRID pattern are allowed in the requirements directory.</p>
<p><strong>Behavior</strong>:</p>
<p><strong><code>false</code> (default - strict mode)</strong>:</p>
<ul>
<li>Only files matching the HRID pattern (e.g., <code>USR-001.md</code>) are allowed</li>
<li>Any other <code>.md</code> file causes an error during loading</li>
<li>Ensures clean, requirements-only directory</li>
</ul>
<p><strong><code>true</code> (permissive mode)</strong>:</p>
<ul>
<li>Files with non-HRID names are silently ignored</li>
<li>Useful when requirements live alongside other documentation</li>
</ul>
<p><strong>When to use <code>true</code></strong>:</p>
<p><strong>Integration with documentation tools</strong>:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ config.toml          ‚Üê allow_unrecognised = true
‚îú‚îÄ‚îÄ introduction.md      ‚Üê Ignored (not an HRID)
‚îú‚îÄ‚îÄ architecture.md      ‚Üê Ignored
‚îú‚îÄ‚îÄ USR-001.md          ‚Üê Loaded as requirement
‚îî‚îÄ‚îÄ USR-002.md          ‚Üê Loaded as requirement
</code></pre>
<p><strong>Mixed content repositories</strong>:</p>
<pre><code>project-docs/
‚îú‚îÄ‚îÄ README.md           ‚Üê Ignored
‚îú‚îÄ‚îÄ CHANGELOG.md        ‚Üê Ignored
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md      ‚Üê Loaded
‚îÇ   ‚îî‚îÄ‚îÄ SYS-001.md      ‚Üê Loaded
</code></pre>
<p><strong>When to use <code>false</code> (default)</strong>:</p>
<ul>
<li>Dedicated requirements directory</li>
<li>Strict separation between requirements and other docs</li>
<li>Catch typos (e.g., <code>US-001.md</code> instead of <code>USR-001.md</code>)</li>
</ul>
<p><strong>Error example with <code>allow_unrecognised = false</code></strong>:</p>
<pre><code class="language-bash">$ req clean
Error: Unrecognised file: README.md
</code></pre>
<h3 id="allow_invalid-optional"><a class="header" href="#allow_invalid-optional"><code>allow_invalid</code> (optional)</a></h3>
<pre><code class="language-toml">allow_invalid = false
</code></pre>
<p><strong>Type</strong>: Boolean</p>
<p><strong>Default</strong>: <code>false</code></p>
<p><strong>Purpose</strong>: Controls whether requirement files with invalid YAML frontmatter or formatting errors are allowed.</p>
<p><strong>Behavior</strong>:</p>
<p><strong><code>false</code> (default - strict mode)</strong>:</p>
<ul>
<li>Requirements must have valid YAML frontmatter</li>
<li>Missing required fields cause errors</li>
<li>Ensures data integrity</li>
</ul>
<p><strong><code>true</code> (permissive mode)</strong>:</p>
<ul>
<li>Invalid requirements are skipped with warnings</li>
<li>Partial loading allows working with partially correct data</li>
<li>Useful during migration or recovery</li>
</ul>
<p><strong>Validation checks</strong>:</p>
<ul>
<li>Valid YAML syntax</li>
<li>Required fields present (<code>_version</code>, <code>uuid</code>, <code>created</code>)</li>
<li>Valid UUID format</li>
<li>Valid timestamp format</li>
<li>Valid parent structure (if present)</li>
</ul>
<p><strong>When to use <code>true</code></strong>:</p>
<ul>
<li>Migrating from another tool (gradual fix-up)</li>
<li>Recovering from manual editing errors</li>
<li>Development/debugging</li>
</ul>
<p><strong>When to use <code>false</code> (default)</strong>:</p>
<ul>
<li>Production use</li>
<li>Ensure data quality</li>
<li>Catch errors early</li>
</ul>
<p><strong>Error example with <code>allow_invalid = false</code></strong>:</p>
<pre><code class="language-bash">$ req clean
Error: Invalid requirement USR-001.md: missing required field 'uuid'
</code></pre>
<p><strong>Warning example with <code>allow_invalid = true</code></strong>:</p>
<pre><code class="language-bash">$ req clean
Warning: Skipping invalid requirement USR-001.md: missing required field 'uuid'
Successfully loaded 42 requirements (1 skipped)
</code></pre>
<h2 id="configuration-strategy"><a class="header" href="#configuration-strategy">Configuration Strategy</a></h2>
<h3 id="start-simple"><a class="header" href="#start-simple">Start Simple</a></h3>
<p>Begin with minimal configuration:</p>
<pre><code class="language-toml">_version = "1"
</code></pre>
<p>Add constraints as your project matures.</p>
<h3 id="recommended-settings"><a class="header" href="#recommended-settings">Recommended Settings</a></h3>
<p><strong>Small project (&lt; 100 requirements)</strong>:</p>
<pre><code class="language-toml">_version = "1"
digits = 3
allow_unrecognised = false
allow_invalid = false
</code></pre>
<p><strong>Large project (&gt; 1000 requirements)</strong>:</p>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS", "SWR", "HWR", "TST", "DOC"]
digits = 4
allow_unrecognised = false
allow_invalid = false
</code></pre>
<p><strong>Integrated documentation project</strong>:</p>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS"]
digits = 3
allow_unrecognised = true  # Mixed with other docs
allow_invalid = false
</code></pre>
<p><strong>Migration project</strong>:</p>
<pre><code class="language-toml">_version = "1"
digits = 3
allow_unrecognised = true
allow_invalid = true  # Temporarily permissive during migration
</code></pre>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>Validate your configuration by running:</p>
<pre><code class="language-bash">req clean
</code></pre>
<p>This loads all requirements and reports configuration-related errors.</p>
<p><strong>Successful validation</strong>:</p>
<pre><code class="language-bash">$ req clean
# No output = success
</code></pre>
<p><strong>Configuration error</strong>:</p>
<pre><code class="language-bash">$ req clean
Error: Failed to parse config file: missing field '_version'
</code></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="regulated-industry-aerospace"><a class="header" href="#regulated-industry-aerospace">Regulated Industry (Aerospace)</a></h3>
<pre><code class="language-toml">_version = "1"

# DO-178C levels: User, System, Software, Hardware, Test
allowed_kinds = ["URQT", "SRQT", "SWRQT", "HWRQT", "TRQT"]

# Large project
digits = 4

# Strict validation
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h3 id="agile-software-project"><a class="header" href="#agile-software-project">Agile Software Project</a></h3>
<pre><code class="language-toml">_version = "1"

# User stories, system reqs, tests
allowed_kinds = ["USR", "SYS", "TST"]

# Small/medium project
digits = 3

# Allow flexibility
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h3 id="multi-component-system"><a class="header" href="#multi-component-system">Multi-Component System</a></h3>
<pre><code class="language-toml">_version = "1"

# Component-prefixed kinds
allowed_kinds = [
    "USR",           # Cross-cutting user requirements
    "AUTH-SYS",      # Authentication subsystem
    "PAY-SYS",       # Payment subsystem
    "REPORT-SYS",    # Reporting subsystem
]

digits = 3
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="config-file-not-recognized"><a class="header" href="#config-file-not-recognized">Config file not recognized</a></h3>
<p><strong>Problem</strong>: Changes to <code>config.toml</code> don't take effect.</p>
<p><strong>Solution</strong>: Ensure the file is named exactly <code>config.toml</code> (lowercase, no extra extensions) and is in the requirements root directory.</p>
<h3 id="parse-errors"><a class="header" href="#parse-errors">Parse errors</a></h3>
<p><strong>Problem</strong>: <code>Error: Failed to parse config file</code></p>
<p><strong>Solution</strong>: Validate TOML syntax:</p>
<ul>
<li>Strings must be quoted: <code>_version = "1"</code>, not <code>_version = 1</code></li>
<li>Arrays use square brackets: <code>allowed_kinds = ["USR", "SYS"]</code></li>
<li>Check for typos in field names</li>
</ul>
<p>Use a TOML validator or linter if needed.</p>
<h3 id="unexpected-behavior"><a class="header" href="#unexpected-behavior">Unexpected behavior</a></h3>
<p><strong>Problem</strong>: Requirements are rejected unexpectedly.</p>
<p><strong>Solution</strong>:</p>
<ol>
<li>Check <code>allowed_kinds</code> - ensure the kinds you're using are listed</li>
<li>Check <code>allow_unrecognised</code> - set to <code>true</code> if mixing requirements with other docs</li>
<li>Check <code>allow_invalid</code> - consider temporarily enabling for debugging</li>
</ol>
<h2 id="future-configuration-options"><a class="header" href="#future-configuration-options">Future Configuration Options</a></h2>
<p>Planned configuration options (not yet implemented):</p>
<ul>
<li><strong><code>namespace_separator</code></strong>: Customize the separator in namespaced HRIDs</li>
<li><strong><code>require_namespaces</code></strong>: Enforce namespace usage</li>
<li><strong><code>max_parents</code></strong>: Limit number of parent requirements</li>
<li><strong><code>tag_validation</code></strong>: Restrict allowed tag values</li>
<li><strong><code>review_policies</code></strong>: Configure review workflow behavior</li>
</ul>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li>Learn about <a href="configuration/./directory-structure.html">Directory Structure</a> for organizing requirements</li>
<li>Understand <a href="configuration/./namespaces.html">Namespaces</a> for large projects</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h1>
<p>Requiem is flexible about how you organize requirements on disk. This chapter explains directory organization options and best practices.</p>
<h2 id="directory-structure-modes"><a class="header" href="#directory-structure-modes">Directory Structure Modes</a></h2>
<p>Requiem supports two fundamental modes for organizing requirements, controlled by the <code>subfolders_are_namespaces</code> configuration option:</p>
<h3 id="1-filename-based-mode-default"><a class="header" href="#1-filename-based-mode-default">1. Filename-Based Mode (Default)</a></h3>
<p><strong>Configuration</strong>: <code>subfolders_are_namespaces = false</code> (or omitted)</p>
<p>In this mode, the full HRID is encoded in the filename, and directory structure is purely organizational:</p>
<pre><code>my-requirements/
‚îú‚îÄ‚îÄ USR-001.md              ‚Üí HRID: USR-001
‚îú‚îÄ‚îÄ SYS-002.md              ‚Üí HRID: SYS-002
‚îú‚îÄ‚îÄ auth-USR-003.md         ‚Üí HRID: auth-USR-003
‚îî‚îÄ‚îÄ custom/folder/
    ‚îî‚îÄ‚îÄ system-REQ-004.md   ‚Üí HRID: system-REQ-004
</code></pre>
<p><strong>Use when</strong>: You want maximum flexibility in folder organization without affecting requirement namespaces.</p>
<h3 id="2-path-based-mode"><a class="header" href="#2-path-based-mode">2. Path-Based Mode</a></h3>
<p><strong>Configuration</strong>: <code>subfolders_are_namespaces = true</code></p>
<p>In this mode, subfolders encode the namespace, and the filename contains only KIND-ID:</p>
<pre><code>my-requirements/
‚îú‚îÄ‚îÄ REQ-001.md              ‚Üí HRID: REQ-001 (no namespace)
‚îú‚îÄ‚îÄ system/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îú‚îÄ‚îÄ REQ-002.md      ‚Üí HRID: system-auth-REQ-002
‚îÇ       ‚îî‚îÄ‚îÄ USR/
‚îÇ           ‚îî‚îÄ‚îÄ 003.md      ‚Üí HRID: system-auth-USR-003 (KIND from parent)
</code></pre>
<p>The filename format is automatically inferred:</p>
<ul>
<li><strong>Numeric only</strong> (e.g., <code>003.md</code>) ‚Üí KIND taken from parent folder</li>
<li><strong>KIND-ID</strong> (e.g., <code>REQ-002.md</code>) ‚Üí KIND and ID from filename</li>
</ul>
<p><strong>Use when</strong>: You want folder structure to directly mirror requirement namespaces.</p>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>At minimum, you need a directory containing requirement markdown files:</p>
<pre><code>my-requirements/
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ SYS-001.md
‚îî‚îÄ‚îÄ SYS-002.md
</code></pre>
<p>That's it! No initialization or hidden directories required.</p>
<h2 id="with-configuration"><a class="header" href="#with-configuration">With Configuration</a></h2>
<p>Add a <code>config.toml</code> for project-specific settings:</p>
<pre><code>my-requirements/
‚îú‚îÄ‚îÄ config.toml      ‚Üê Configuration
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ SYS-001.md
‚îî‚îÄ‚îÄ SYS-002.md
</code></pre>
<p>The configuration file is optional but recommended for projects with specific needs.</p>
<h2 id="using-subdirectories"><a class="header" href="#using-subdirectories">Using Subdirectories</a></h2>
<p>Requiem recursively searches subdirectories, enabling hierarchical organization.</p>
<h3 id="organize-by-requirement-kind"><a class="header" href="#organize-by-requirement-kind">Organize by Requirement Kind</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
‚îÇ   ‚îú‚îÄ‚îÄ USR-002.md
‚îÇ   ‚îî‚îÄ‚îÄ USR-003.md
‚îú‚îÄ‚îÄ system/
‚îÇ   ‚îú‚îÄ‚îÄ SYS-001.md
‚îÇ   ‚îú‚îÄ‚îÄ SYS-002.md
‚îÇ   ‚îî‚îÄ‚îÄ SYS-003.md
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ TST-001.md
    ‚îî‚îÄ‚îÄ TST-002.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Clear separation of requirement levels</li>
<li>Easy to navigate</li>
<li>Natural for large projects</li>
</ul>
<p><strong>Note</strong>: In filename-based mode (default), directory names don't affect requirement behavior. <code>user/USR-001.md</code> and <code>system/USR-001.md</code> would create a filename conflict (both have HRID <code>USR-001</code>), so use different kinds. In path-based mode, these would have different HRIDs: <code>user-USR-001</code> and <code>system-USR-001</code>.</p>
<h3 id="organize-by-feature"><a class="header" href="#organize-by-feature">Organize by Feature</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ authentication/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md   # User login
‚îÇ   ‚îú‚îÄ‚îÄ SYS-001.md   # Auth service
‚îÇ   ‚îî‚îÄ‚îÄ TST-001.md   # Auth tests
‚îú‚îÄ‚îÄ payment/
‚îÇ   ‚îú‚îÄ‚îÄ USR-002.md   # Payment processing
‚îÇ   ‚îú‚îÄ‚îÄ SYS-002.md   # Payment gateway
‚îÇ   ‚îî‚îÄ‚îÄ TST-002.md   # Payment tests
‚îî‚îÄ‚îÄ reporting/
    ‚îú‚îÄ‚îÄ USR-003.md   # Report generation
    ‚îî‚îÄ‚îÄ SYS-003.md   # Report engine
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Groups related requirements</li>
<li>Mirrors feature structure</li>
<li>Good for feature-based development</li>
</ul>
<h3 id="organize-by-component"><a class="header" href="#organize-by-component">Organize by Component</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ WEB-USR-001.md
‚îÇ   ‚îú‚îÄ‚îÄ WEB-SYS-001.md
‚îÇ   ‚îú‚îÄ‚îÄ MOBILE-USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ MOBILE-SYS-001.md
‚îî‚îÄ‚îÄ backend/
    ‚îú‚îÄ‚îÄ API-SYS-001.md
    ‚îú‚îÄ‚îÄ DB-SYS-001.md
    ‚îî‚îÄ‚îÄ CACHE-SYS-001.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Aligns with system architecture</li>
<li>Clear ownership boundaries</li>
<li>Natural for microservices</li>
</ul>
<p><strong>Note</strong>: Consider using namespaces in HRIDs (e.g., <code>WEB-USR-001</code>) to avoid conflicts.</p>
<h3 id="deep-hierarchies"><a class="header" href="#deep-hierarchies">Deep Hierarchies</a></h3>
<p>Requiem supports arbitrary nesting:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îî‚îÄ‚îÄ product/
    ‚îú‚îÄ‚îÄ core/
    ‚îÇ   ‚îú‚îÄ‚îÄ auth/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SYS-001.md
    ‚îÇ   ‚îî‚îÄ‚îÄ data/
    ‚îÇ       ‚îú‚îÄ‚îÄ USR-002.md
    ‚îÇ       ‚îî‚îÄ‚îÄ SYS-002.md
    ‚îî‚îÄ‚îÄ plugins/
        ‚îú‚îÄ‚îÄ export/
        ‚îÇ   ‚îî‚îÄ‚îÄ USR-003.md
        ‚îî‚îÄ‚îÄ import/
            ‚îî‚îÄ‚îÄ USR-004.md
</code></pre>
<p><strong>Caution</strong>: Deep hierarchies can be harder to navigate. Consider flat or shallow structures unless your project naturally requires depth.</p>
<h2 id="flat-vs-hierarchical"><a class="header" href="#flat-vs-hierarchical">Flat vs. Hierarchical</a></h2>
<h3 id="flat-structure"><a class="header" href="#flat-structure">Flat Structure</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ USR-050.md
‚îú‚îÄ‚îÄ SYS-001.md
‚îú‚îÄ‚îÄ SYS-002.md
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ SYS-100.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simple and straightforward</li>
<li>Easy to understand</li>
<li>Works well for small/medium projects (&lt; 100 requirements)</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Directory listing can become unwieldy with many requirements</li>
<li>Harder to navigate in file browser with 100+ files</li>
</ul>
<p><strong>Best for</strong>: Small to medium projects, single-component systems.</p>
<h3 id="hierarchical-structure"><a class="header" href="#hierarchical-structure">Hierarchical Structure</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ user-requirements/
‚îÇ   ‚îî‚îÄ‚îÄ (50 files)
‚îú‚îÄ‚îÄ system-requirements/
‚îÇ   ‚îî‚îÄ‚îÄ (100 files)
‚îî‚îÄ‚îÄ test-requirements/
    ‚îî‚îÄ‚îÄ (150 files)
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Scalable to large projects (1000+ requirements)</li>
<li>Natural organization</li>
<li>Easier to navigate</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Slightly more complex</li>
<li>Must decide on hierarchy scheme</li>
</ul>
<p><strong>Best for</strong>: Large projects, multi-component systems.</p>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-start-flat-refactor-when-needed"><a class="header" href="#1-start-flat-refactor-when-needed">1. Start Flat, Refactor When Needed</a></h3>
<p>Begin with a flat structure:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ SYS-001.md
</code></pre>
<p>Introduce subdirectories when you have 50+ requirements or natural groupings emerge.</p>
<h3 id="2-use-consistent-naming"><a class="header" href="#2-use-consistent-naming">2. Use Consistent Naming</a></h3>
<p>If using subdirectories, name them consistently:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ 1-user-requirements/
‚îú‚îÄ‚îÄ 2-system-requirements/
‚îú‚îÄ‚îÄ 3-software-requirements/
‚îî‚îÄ‚îÄ 4-test-requirements/
</code></pre>
<p>Or:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ user/
‚îú‚îÄ‚îÄ system/
‚îú‚îÄ‚îÄ software/
‚îî‚îÄ‚îÄ test/
</code></pre>
<p><strong>Avoid</strong>: Mixing naming schemes (<code>user_reqs/</code>, <code>system-requirements/</code>, <code>Tests/</code>).</p>
<h3 id="3-keep-shallow-2-3-levels-max"><a class="header" href="#3-keep-shallow-2-3-levels-max">3. Keep Shallow (2-3 Levels Max)</a></h3>
<p>Prefer:</p>
<pre><code>requirements/
‚îî‚îÄ‚îÄ user/
    ‚îî‚îÄ‚îÄ USR-001.md
</code></pre>
<p>Over:</p>
<pre><code>requirements/
‚îî‚îÄ‚îÄ level1/
    ‚îî‚îÄ‚îÄ level2/
        ‚îî‚îÄ‚îÄ level3/
            ‚îî‚îÄ‚îÄ level4/
                ‚îî‚îÄ‚îÄ USR-001.md
</code></pre>
<p>Deep hierarchies are hard to navigate and remember.</p>
<h3 id="4-align-with-team-structure"><a class="header" href="#4-align-with-team-structure">4. Align with Team Structure</a></h3>
<p>Organize to match how your team works:</p>
<p><strong>Team by feature</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ login-team/
‚îú‚îÄ‚îÄ payment-team/
‚îî‚îÄ‚îÄ reporting-team/
</code></pre>
<p><strong>Team by layer</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ product-managers/  (USR requirements)
‚îú‚îÄ‚îÄ architects/        (SYS requirements)
‚îî‚îÄ‚îÄ developers/        (SWR requirements)
</code></pre>
<h3 id="5-dont-encode-information-in-paths"><a class="header" href="#5-dont-encode-information-in-paths">5. Don't Encode Information in Paths</a></h3>
<p><strong>Bad</strong>:</p>
<pre><code>requirements/
‚îî‚îÄ‚îÄ high-priority/
    ‚îî‚îÄ‚îÄ USR-001.md  # Priority encoded in directory
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code>requirements/
‚îî‚îÄ‚îÄ USR-001.md

# USR-001.md content:
---
tags:
- high-priority
---
The requirement text...
</code></pre>
<p>Use tags or content for metadata, not directory structure. Directories are for organization only.</p>
<h2 id="special-cases"><a class="header" href="#special-cases">Special Cases</a></h2>
<h3 id="mixed-content-requirements--documentation"><a class="header" href="#mixed-content-requirements--documentation">Mixed Content (Requirements + Documentation)</a></h3>
<p>If requirements live alongside other documentation:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ introduction.md      ‚Üê Not a requirement
‚îú‚îÄ‚îÄ architecture.md      ‚Üê Not a requirement
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md      ‚Üê Requirement
‚îÇ   ‚îî‚îÄ‚îÄ SYS-001.md      ‚Üê Requirement
‚îî‚îÄ‚îÄ user-guide.md        ‚Üê Not a requirement
</code></pre>
<p>Set <code>allow_unrecognised = true</code> in <code>config.toml</code> to allow non-requirement markdown files.</p>
<h3 id="integration-with-mdbook"><a class="header" href="#integration-with-mdbook">Integration with MdBook</a></h3>
<p>MdBook projects:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ book.toml           ‚Üê MdBook config
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ SUMMARY.md      ‚Üê MdBook table of contents
‚îÇ   ‚îú‚îÄ‚îÄ chapter1.md     ‚Üê Documentation
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md      ‚Üê Requirement (can be in SUMMARY.md)
‚îÇ   ‚îî‚îÄ‚îÄ USR-002.md      ‚Üê Requirement
‚îî‚îÄ‚îÄ config.toml         ‚Üê Requiem config (allow_unrecognised = true)
</code></pre>
<p>See <a href="configuration/../integration/mdbook.html">Integration &gt; Using with MdBook</a> for details.</p>
<h3 id="integration-with-sphinx"><a class="header" href="#integration-with-sphinx">Integration with Sphinx</a></h3>
<p>Sphinx projects:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ conf.py             ‚Üê Sphinx config
‚îú‚îÄ‚îÄ index.md
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ config.toml     ‚Üê Requiem config
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md      ‚Üê Requirement
‚îÇ   ‚îî‚îÄ‚îÄ SYS-001.md      ‚Üê Requirement
‚îî‚îÄ‚îÄ other-content.md
</code></pre>
<p>See <a href="configuration/../integration/sphinx.html">Integration &gt; Using with Sphinx</a> for details.</p>
<h3 id="monorepo-structure"><a class="header" href="#monorepo-structure">Monorepo Structure</a></h3>
<p>Large monorepos with multiple products:</p>
<pre><code>monorepo/
‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îú‚îÄ‚îÄ web-app/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requirements/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ config.toml
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ WEB-USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ mobile-app/
‚îÇ       ‚îî‚îÄ‚îÄ requirements/
‚îÇ           ‚îú‚îÄ‚îÄ config.toml
‚îÇ           ‚îî‚îÄ‚îÄ MOBILE-USR-001.md
‚îî‚îÄ‚îÄ shared/
    ‚îî‚îÄ‚îÄ requirements/
        ‚îú‚îÄ‚îÄ config.toml
        ‚îî‚îÄ‚îÄ CORE-SYS-001.md
</code></pre>
<p>Each product/component has its own independent requirements directory with separate <code>config.toml</code>.</p>
<h2 id="file-system-considerations"><a class="header" href="#file-system-considerations">File System Considerations</a></h2>
<h3 id="case-sensitivity"><a class="header" href="#case-sensitivity">Case Sensitivity</a></h3>
<p><strong>Linux/Mac</strong>: Filenames are case-sensitive</p>
<ul>
<li><code>USR-001.md</code> and <code>usr-001.md</code> are different files</li>
<li>Requiem only recognizes <code>USR-001.md</code> (uppercase HRID)</li>
</ul>
<p><strong>Windows</strong>: Filenames are case-insensitive</p>
<ul>
<li><code>USR-001.md</code> and <code>usr-001.md</code> refer to the same file</li>
<li>Use consistent casing to avoid issues</li>
</ul>
<p><strong>Recommendation</strong>: Always use uppercase HRIDs to avoid cross-platform issues.</p>
<h3 id="symbolic-links"><a class="header" href="#symbolic-links">Symbolic Links</a></h3>
<p>Requiem follows symbolic links when scanning for requirements:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ current -&gt; v2.0/     ‚Üê Symlink
‚îú‚îÄ‚îÄ v1.0/
‚îÇ   ‚îî‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ v2.0/
    ‚îî‚îÄ‚îÄ USR-001.md
</code></pre>
<p><strong>Caution</strong>: Ensure symlinks don't create cycles or duplicate requirements.</p>
<h3 id="hidden-files-and-directories"><a class="header" href="#hidden-files-and-directories">Hidden Files and Directories</a></h3>
<p>Files and directories starting with <code>.</code> are typically ignored by Requiem (following standard Unix convention):</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ .git/               ‚Üê Ignored
‚îú‚îÄ‚îÄ .DS_Store           ‚Üê Ignored (Mac)
‚îú‚îÄ‚îÄ config.toml
‚îî‚îÄ‚îÄ USR-001.md
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="large-directories"><a class="header" href="#large-directories">Large Directories</a></h3>
<p>Requiem uses parallel loading for performance:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ USR-5000.md  # 5000 files loads quickly due to parallelism
</code></pre>
<p><strong>Performance</strong>: Requiem can handle thousands of requirements efficiently. Directory structure has minimal performance impact.</p>
<h3 id="network-file-systems"><a class="header" href="#network-file-systems">Network File Systems</a></h3>
<p>If requirements are on a network drive:</p>
<ul>
<li>Initial loading may be slower</li>
<li>Consider using subdirectories to localize access patterns</li>
<li>Parallel loading helps mitigate network latency</li>
</ul>
<h2 id="choosing-between-modes"><a class="header" href="#choosing-between-modes">Choosing Between Modes</a></h2>
<h3 id="when-to-use-filename-based-mode-default"><a class="header" href="#when-to-use-filename-based-mode-default">When to Use Filename-Based Mode (Default)</a></h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Maximum flexibility - organize folders however you want</li>
<li>Easy to move files between folders without changing HRIDs</li>
<li>Works well with arbitrary organizational schemes (by feature, by team, etc.)</li>
<li>Explicit namespaces visible in every filename</li>
</ul>
<p><strong>Best for</strong>:</p>
<ul>
<li>Projects where folder structure is organizational, not semantic</li>
<li>Teams that reorganize folders frequently</li>
<li>Mixed organizational schemes</li>
<li>When you want full control over namespaces</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ team-a/
‚îÇ   ‚îî‚îÄ‚îÄ auth-USR-001.md      ‚Üí HRID: auth-USR-001
‚îî‚îÄ‚îÄ team-b/
    ‚îî‚îÄ‚îÄ auth-SYS-002.md      ‚Üí HRID: auth-SYS-002
</code></pre>
<h3 id="when-to-use-path-based-mode"><a class="header" href="#when-to-use-path-based-mode">When to Use Path-Based Mode</a></h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Cleaner filenames (shorter, less redundant)</li>
<li>Folder structure enforces namespace consistency</li>
<li>Natural for hierarchical component structures</li>
<li>Automatic namespace creation from folders</li>
</ul>
<p><strong>Best for</strong>:</p>
<ul>
<li>Projects with stable, hierarchical component structures</li>
<li>When folder structure mirrors system architecture</li>
<li>Microservices or multi-component systems</li>
<li>When you want enforced namespace-folder alignment</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md           ‚Üí HRID: auth-USR-001
‚îÇ   ‚îî‚îÄ‚îÄ SYS-002.md           ‚Üí HRID: auth-SYS-002
‚îî‚îÄ‚îÄ payment/
    ‚îú‚îÄ‚îÄ USR-001.md           ‚Üí HRID: payment-USR-001
    ‚îî‚îÄ‚îÄ SYS-002.md           ‚Üí HRID: payment-SYS-002
</code></pre>
<h3 id="comparison-table"><a class="header" href="#comparison-table">Comparison Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Filename-Based</th><th>Path-Based</th></tr></thead><tbody>
<tr><td><strong>Filename contains</strong></td><td>Full HRID</td><td>KIND-ID only</td></tr>
<tr><td><strong>Namespace from</strong></td><td>Filename</td><td>Folder path</td></tr>
<tr><td><strong>Folder flexibility</strong></td><td>High</td><td>Low (tied to namespace)</td></tr>
<tr><td><strong>File move impact</strong></td><td>None</td><td>Changes HRID</td></tr>
<tr><td><strong>Filename length</strong></td><td>Longer</td><td>Shorter</td></tr>
<tr><td><strong>Default mode</strong></td><td>Yes</td><td>No</td></tr>
</tbody></table>
</div>
<h2 id="migration-between-modes"><a class="header" href="#migration-between-modes">Migration Between Modes</a></h2>
<h3 id="converting-from-filename-based-to-path-based"><a class="header" href="#converting-from-filename-based-to-path-based">Converting from Filename-Based to Path-Based</a></h3>
<ol>
<li><strong>Update configuration</strong>:</li>
</ol>
<pre><code class="language-toml"># config.toml
_version = "1"
subfolders_are_namespaces = true
</code></pre>
<ol start="2">
<li><strong>Reorganize files</strong> to match namespace structure:</li>
</ol>
<pre><code class="language-bash"># Before (filename-based):
# requirements/
# ‚îú‚îÄ‚îÄ auth-USR-001.md
# ‚îî‚îÄ‚îÄ payment-USR-002.md

# Create namespace folders
mkdir -p auth payment

# Move and rename files
mv auth-USR-001.md auth/USR-001.md
mv payment-USR-002.md payment/USR-002.md

# After (path-based):
# requirements/
# ‚îú‚îÄ‚îÄ auth/
# ‚îÇ   ‚îî‚îÄ‚îÄ USR-001.md
# ‚îî‚îÄ‚îÄ payment/
#     ‚îî‚îÄ‚îÄ USR-002.md
</code></pre>
<ol start="3">
<li><strong>Verify</strong>:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<h3 id="converting-from-path-based-to-filename-based"><a class="header" href="#converting-from-path-based-to-filename-based">Converting from Path-Based to Filename-Based</a></h3>
<ol>
<li><strong>Flatten files</strong> and encode namespace in filename:</li>
</ol>
<pre><code class="language-bash"># Before (path-based):
# requirements/
# ‚îú‚îÄ‚îÄ auth/
# ‚îÇ   ‚îî‚îÄ‚îÄ USR-001.md        (HRID: auth-USR-001)
# ‚îî‚îÄ‚îÄ payment/
#     ‚îî‚îÄ‚îÄ USR-002.md        (HRID: payment-USR-002)

# Move and rename with full HRID
mv auth/USR-001.md auth-USR-001.md
mv payment/USR-002.md payment-USR-002.md

# Remove now-empty folders
rmdir auth payment

# After (filename-based):
# requirements/
# ‚îú‚îÄ‚îÄ auth-USR-001.md
# ‚îî‚îÄ‚îÄ payment-USR-002.md
</code></pre>
<ol start="2">
<li><strong>Update configuration</strong>:</li>
</ol>
<pre><code class="language-toml"># config.toml
_version = "1"
subfolders_are_namespaces = false
</code></pre>
<ol start="3">
<li><strong>Verify</strong>:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<p><strong>Note</strong>: When converting between modes, the HRID (and thus UUID) remains the same, preserving all links and history.</p>
<h2 id="migration-and-refactoring"><a class="header" href="#migration-and-refactoring">Migration and Refactoring</a></h2>
<h3 id="reorganizing-files"><a class="header" href="#reorganizing-files">Reorganizing Files</a></h3>
<p>To reorganize directory structure in filename-based mode:</p>
<ol>
<li>Move requirement files:</li>
</ol>
<pre><code class="language-bash">mkdir system
mv SYS-*.md system/
</code></pre>
<ol start="2">
<li>Verify:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<ol start="3">
<li>Commit:</li>
</ol>
<pre><code class="language-bash">git add -A
git commit -m "Organize system requirements into subdirectory"
</code></pre>
<p><strong>Safe because</strong>: Requirements are identified by HRID (filename), not path. Moving files doesn't break links.</p>
<h3 id="splitting-directories"><a class="header" href="#splitting-directories">Splitting Directories</a></h3>
<p>To split a large flat directory:</p>
<pre><code class="language-bash"># Before
requirements/
‚îú‚îÄ‚îÄ USR-001.md (100 files)

# After
requirements/
‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îî‚îÄ‚îÄ USR-001.md (100 files)
‚îî‚îÄ‚îÄ system/
    ‚îî‚îÄ‚îÄ SYS-001.md (100 files)
</code></pre>
<p>Steps:</p>
<pre><code class="language-bash">mkdir user system test
mv USR-*.md user/
mv SYS-*.md system/
mv TST-*.md test/
req clean  # Verify
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p><strong>Key Takeaways</strong>:</p>
<ol>
<li><strong>Flexible</strong>: Flat or hierarchical, your choice</li>
<li><strong>Recursive</strong>: Subdirectories are automatically scanned</li>
<li><strong>Simple</strong>: Directory names don't affect requirement behavior</li>
<li><strong>Scalable</strong>: Supports small projects (10s) to large (1000s)</li>
<li><strong>Reorganizable</strong>: Safe to move files (links use UUIDs, not paths)</li>
</ol>
<p><strong>Recommendations</strong>:</p>
<ul>
<li>Start flat, add structure as needed</li>
<li>Keep shallow (2-3 levels max)</li>
<li>Organize by kind, feature, or component</li>
<li>Use consistent naming conventions</li>
<li>Align with team structure</li>
</ul>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li>Understand <a href="configuration/./namespaces.html">Namespaces</a> for large multi-component projects</li>
<li>Learn about <a href="configuration/../integration/version-control.html">Version Control Best Practices</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Namespaces extend HRIDs with prefixes to organize requirements in large, multi-component projects. This chapter explains when and how to use them.</p>
<h2 id="what-are-namespaces"><a class="header" href="#what-are-namespaces">What Are Namespaces?</a></h2>
<p>A namespace is an optional prefix in an HRID that provides additional context:</p>
<pre><code>USR-001              # No namespace
AUTH-USR-001         # One namespace level: AUTH
AUTH-LOGIN-USR-001   # Two namespace levels: AUTH, LOGIN
A-B-C-USR-001        # Three namespace levels: A, B, C
</code></pre>
<h3 id="hrid-format-with-namespaces"><a class="header" href="#hrid-format-with-namespaces">HRID Format with Namespaces</a></h3>
<p>Complete format:</p>
<pre><code>{NAMESPACE-}*{KIND}-{ID}
</code></pre>
<p>Where:</p>
<ul>
<li><code>NAMESPACE</code>: Zero or more namespace segments</li>
<li><code>KIND</code>: Requirement kind (e.g., USR, SYS)</li>
<li><code>ID</code>: Numeric identifier</li>
</ul>
<p>Examples:</p>
<pre><code>USR-001                    # KIND=USR, ID=001, namespace=[]
COMPONENT-USR-001          # KIND=USR, ID=001, namespace=[COMPONENT]
AUTH-LOGIN-SYS-042         # KIND=SYS, ID=042, namespace=[AUTH, LOGIN]
</code></pre>
<h2 id="when-to-use-namespaces-1"><a class="header" href="#when-to-use-namespaces-1">When to Use Namespaces</a></h2>
<h3 id="large-projects"><a class="header" href="#large-projects">Large Projects</a></h3>
<p>Projects with many requirements benefit from namespacing:</p>
<pre><code># Without namespaces (confusion)
USR-001  # Which component?
USR-002  # Auth or payment?
USR-003  # Mobile or web?

# With namespaces (clarity)
AUTH-USR-001    # Authentication user requirement
PAY-USR-002     # Payment user requirement
MOBILE-USR-003  # Mobile app user requirement
</code></pre>
<h3 id="multi-component-systems"><a class="header" href="#multi-component-systems">Multi-Component Systems</a></h3>
<p>Systems with distinct components or subsystems:</p>
<pre><code>FRONTEND-USR-001
FRONTEND-SYS-001

BACKEND-USR-001
BACKEND-SYS-001

DATABASE-SYS-001
CACHE-SYS-001
</code></pre>
<h3 id="product-families"><a class="header" href="#product-families">Product Families</a></h3>
<p>Related products sharing requirements:</p>
<pre><code>CORE-USR-001      # Shared across all products
CORE-SYS-001

MOBILE-USR-001    # Mobile-specific
MOBILE-SYS-001

WEB-USR-001       # Web-specific
WEB-SYS-001
</code></pre>
<h3 id="team-boundaries"><a class="header" href="#team-boundaries">Team Boundaries</a></h3>
<p>Map namespaces to team ownership:</p>
<pre><code>TEAM-ALPHA-USR-001    # Team Alpha's requirements
TEAM-BETA-USR-001     # Team Beta's requirements
SHARED-USR-001        # Cross-team requirements
</code></pre>
<h3 id="acquisitions-and-mergers"><a class="header" href="#acquisitions-and-mergers">Acquisitions and Mergers</a></h3>
<p>Integrate acquired codebases without renumbering:</p>
<pre><code>LEGACY-USR-001    # From acquired company (existing numbering)
NEW-USR-001       # Newly created requirements
</code></pre>
<h2 id="when-not-to-use-namespaces-1"><a class="header" href="#when-not-to-use-namespaces-1">When NOT to Use Namespaces</a></h2>
<h3 id="small-projects"><a class="header" href="#small-projects">Small Projects</a></h3>
<p>Projects with &lt; 100 requirements rarely need namespaces:</p>
<pre><code># Simple project (no namespace needed)
USR-001
USR-002
SYS-001
SYS-002
</code></pre>
<p>Namespaces add complexity without benefit for small projects.</p>
<h3 id="single-component"><a class="header" href="#single-component">Single Component</a></h3>
<p>If your project is a single cohesive unit:</p>
<pre><code># Single-component app
USR-001
SYS-001
TST-001
</code></pre>
<p>No need for namespaces unless planning for future growth.</p>
<h3 id="shallow-hierarchy"><a class="header" href="#shallow-hierarchy">Shallow Hierarchy</a></h3>
<p>If requirements naturally form a flat or shallow structure, namespaces may be overkill.</p>
<h2 id="namespace-strategies"><a class="header" href="#namespace-strategies">Namespace Strategies</a></h2>
<h3 id="strategy-1-by-component"><a class="header" href="#strategy-1-by-component">Strategy 1: By Component</a></h3>
<p>Organize by system architecture:</p>
<pre><code>AUTH-USR-001       # Authentication component
AUTH-SYS-001

API-USR-001        # API gateway
API-SYS-001

DB-SYS-001         # Database layer

CACHE-SYS-001      # Cache layer
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Mirrors system architecture</li>
<li>Clear component ownership</li>
<li>Natural for microservices</li>
</ul>
<p><strong>When to use</strong>: Systems with well-defined component boundaries.</p>
<h3 id="strategy-2-by-layer"><a class="header" href="#strategy-2-by-layer">Strategy 2: By Layer</a></h3>
<p>Organize by architectural layer:</p>
<pre><code>UI-USR-001         # User interface layer
UI-SYS-001

BL-SYS-001         # Business logic layer

DATA-SYS-001       # Data layer
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Aligns with layered architectures</li>
<li>Clear layer separation</li>
</ul>
<p><strong>When to use</strong>: Traditional n-tier applications.</p>
<h3 id="strategy-3-by-feature"><a class="header" href="#strategy-3-by-feature">Strategy 3: By Feature</a></h3>
<p>Organize by product feature:</p>
<pre><code>LOGIN-USR-001      # Login feature
LOGIN-SYS-001
LOGIN-TST-001

PAYMENT-USR-001    # Payment feature
PAYMENT-SYS-001
PAYMENT-TST-001

REPORTING-USR-001  # Reporting feature
REPORTING-SYS-001
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Groups related requirements</li>
<li>Feature-based development</li>
<li>Easy feature scoping</li>
</ul>
<p><strong>When to use</strong>: Feature-driven development, agile teams.</p>
<h3 id="strategy-4-hybrid"><a class="header" href="#strategy-4-hybrid">Strategy 4: Hybrid</a></h3>
<p>Combine multiple levels:</p>
<pre><code>MOBILE-AUTH-USR-001    # Mobile app, auth feature, user requirement
MOBILE-PAY-SYS-001     # Mobile app, payment feature, system requirement

WEB-AUTH-USR-001       # Web app, auth feature, user requirement
WEB-PAY-SYS-001        # Web app, payment feature, system requirement
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Maximum organization</li>
<li>Clear context at a glance</li>
</ul>
<p><strong>When to use</strong>: Very large, multi-product systems.</p>
<p><strong>Caution</strong>: Deep hierarchies can make HRIDs verbose. Balance clarity with brevity.</p>
<h2 id="namespace-depth"><a class="header" href="#namespace-depth">Namespace Depth</a></h2>
<h3 id="single-level"><a class="header" href="#single-level">Single Level</a></h3>
<pre><code>COMPONENT-USR-001
</code></pre>
<p><strong>Typical</strong>: 5-10 namespaces per project</p>
<p><strong>Best for</strong>: Medium projects with distinct components</p>
<h3 id="two-levels"><a class="header" href="#two-levels">Two Levels</a></h3>
<pre><code>PRODUCT-COMPONENT-USR-001
</code></pre>
<p><strong>Typical</strong>: 3-5 top-level namespaces, 3-7 sub-namespaces each</p>
<p><strong>Best for</strong>: Large projects, product families</p>
<h3 id="three-levels"><a class="header" href="#three-levels">Three+ Levels</a></h3>
<pre><code>ORG-PRODUCT-COMPONENT-USR-001
</code></pre>
<p><strong>Typical</strong>: Very large enterprises</p>
<p><strong>Best for</strong>: Massive systems, multi-organization projects</p>
<p><strong>Caution</strong>: HRIDs become long and unwieldy. Consider if truly necessary.</p>
<h2 id="namespace-naming-conventions"><a class="header" href="#namespace-naming-conventions">Namespace Naming Conventions</a></h2>
<h3 id="use-descriptive-names"><a class="header" href="#use-descriptive-names">Use Descriptive Names</a></h3>
<pre><code># Good
AUTH-USR-001      # Clear: authentication
PAYMENT-SYS-001   # Clear: payment processing

# Less clear
A-USR-001         # What is "A"?
MOD1-SYS-001      # What is "MOD1"?
</code></pre>
<h3 id="keep-short"><a class="header" href="#keep-short">Keep Short</a></h3>
<pre><code># Good
AUTH-USR-001      # 4 characters
PAY-USR-001       # 3 characters

# Too long
AUTHENTICATION-USR-001    # 14 characters
PAYMENT-PROCESSING-USR-001  # 18 characters
</code></pre>
<p>Aim for 3-8 characters per namespace segment.</p>
<h3 id="use-consistent-casing"><a class="header" href="#use-consistent-casing">Use Consistent Casing</a></h3>
<pre><code># Good (all uppercase)
AUTH-USR-001
PAYMENT-SYS-001

# Inconsistent (avoid)
auth-USR-001
Payment-SYS-001
</code></pre>
<p>Convention: Use uppercase to match KIND and ID conventions.</p>
<h3 id="avoid-special-characters"><a class="header" href="#avoid-special-characters">Avoid Special Characters</a></h3>
<pre><code># Good
AUTH-USR-001
PAYMENT-SYS-001

# Bad (don't use)
AUTH_USR-001      # Underscore confuses parsing
AUTH.USR.001      # Periods not supported
AUTH/USR/001      # Slashes not supported
</code></pre>
<p>Only use hyphens as separators.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<h3 id="creating-namespaced-requirements"><a class="header" href="#creating-namespaced-requirements">Creating Namespaced Requirements</a></h3>
<p>Use the namespace in the KIND argument:</p>
<pre><code class="language-bash"># Single namespace
req add AUTH-USR

# Output: Added requirement AUTH-USR-001
</code></pre>
<pre><code class="language-bash"># Two namespace levels
req add MOBILE-AUTH-SYS

# Output: Added requirement MOBILE-AUTH-SYS-001
</code></pre>
<h3 id="linking-namespaced-requirements"><a class="header" href="#linking-namespaced-requirements">Linking Namespaced Requirements</a></h3>
<p>Linking works identically:</p>
<pre><code class="language-bash">req link MOBILE-AUTH-SYS-001 AUTH-USR-001
</code></pre>
<p>Namespaces don't affect link functionality.</p>
<h3 id="file-naming"><a class="header" href="#file-naming">File Naming</a></h3>
<p>Filenames match HRIDs exactly:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ AUTH-USR-001.md
‚îú‚îÄ‚îÄ AUTH-SYS-001.md
‚îú‚îÄ‚îÄ PAYMENT-USR-001.md
‚îî‚îÄ‚îÄ MOBILE-AUTH-USR-001.md
</code></pre>
<h2 id="namespace-organization-with-directories"><a class="header" href="#namespace-organization-with-directories">Namespace Organization with Directories</a></h2>
<p>Combine namespaces with directory structure:</p>
<h3 id="option-1-match-namespace-to-directory"><a class="header" href="#option-1-match-namespace-to-directory">Option 1: Match Namespace to Directory</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ AUTH-USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ AUTH-SYS-001.md
‚îî‚îÄ‚îÄ payment/
    ‚îú‚îÄ‚îÄ PAYMENT-USR-001.md
    ‚îî‚îÄ‚îÄ PAYMENT-SYS-001.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Reinforces namespace structure</li>
<li>Easy to navigate</li>
</ul>
<p><strong>Disadvantage</strong>:</p>
<ul>
<li>Redundancy (namespace in filename and path)</li>
</ul>
<h3 id="option-2-namespace-without-matching-directory"><a class="header" href="#option-2-namespace-without-matching-directory">Option 2: Namespace Without Matching Directory</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ AUTH-USR-001.md
‚îú‚îÄ‚îÄ AUTH-SYS-001.md
‚îú‚îÄ‚îÄ PAYMENT-USR-001.md
‚îî‚îÄ‚îÄ PAYMENT-SYS-001.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simpler structure</li>
<li>No redundancy</li>
</ul>
<p><strong>Disadvantage</strong>:</p>
<ul>
<li>Large directories if many components</li>
</ul>
<h3 id="option-3-hybrid"><a class="header" href="#option-3-hybrid">Option 3: Hybrid</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ mobile/
‚îÇ   ‚îú‚îÄ‚îÄ MOBILE-AUTH-USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ MOBILE-PAY-USR-001.md
‚îî‚îÄ‚îÄ web/
    ‚îú‚îÄ‚îÄ WEB-AUTH-USR-001.md
    ‚îî‚îÄ‚îÄ WEB-PAY-USR-001.md
</code></pre>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Top level organized by directory</li>
<li>Sub-level by namespace</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="restricting-namespaces"><a class="header" href="#restricting-namespaces">Restricting Namespaces</a></h3>
<p>Currently, Requiem doesn't restrict namespaces via configuration. Any valid namespace is accepted.</p>
<p><strong>Workaround</strong>: Use <code>allowed_kinds</code> to restrict full namespaced kinds:</p>
<pre><code class="language-toml">_version = "1"
allowed_kinds = [
    "AUTH-USR",
    "AUTH-SYS",
    "PAYMENT-USR",
    "PAYMENT-SYS",
]
</code></pre>
<p>This allows:</p>
<ul>
<li><code>AUTH-USR-001</code> ‚úì</li>
<li><code>PAYMENT-SYS-001</code> ‚úì</li>
</ul>
<p>This blocks:</p>
<ul>
<li><code>INVALID-USR-001</code> ‚úó</li>
<li><code>USR-001</code> ‚úó (no namespace)</li>
</ul>
<p><strong>Limitation</strong>: Doesn't enforce namespace structure for multi-level namespaces.</p>
<h3 id="future-configuration"><a class="header" href="#future-configuration">Future Configuration</a></h3>
<p>Planned configuration options (not yet implemented):</p>
<pre><code class="language-toml"># Planned (not implemented)
[namespaces]
required = true          # Require all HRIDs to have namespaces
allowed = ["AUTH", "PAYMENT", "REPORTING"]
separator = "-"          # Customize separator (default: "-")
max_depth = 2            # Limit namespace depth
</code></pre>
<h2 id="migration-to-namespaces"><a class="header" href="#migration-to-namespaces">Migration to Namespaces</a></h2>
<h3 id="adding-namespaces-to-existing-project"><a class="header" href="#adding-namespaces-to-existing-project">Adding Namespaces to Existing Project</a></h3>
<p><strong>Challenge</strong>: Existing requirements lack namespaces:</p>
<pre><code>USR-001.md
USR-002.md
SYS-001.md
</code></pre>
<p><strong>Goal</strong>: Add namespaces:</p>
<pre><code>AUTH-USR-001.md
PAYMENT-USR-002.md
AUTH-SYS-001.md
</code></pre>
<p><strong>Steps</strong>:</p>
<ol>
<li>
<p><strong>Plan namespace scheme</strong>: Decide which requirements belong to which namespace</p>
</li>
<li>
<p><strong>Rename files</strong>:</p>
</li>
</ol>
<pre><code class="language-bash">mv USR-001.md AUTH-USR-001.md
mv USR-002.md PAYMENT-USR-002.md
mv SYS-001.md AUTH-SYS-001.md
</code></pre>
<ol start="3">
<li>
<p><strong>Update HRIDs in frontmatter</strong>: Edit each file to update the HRID references</p>
</li>
<li>
<p><strong>Fix parent links</strong>: Run <code>req clean</code> to correct parent HRIDs</p>
</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<ol start="5">
<li><strong>Verify</strong>:</li>
</ol>
<pre><code class="language-bash">req clean  # Should succeed with no errors
</code></pre>
<ol start="6">
<li><strong>Commit</strong>:</li>
</ol>
<pre><code class="language-bash">git add -A
git commit -m "Add namespaces to requirements"
</code></pre>
<p><strong>Note</strong>: UUIDs remain unchanged, so relationships are preserved.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="example-1-e-commerce-platform"><a class="header" href="#example-1-e-commerce-platform">Example 1: E-commerce Platform</a></h3>
<pre><code># Customer-facing requirements
CUSTOMER-USR-001.md  # Customer account management
CUSTOMER-USR-002.md  # Product browsing

# Cart and checkout
CART-USR-001.md      # Shopping cart
CHECKOUT-USR-001.md  # Checkout process

# Payment processing
PAYMENT-SYS-001.md   # Payment gateway integration
PAYMENT-SYS-002.md   # PCI compliance

# Order management
ORDER-SYS-001.md     # Order processing
ORDER-SYS-002.md     # Order fulfillment

# Inventory
INVENTORY-SYS-001.md # Stock management
</code></pre>
<h3 id="example-2-aerospace-system"><a class="header" href="#example-2-aerospace-system">Example 2: Aerospace System</a></h3>
<pre><code># Aircraft levels (DO-178C)
AIRCRAFT-URQT-001.md   # Aircraft-level user requirement

# System level
AVIONICS-SRQT-001.md   # Avionics system requirement
ENGINES-SRQT-001.md    # Engine system requirement

# Software level
AVIONICS-FCS-SWRQT-001.md   # Flight control software
AVIONICS-NAV-SWRQT-001.md   # Navigation software

# Hardware level
AVIONICS-FCS-HWRQT-001.md   # Flight control hardware
</code></pre>
<h3 id="example-3-mobile-and-web-apps"><a class="header" href="#example-3-mobile-and-web-apps">Example 3: Mobile and Web Apps</a></h3>
<pre><code># Shared requirements
CORE-USR-001.md         # Cross-platform user requirement
CORE-SYS-001.md         # Backend API

# Mobile-specific
MOBILE-IOS-USR-001.md   # iOS-specific requirement
MOBILE-ANDROID-USR-001.md  # Android-specific

# Web-specific
WEB-USR-001.md          # Web app requirement
WEB-ADMIN-USR-001.md    # Admin panel requirement
</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-design-namespace-scheme-early"><a class="header" href="#1-design-namespace-scheme-early">1. Design Namespace Scheme Early</a></h3>
<p>Define your namespace strategy before creating many requirements:</p>
<pre><code class="language-toml"># Document in config.toml comments
_version = "1"

# Namespace scheme:
# - AUTH: Authentication and authorization
# - PAYMENT: Payment processing
# - REPORTING: Report generation
# - ADMIN: Administration features

allowed_kinds = ["AUTH-USR", "AUTH-SYS", "PAYMENT-USR", "PAYMENT-SYS"]
</code></pre>
<h3 id="2-keep-namespaces-shallow"><a class="header" href="#2-keep-namespaces-shallow">2. Keep Namespaces Shallow</a></h3>
<p>Prefer 1-2 levels over 3+:</p>
<pre><code># Good
AUTH-USR-001

# Still good
MOBILE-AUTH-USR-001

# Getting long
COMPANY-PRODUCT-MOBILE-AUTH-USR-001
</code></pre>
<h3 id="3-document-namespace-meanings"><a class="header" href="#3-document-namespace-meanings">3. Document Namespace Meanings</a></h3>
<p>Create a README or documentation page:</p>
<pre><code class="language-markdown"># Namespace Guide

- **AUTH**: Authentication and authorization
- **PAYMENT**: Payment processing
- **REPORT**: Report generation
- **ADMIN**: Administration and configuration
</code></pre>
<h3 id="4-consistent-abbreviations"><a class="header" href="#4-consistent-abbreviations">4. Consistent Abbreviations</a></h3>
<p>Use consistent abbreviations across namespaces:</p>
<pre><code># Good (consistent)
AUTH-USR-001
AUTH-SYS-001
PAYMENT-USR-001
PAYMENT-SYS-001

# Inconsistent (avoid)
AUTH-USR-001
AUTHENTICATION-SYS-001
PAY-USR-001
PAYMENT_PROCESSING-SYS-001
</code></pre>
<h3 id="5-consider-future-growth"><a class="header" href="#5-consider-future-growth">5. Consider Future Growth</a></h3>
<p>Choose namespaces that won't become obsolete:</p>
<pre><code># Flexible
MOBILE-USR-001       # Can add MOBILE-IOS, MOBILE-ANDROID later

# Inflexible
IPHONE-USR-001       # What about iPads? Android?
</code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p><strong>Key Takeaways</strong>:</p>
<ol>
<li><strong>Optional</strong>: Namespaces are optional; use when beneficial</li>
<li><strong>Hierarchical</strong>: Support multiple levels (1-3 typical)</li>
<li><strong>Flexible</strong>: Choose strategy that fits your project</li>
<li><strong>Scalable</strong>: Essential for large, multi-component systems</li>
<li><strong>Format</strong>: <code>{NAMESPACE-}*{KIND}-{ID}</code></li>
</ol>
<p><strong>When to use</strong>:</p>
<ul>
<li>Large projects (&gt; 100 requirements)</li>
<li>Multi-component systems</li>
<li>Product families</li>
<li>Team boundaries</li>
<li>Acquisitions</li>
</ul>
<p><strong>When NOT to use</strong>:</p>
<ul>
<li>Small projects (&lt; 100 requirements)</li>
<li>Single-component systems</li>
<li>When simplicity is priority</li>
</ul>
<p><strong>Best practices</strong>:</p>
<ul>
<li>Design namespace scheme early</li>
<li>Keep shallow (1-2 levels)</li>
<li>Use descriptive, short names</li>
<li>Document namespace meanings</li>
<li>Consider future growth</li>
</ul>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li>Review <a href="configuration/./directory-structure.html">Directory Structure</a> for organizing namespaced requirements</li>
<li>Learn about <a href="configuration/../working-with-requirements/creating.html">Creating Requirements</a> with namespaces</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maintaining-requirements"><a class="header" href="#maintaining-requirements">Maintaining Requirements</a></h1>
<p>Requirements evolve throughout a project's lifecycle. This chapter covers maintenance tasks that keep your requirements accurate and consistent.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Requiem provides tools for:</p>
<ul>
<li><strong><a href="./maintaining/correcting-hrids.html">Correcting HRIDs</a></strong> - Fixing parent references after renaming requirements</li>
<li><strong><a href="./maintaining/fingerprints.html">Fingerprints and Change Detection</a></strong> - Understanding how Requiem tracks content changes</li>
<li><strong><a href="./maintaining/review-workflows.html">Review Workflows</a></strong> - Managing reviews when requirements change (planned feature)</li>
</ul>
<h2 id="common-maintenance-tasks"><a class="header" href="#common-maintenance-tasks">Common Maintenance Tasks</a></h2>
<h3 id="regular-cleanup"><a class="header" href="#regular-cleanup">Regular Cleanup</a></h3>
<p>Run <code>req clean</code> periodically to ensure consistency:</p>
<pre><code class="language-bash">req clean
</code></pre>
<p>This command:</p>
<ul>
<li>Loads all requirements</li>
<li>Validates frontmatter and format</li>
<li>Corrects parent HRIDs if requirements were renamed</li>
<li>Reports any errors or inconsistencies</li>
</ul>
<p><strong>Frequency</strong>: Run after major reorganizations or before releases.</p>
<h3 id="after-renaming-requirements"><a class="header" href="#after-renaming-requirements">After Renaming Requirements</a></h3>
<p>If you rename requirement files (change HRIDs):</p>
<ol>
<li>Rename the file:</li>
</ol>
<pre><code class="language-bash">mv USR-001.md USR-100.md
</code></pre>
<ol start="2">
<li>Update parent references:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<ol start="3">
<li>Verify changes:</li>
</ol>
<pre><code class="language-bash">git diff
</code></pre>
<p>The <code>clean</code> command updates all parent HRIDs automatically.</p>
<h3 id="after-editing-content"><a class="header" href="#after-editing-content">After Editing Content</a></h3>
<p>When requirement text changes:</p>
<ol>
<li>Edit the markdown body</li>
<li>Save the file</li>
<li>Commit with a descriptive message:</li>
</ol>
<pre><code class="language-bash">git add USR-001.md
git commit -m "Update USR-001: clarify email validation requirement"
</code></pre>
<p>The fingerprint updates automatically when content changes, enabling change detection.</p>
<h3 id="managing-requirements-at-scale"><a class="header" href="#managing-requirements-at-scale">Managing Requirements at Scale</a></h3>
<p>For projects with hundreds of requirements:</p>
<p><strong>Use scripts</strong>: Automate repetitive tasks</p>
<pre><code class="language-bash"># Example: Add a tag to all USR requirements
for file in USR-*.md; do
    # Add tag via sed or Python script
done
</code></pre>
<p><strong>Use version control</strong>: Track changes over time</p>
<pre><code class="language-bash"># See what requirements changed this sprint
git log --since="2 weeks ago" --name-only -- "*.md"
</code></pre>
<p><strong>Use traceability</strong>: Understand impact of changes</p>
<pre><code class="language-bash"># Find all children of a requirement
grep -r "uuid: &lt;parent-uuid&gt;" *.md
</code></pre>
<h2 id="maintenance-best-practices"><a class="header" href="#maintenance-best-practices">Maintenance Best Practices</a></h2>
<h3 id="1-validate-before-committing"><a class="header" href="#1-validate-before-committing">1. Validate Before Committing</a></h3>
<p>Always run <code>req clean</code> before committing changes:</p>
<pre><code class="language-bash">req clean &amp;&amp; git add -A &amp;&amp; git commit -m "Update requirements"
</code></pre>
<p>This catches errors before they enter the repository.</p>
<h3 id="2-use-descriptive-commit-messages"><a class="header" href="#2-use-descriptive-commit-messages">2. Use Descriptive Commit Messages</a></h3>
<p>Bad:</p>
<pre><code class="language-bash">git commit -m "Update reqs"
</code></pre>
<p>Good:</p>
<pre><code class="language-bash">git commit -m "Add USR-042: user data export requirement

Related to feature request #123. Establishes requirements
for CSV and JSON export formats."
</code></pre>
<h3 id="3-review-changes-carefully"><a class="header" href="#3-review-changes-carefully">3. Review Changes Carefully</a></h3>
<p>Before committing requirement changes, review diffs:</p>
<pre><code class="language-bash">git diff USR-001.md
</code></pre>
<p>Ensure:</p>
<ul>
<li>UUID hasn't changed (breaking traceability)</li>
<li>Metadata is valid</li>
<li>Content changes are intentional</li>
</ul>
<h3 id="4-keep-requirements-current"><a class="header" href="#4-keep-requirements-current">4. Keep Requirements Current</a></h3>
<p><strong>Regular reviews</strong>: Schedule periodic requirement reviews</p>
<p><strong>Update as needed</strong>: Don't let requirements become stale documentation</p>
<p><strong>Archive obsolete requirements</strong>: Move to <code>archived/</code> subdirectory rather than deleting</p>
<h3 id="5-document-maintenance-procedures"><a class="header" href="#5-document-maintenance-procedures">5. Document Maintenance Procedures</a></h3>
<p>Create a <code>CONTRIBUTING.md</code> or similar:</p>
<pre><code class="language-markdown"># Requirements Maintenance

## Before Committing
1. Run `req clean`
2. Review diffs carefully
3. Don't modify UUIDs manually

## Renaming Requirements
1. Rename file
2. Run `req clean` to update parent references
3. Commit changes

## Adding Tags
Use YAML syntax in frontmatter...
</code></pre>
<h2 id="tools-and-automation"><a class="header" href="#tools-and-automation">Tools and Automation</a></h2>
<h3 id="pre-commit-hooks"><a class="header" href="#pre-commit-hooks">Pre-commit Hooks</a></h3>
<p>Automate validation with Git hooks:</p>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

echo "Validating requirements..."
req clean

if [ $? -ne 0 ]; then
    echo "Error: Requirements validation failed"
    exit 1
fi
</code></pre>
<h3 id="cicd-integration-1"><a class="header" href="#cicd-integration-1">CI/CD Integration</a></h3>
<p>Add requirement validation to CI:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml
name: Validate Requirements

on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Requiem
        run: cargo install requirements-manager
      - name: Validate requirements
        run: req clean
        working-directory: ./requirements
</code></pre>
<h3 id="scripts-for-common-tasks"><a class="header" href="#scripts-for-common-tasks">Scripts for Common Tasks</a></h3>
<p><strong>Find requirements without tests</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# List USR requirements not linked by any TST requirement
comm -23 \
  &lt;(ls USR-*.md | sed 's/.md//' | sort) \
  &lt;(grep -oh "USR-[0-9]*" TST-*.md | sort -u)
</code></pre>
<p><strong>Generate traceability report</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# Show parent-child relationships
for file in *.md; do
    hrid=$(basename "$file" .md)
    parents=$(grep "hrid:" "$file" | awk '{print $2}')
    if [ -n "$parents" ]; then
        echo "$hrid -&gt; $parents"
    fi
done
</code></pre>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<h3 id="corrupted-frontmatter"><a class="header" href="#corrupted-frontmatter">Corrupted Frontmatter</a></h3>
<p>If YAML becomes invalid:</p>
<ol>
<li>Check syntax:</li>
</ol>
<pre><code class="language-bash">req clean  # Reports specific error
</code></pre>
<ol start="2">
<li>Fix manually or restore from Git:</li>
</ol>
<pre><code class="language-bash">git checkout HEAD -- USR-001.md
</code></pre>
<ol start="3">
<li>Use online YAML validator if needed</li>
</ol>
<h3 id="duplicate-uuids"><a class="header" href="#duplicate-uuids">Duplicate UUIDs</a></h3>
<p>If two requirements have the same UUID (serious error):</p>
<ol>
<li>Requiem will panic with error message</li>
<li>Identify files with duplicate UUIDs</li>
<li>Manually assign new UUID to one:</li>
</ol>
<pre><code class="language-bash">uuidgen  # Generate new UUID
# Edit file, replace UUID
</code></pre>
<ol start="4">
<li>Verify:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<h3 id="missing-parents"><a class="header" href="#missing-parents">Missing Parents</a></h3>
<p>If a parent requirement is deleted but children still reference it:</p>
<ol>
<li>Requiem reports error during <code>req clean</code></li>
<li>Options:
<ul>
<li>Restore deleted parent</li>
<li>Remove parent reference from child</li>
<li>Link child to different parent</li>
</ul>
</li>
</ol>
<h3 id="merge-conflicts"><a class="header" href="#merge-conflicts">Merge Conflicts</a></h3>
<p>When merging Git branches with requirement changes:</p>
<ol>
<li>
<p>Resolve conflicts in frontmatter carefully:</p>
<ul>
<li>UUIDs should never conflict (unique per requirement)</li>
<li>Timestamps: keep newer</li>
<li>Parents: merge both sets if both added parents</li>
</ul>
</li>
<li>
<p>Resolve markdown body conflicts normally</p>
</li>
<li>
<p>After resolving:</p>
</li>
</ol>
<pre><code class="language-bash">req clean  # Validate merged result
</code></pre>
<h2 id="monitoring-and-reporting"><a class="header" href="#monitoring-and-reporting">Monitoring and Reporting</a></h2>
<h3 id="requirement-statistics"><a class="header" href="#requirement-statistics">Requirement Statistics</a></h3>
<p>Count requirements by kind:</p>
<pre><code class="language-bash">ls USR-*.md | wc -l  # User requirements
ls SYS-*.md | wc -l  # System requirements
</code></pre>
<h3 id="change-tracking"><a class="header" href="#change-tracking">Change Tracking</a></h3>
<p>Requirements changed in last month:</p>
<pre><code class="language-bash">git log --since="1 month ago" --name-only --pretty=format: -- "*.md" | \
  sort -u | grep -E "^[A-Z]+-[0-9]+\.md$"
</code></pre>
<h3 id="coverage-analysis"><a class="header" href="#coverage-analysis">Coverage Analysis</a></h3>
<p>Find requirements without children (potential gaps):</p>
<pre><code class="language-bash"># Find USR requirements not referenced by any SYS requirement
comm -23 \
  &lt;(ls USR-*.md | sed 's/.md//' | sort) \
  &lt;(grep -roh "USR-[0-9]*" SYS-*.md | sort -u)
</code></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<p>Dive deeper into specific maintenance topics:</p>
<ul>
<li><strong><a href="./maintaining/correcting-hrids.html">Correcting HRIDs</a></strong> - Using the <code>req clean</code> command</li>
<li><strong><a href="./maintaining/fingerprints.html">Fingerprints</a></strong> - How change detection works</li>
<li><strong><a href="./maintaining/review-workflows.html">Review Workflows</a></strong> - Managing reviews (planned)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correcting-hrids-1"><a class="header" href="#correcting-hrids-1">Correcting HRIDs</a></h1>
<p>The <code>req clean</code> command corrects outdated parent HRIDs in requirement files. This chapter explains when and how to use it.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Requirements reference their parents using HRIDs for human readability:</p>
<pre><code class="language-yaml">parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001  # Human-readable reference
</code></pre>
<p>If you rename the parent file (<code>USR-001.md</code> ‚Üí <code>USR-100.md</code>), the HRID in child requirements becomes outdated:</p>
<pre><code class="language-yaml"># Child still says:
parents:
- hrid: USR-001  # Wrong! File is now USR-100.md
</code></pre>
<p>The UUID remains correct (traceability is preserved), but the HRID shown to humans is misleading.</p>
<h2 id="the-solution-req-clean"><a class="header" href="#the-solution-req-clean">The Solution: <code>req clean</code></a></h2>
<p>The <code>req clean</code> command:</p>
<ol>
<li>Loads all requirements</li>
<li>For each requirement, checks parent HRIDs against actual parent files</li>
<li>Corrects any mismatches</li>
<li>Saves updated requirements</li>
</ol>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><code class="language-bash">req clean
</code></pre>
<p>Run in your requirements directory. No output means success (all HRIDs were correct or have been fixed).</p>
<h3 id="with-custom-root"><a class="header" href="#with-custom-root">With Custom Root</a></h3>
<pre><code class="language-bash">req --root /path/to/requirements clean
</code></pre>
<p>Specify a different requirements directory.</p>
<h3 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h3>
<pre><code class="language-bash">req -v clean
</code></pre>
<p>Shows what's being corrected:</p>
<pre><code>INFO Corrected parent HRID in SYS-001: USR-001 ‚Üí USR-100
INFO Corrected parent HRID in SYS-002: USR-001 ‚Üí USR-100
</code></pre>
<h2 id="when-to-run-req-clean"><a class="header" href="#when-to-run-req-clean">When to Run <code>req clean</code></a></h2>
<h3 id="after-renaming-requirements-1"><a class="header" href="#after-renaming-requirements-1">After Renaming Requirements</a></h3>
<p><strong>Scenario</strong>: You renamed a requirement file.</p>
<p><strong>Steps</strong>:</p>
<ol>
<li>Rename the file:</li>
</ol>
<pre><code class="language-bash">mv USR-001.md USR-100.md
</code></pre>
<ol start="2">
<li>Correct parent references:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<ol start="3">
<li>Verify changes:</li>
</ol>
<pre><code class="language-bash">git diff
</code></pre>
<p>You'll see parent HRIDs updated in child requirements.</p>
<h3 id="after-reorganization"><a class="header" href="#after-reorganization">After Reorganization</a></h3>
<p><strong>Scenario</strong>: Major restructuring with many renamed files.</p>
<p><strong>Steps</strong>:</p>
<ol>
<li>Perform renames:</li>
</ol>
<pre><code class="language-bash">mv USR-001.md AUTH-USR-001.md
mv USR-002.md PAYMENT-USR-002.md
# ... many more
</code></pre>
<ol start="2">
<li>Fix all references at once:</li>
</ol>
<pre><code class="language-bash">req clean
</code></pre>
<ol start="3">
<li>Verify:</li>
</ol>
<pre><code class="language-bash">git status    # See all modified files
git diff      # Review changes
</code></pre>
<h3 id="before-committing"><a class="header" href="#before-committing">Before Committing</a></h3>
<p><strong>Best practice</strong>: Run <code>req clean</code> before every commit involving requirement changes.</p>
<pre><code class="language-bash">req clean &amp;&amp; git add -A &amp;&amp; git commit -m "Reorganize requirements"
</code></pre>
<p>This ensures the repository always has correct HRIDs.</p>
<h3 id="regular-maintenance"><a class="header" href="#regular-maintenance">Regular Maintenance</a></h3>
<p><strong>Frequency</strong>: Run periodically (e.g., before releases) to catch any drift.</p>
<pre><code class="language-bash">req clean
</code></pre>
<p>If requirements are managed carefully, this should show no changes.</p>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h2>
<h3 id="step-1-load-all-requirements"><a class="header" href="#step-1-load-all-requirements">Step 1: Load All Requirements</a></h3>
<p>Requiem scans the requirements directory recursively, loading all <code>.md</code> files with valid HRID names.</p>
<h3 id="step-2-build-index"><a class="header" href="#step-2-build-index">Step 2: Build Index</a></h3>
<p>Creates a UUID-to-requirement mapping:</p>
<pre><code>UUID 4bfeb7d5-... ‚Üí USR-100 (actual current HRID)
UUID 3fc6800c-... ‚Üí SYS-001
...
</code></pre>
<h3 id="step-3-check-each-parent-reference"><a class="header" href="#step-3-check-each-parent-reference">Step 3: Check Each Parent Reference</a></h3>
<p>For each requirement, examines parent references:</p>
<pre><code class="language-yaml"># Child requirement SYS-001.md
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  hrid: USR-001  # Check if this matches actual HRID for this UUID
</code></pre>
<h3 id="step-4-correct-mismatches"><a class="header" href="#step-4-correct-mismatches">Step 4: Correct Mismatches</a></h3>
<p>If the HRID doesn't match:</p>
<ul>
<li>Look up the UUID in the index</li>
<li>Find the actual current HRID</li>
<li>Update the parent reference</li>
<li>Save the requirement file</li>
</ul>
<h3 id="step-5-report-results"><a class="header" href="#step-5-report-results">Step 5: Report Results</a></h3>
<p>With verbose logging (<code>-v</code>), reports each correction. Otherwise, silent success.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="example-1-simple-rename"><a class="header" href="#example-1-simple-rename">Example 1: Simple Rename</a></h3>
<p><strong>Before</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ SYS-001.md
</code></pre>
<p><code>SYS-001.md</code> links to <code>USR-001</code>:</p>
<pre><code class="language-yaml"># SYS-001.md
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  hrid: USR-001
</code></pre>
<p><strong>Rename parent</strong>:</p>
<pre><code class="language-bash">mv USR-001.md USR-100.md
</code></pre>
<p><strong>Run clean</strong>:</p>
<pre><code class="language-bash">req clean
</code></pre>
<p><strong>After</strong>:</p>
<p><code>SYS-001.md</code> now shows correct HRID:</p>
<pre><code class="language-yaml"># SYS-001.md
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  hrid: USR-100  # Corrected!
</code></pre>
<h3 id="example-2-multiple-children"><a class="header" href="#example-2-multiple-children">Example 2: Multiple Children</a></h3>
<p><strong>Scenario</strong>: One parent with multiple children.</p>
<p><strong>Before</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ SYS-001.md  (parent: USR-001)
‚îú‚îÄ‚îÄ SYS-002.md  (parent: USR-001)
‚îî‚îÄ‚îÄ SYS-003.md  (parent: USR-001)
</code></pre>
<p><strong>Rename parent</strong>:</p>
<pre><code class="language-bash">mv USR-001.md USR-050.md
</code></pre>
<p><strong>Run clean</strong>:</p>
<pre><code class="language-bash">req -v clean
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>INFO Corrected parent HRID in SYS-001: USR-001 ‚Üí USR-050
INFO Corrected parent HRID in SYS-002: USR-001 ‚Üí USR-050
INFO Corrected parent HRID in SYS-003: USR-001 ‚Üí USR-050
</code></pre>
<p>All three children are updated in one command.</p>
<h3 id="example-3-adding-namespaces"><a class="header" href="#example-3-adding-namespaces">Example 3: Adding Namespaces</a></h3>
<p><strong>Scenario</strong>: Migrating to namespaced HRIDs.</p>
<p><strong>Before</strong>:</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ SYS-001.md  (parent: USR-001)
‚îî‚îÄ‚îÄ SYS-002.md  (parent: USR-002)
</code></pre>
<p><strong>Rename with namespaces</strong>:</p>
<pre><code class="language-bash">mv USR-001.md AUTH-USR-001.md
mv USR-002.md PAYMENT-USR-002.md
mv SYS-001.md AUTH-SYS-001.md
mv SYS-002.md PAYMENT-SYS-002.md
</code></pre>
<p><strong>Run clean</strong>:</p>
<pre><code class="language-bash">req clean
</code></pre>
<p><strong>Result</strong>: All parent references updated to namespaced HRIDs.</p>
<h2 id="edge-cases"><a class="header" href="#edge-cases">Edge Cases</a></h2>
<h3 id="requirement-not-found"><a class="header" href="#requirement-not-found">Requirement Not Found</a></h3>
<p><strong>Scenario</strong>: Child references a parent UUID that doesn't exist.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml"># SYS-001.md
parents:
- uuid: 00000000-0000-0000-0000-000000000000  # No requirement with this UUID
  hrid: USR-999
</code></pre>
<p><strong>Behavior</strong>: <code>req clean</code> panics with error message:</p>
<pre><code>Error: Parent requirement 00000000-0000-0000-0000-000000000000 not found!
</code></pre>
<p><strong>Resolution</strong>:</p>
<ul>
<li>Restore the missing parent requirement, or</li>
<li>Manually remove the invalid parent reference from the child</li>
</ul>
<h3 id="self-referential-parent"><a class="header" href="#self-referential-parent">Self-Referential Parent</a></h3>
<p><strong>Scenario</strong>: Requirement lists itself as a parent (should never happen).</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml"># SYS-001.md
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a  # Same as own UUID!
  hrid: SYS-001
</code></pre>
<p><strong>Behavior</strong>: <code>req clean</code> panics with error message:</p>
<pre><code>Error: Requirement 4bfeb7d5-... is its own parent!
</code></pre>
<p><strong>Resolution</strong>: Manually remove the self-reference from the frontmatter.</p>
<h3 id="circular-dependencies-1"><a class="header" href="#circular-dependencies-1">Circular Dependencies</a></h3>
<p><strong>Scenario</strong>: Requirement A depends on B, B depends on C, C depends on A.</p>
<p><strong>Current behavior</strong>: <code>req clean</code> doesn't detect cycles (cycle detection is planned but not implemented).</p>
<p><strong>Impact</strong>: HRIDs will be corrected, but the circular dependency remains undetected.</p>
<p><strong>Workaround</strong>: Manually audit requirement relationships or use external tools.</p>
<h2 id="integration-with-workflows"><a class="header" href="#integration-with-workflows">Integration with Workflows</a></h2>
<h3 id="pre-commit-hook"><a class="header" href="#pre-commit-hook">Pre-commit Hook</a></h3>
<p>Automatically correct HRIDs before every commit:</p>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

echo "Correcting requirement HRIDs..."
req clean

if [ $? -ne 0 ]; then
    echo "Error: Failed to correct HRIDs"
    exit 1
fi

# Stage any changes made by req clean
git add -u
</code></pre>
<p><strong>Benefit</strong>: Never commit incorrect HRIDs.</p>
<p><strong>Caution</strong>: Automatically stages changes. Review carefully.</p>
<h3 id="ci-pipeline"><a class="header" href="#ci-pipeline">CI Pipeline</a></h3>
<p>Validate HRIDs in CI:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml
- name: Validate HRIDs
  run: |
    req clean
    if [ -n "$(git status --porcelain)" ]; then
      echo "Error: HRIDs are out of sync"
      git diff
      exit 1
    fi
</code></pre>
<p><strong>Benefit</strong>: Catches incorrect HRIDs before merging.</p>
<h3 id="manual-review-workflow"><a class="header" href="#manual-review-workflow">Manual Review Workflow</a></h3>
<p>For critical projects, manually review HRID corrections:</p>
<pre><code class="language-bash"># Run clean
req clean

# Review changes
git diff

# If acceptable, commit
git add -A
git commit -m "Correct parent HRIDs after reorganization"
</code></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p><code>req clean</code> loads all requirements in parallel, making it fast even for large projects:</p>
<ul>
<li><strong>100 requirements</strong>: &lt; 1 second</li>
<li><strong>1000 requirements</strong>: ~2-3 seconds</li>
<li><strong>10000 requirements</strong>: ~15-20 seconds</li>
</ul>
<p><strong>Scales well</strong> due to Rust's performance and parallel processing.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="no-dry-run-mode"><a class="header" href="#no-dry-run-mode">No Dry-Run Mode</a></h3>
<p>Currently, <code>req clean</code> modifies files immediately. There's no preview mode.</p>
<p><strong>Workaround</strong>: Use Git to preview changes:</p>
<pre><code class="language-bash">req clean         # Make changes
git diff          # Preview
git checkout -- . # Undo if needed (before committing)
</code></pre>
<h3 id="no-selective-correction"><a class="header" href="#no-selective-correction">No Selective Correction</a></h3>
<p>Can't correct only specific requirements; it's all-or-nothing.</p>
<p><strong>Workaround</strong>: Use Git to selectively stage changes:</p>
<pre><code class="language-bash">req clean
git add SYS-001.md SYS-002.md  # Stage only specific files
</code></pre>
<h3 id="requires-all-parents-present"><a class="header" href="#requires-all-parents-present">Requires All Parents Present</a></h3>
<p>If a parent requirement is missing, <code>req clean</code> fails. Can't correct partial sets.</p>
<p><strong>Workaround</strong>: Ensure all requirements are present, or manually fix references.</p>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-run-before-committing"><a class="header" href="#1-run-before-committing">1. Run Before Committing</a></h3>
<pre><code class="language-bash">req clean &amp;&amp; git add -A &amp;&amp; git commit
</code></pre>
<p>Make it a habit.</p>
<h3 id="2-review-changes"><a class="header" href="#2-review-changes">2. Review Changes</a></h3>
<p>Always review what <code>req clean</code> changed:</p>
<pre><code class="language-bash">req clean
git diff  # See what was corrected
</code></pre>
<h3 id="3-use-verbose-mode-for-learning"><a class="header" href="#3-use-verbose-mode-for-learning">3. Use Verbose Mode for Learning</a></h3>
<p>When first using <code>req clean</code>, run with <code>-v</code> to understand what it's doing:</p>
<pre><code class="language-bash">req -v clean
</code></pre>
<h3 id="4-combine-with-validation"><a class="header" href="#4-combine-with-validation">4. Combine with Validation</a></h3>
<p>Use <code>req clean</code> as a validation step:</p>
<pre><code class="language-bash">req clean
if [ $? -eq 0 ]; then
    echo "Requirements are consistent"
else
    echo "Errors found"
fi
</code></pre>
<h3 id="5-document-in-team-processes"><a class="header" href="#5-document-in-team-processes">5. Document in Team Processes</a></h3>
<p>Include in your team's documentation:</p>
<pre><code class="language-markdown">## Renaming Requirements

1. Rename the file
2. Run `req clean`
3. Review changes with `git diff`
4. Commit
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<p><strong>Error</strong>: <code>req: command not found</code></p>
<p><strong>Solution</strong>: Install Requiem:</p>
<pre><code class="language-bash">cargo install requirements-manager
</code></pre>
<h3 id="permission-denied"><a class="header" href="#permission-denied">Permission Denied</a></h3>
<p><strong>Error</strong>: <code>Error: Permission denied</code></p>
<p><strong>Solution</strong>: Ensure you have write permissions to requirement files.</p>
<h3 id="configuration-parse-error"><a class="header" href="#configuration-parse-error">Configuration Parse Error</a></h3>
<p><strong>Error</strong>: <code>Error: Failed to parse config file</code></p>
<p><strong>Solution</strong>: Check <code>config.toml</code> syntax. Remove or fix if invalid.</p>
<h3 id="unexpected-changes"><a class="header" href="#unexpected-changes">Unexpected Changes</a></h3>
<p><strong>Issue</strong>: <code>req clean</code> makes unexpected modifications.</p>
<p><strong>Diagnosis</strong>:</p>
<ol>
<li>Run with verbose: <code>req -v clean</code></li>
<li>Examine which HRIDs are being corrected</li>
<li>Check if requirement files were renamed</li>
</ol>
<p><strong>Resolution</strong>: Review changes with <code>git diff</code>. Revert if incorrect.</p>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p><strong>Key points</strong>:</p>
<ul>
<li><strong>Purpose</strong>: Correct outdated parent HRIDs after renaming requirements</li>
<li><strong>Usage</strong>: <code>req clean</code> in requirements directory</li>
<li><strong>When</strong>: After renaming files, before committing, regular maintenance</li>
<li><strong>How</strong>: Loads all requirements, checks parent HRIDs, corrects mismatches</li>
<li><strong>Safe</strong>: Uses UUIDs for correctness; HRIDs are display-only</li>
</ul>
<p><strong>Best practice</strong>: Run <code>req clean</code> before every commit involving requirements.</p>
<p><strong>Limitation</strong>: No dry-run or selective correction (yet).</p>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li>Learn about <a href="maintaining/./fingerprints.html">Fingerprints</a> for change detection</li>
<li>Understand <a href="maintaining/./review-workflows.html">Review Workflows</a> (planned feature)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fingerprints-and-change-detection"><a class="header" href="#fingerprints-and-change-detection">Fingerprints and Change Detection</a></h1>
<p>Requiem uses content fingerprints to detect when requirements change. This chapter explains how fingerprints work and enable change management.</p>
<h2 id="what-is-a-fingerprint"><a class="header" href="#what-is-a-fingerprint">What is a Fingerprint?</a></h2>
<p>A fingerprint is a cryptographic hash (SHA256) of a requirement's semantic content. It's stored in parent references:</p>
<pre><code class="language-yaml"># SYS-001.md
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
</code></pre>
<p>The fingerprint represents the state of <code>USR-001</code> when <code>SYS-001</code> was last reviewed or updated.</p>
<h2 id="how-fingerprints-work"><a class="header" href="#how-fingerprints-work">How Fingerprints Work</a></h2>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<p>When you link a child to a parent:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
</code></pre>
<p>Requiem:</p>
<ol>
<li>Computes the fingerprint of <code>USR-001</code>'s content</li>
<li>Stores it in <code>SYS-001</code>'s parent reference</li>
</ol>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>Fingerprints update in two scenarios:</p>
<p><strong>1. When creating the link</strong>:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
# Fingerprint captured at link time
</code></pre>
<p><strong>2. When the parent's content changes</strong>:</p>
<ul>
<li>The parent's fingerprint is recomputed automatically</li>
<li>Child references keep the OLD fingerprint</li>
<li>This creates a mismatch, indicating the child may need review</li>
</ul>
<h3 id="whats-included-in-the-fingerprint"><a class="header" href="#whats-included-in-the-fingerprint">What's Included in the Fingerprint</a></h3>
<p>Fingerprints hash:</p>
<ul>
<li>‚úì <strong>Markdown body</strong>: The requirement text</li>
<li>‚úì <strong>Tags</strong>: Any tags in the frontmatter</li>
</ul>
<p>Fingerprints <strong>do NOT</strong> include:</p>
<ul>
<li>‚úó HRID (just a label)</li>
<li>‚úó UUID (stable identifier, not content)</li>
<li>‚úó Created timestamp (metadata, not content)</li>
<li>‚úó Parent relationships (separate from content)</li>
</ul>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p><strong>Requirement USR-001</strong>:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
tags:
- authentication
- security
---

The system shall validate user email addresses according to RFC 5322.
</code></pre>
<p><strong>Fingerprint computation</strong>:</p>
<pre><code>Content: "The system shall validate user email addresses according to RFC 5322."
Tags: ["authentication", "security"]
‚Üí Encode with Borsh
‚Üí Hash with SHA256
‚Üí Fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
</code></pre>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h3>
<p><strong>Problem</strong>: A parent requirement changes. Which child requirements are affected?</p>
<p><strong>Solution</strong>: Compare fingerprints.</p>
<p><strong>Example</strong>:</p>
<ol>
<li>Initial state:</li>
</ol>
<pre><code class="language-yaml"># SYS-001.md links to USR-001
parents:
- uuid: 4bfeb7d5-...
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
  hrid: USR-001
</code></pre>
<ol start="2">
<li>Someone edits <code>USR-001</code>:</li>
</ol>
<pre><code class="language-markdown"># USR-001.md
The system shall validate user email addresses according to RFC 5322.
Email validation must occur before account creation.  # ‚Üê New sentence
</code></pre>
<ol start="3">
<li>USR-001's fingerprint changes:</li>
</ol>
<pre><code>New fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
</code></pre>
<ol start="4">
<li>SYS-001 still has the old fingerprint:</li>
</ol>
<pre><code class="language-yaml"># SYS-001.md
parents:
- fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda  # Old!
</code></pre>
<ol start="5">
<li><strong>Mismatch detected</strong>: SYS-001 needs review because its parent changed.</li>
</ol>
<h3 id="impact-analysis"><a class="header" href="#impact-analysis">Impact Analysis</a></h3>
<p><strong>Question</strong>: If I change this requirement, what else is affected?</p>
<p><strong>Answer</strong>: Use the <code>req suspect</code> command after making changes to find affected children.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># 1. Edit a parent requirement
vim USR-001.md  # Make your changes

# 2. Check for suspect links
req suspect
# Output shows all affected children:
#   SYS-001 ‚Üí USR-001
#   SYS-002 ‚Üí USR-001
#   ... (fingerprint mismatches)

# 3. Review each affected child
vim SYS-001.md
vim SYS-002.md

# 4. Accept fingerprints after review
req accept SYS-001 USR-001
req accept SYS-002 USR-001

# Or accept all at once
req accept --all
</code></pre>
<p><strong>Manual process</strong> (if needed):</p>
<pre><code class="language-bash"># 1. Get UUID of the requirement you're changing
grep "uuid:" USR-001.md

# 2. Find all requirements that reference this UUID
grep -r "uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a" *.md

# 3. Those requirements may need review after your change
</code></pre>
<h3 id="review-tracking"><a class="header" href="#review-tracking">Review Tracking</a></h3>
<p><strong>Goal</strong>: Track which requirements need review after upstream changes.</p>
<p><strong>Current state</strong>: Basic suspect link detection implemented via <code>req suspect</code> and <code>req accept</code> commands.</p>
<p><strong>Available now</strong>:</p>
<ul>
<li>Detect fingerprint mismatches with <code>req suspect</code></li>
<li>Accept individual links with <code>req accept &lt;child&gt; &lt;parent&gt;</code></li>
<li>Accept all suspect links with <code>req accept --all</code></li>
<li>CI/CD integration via exit codes</li>
</ul>
<p><strong>Future</strong>: Advanced review workflows with status tracking and assignments (planned feature).</p>
<h2 id="computing-fingerprints"><a class="header" href="#computing-fingerprints">Computing Fingerprints</a></h2>
<h3 id="viewing-a-requirements-fingerprint"><a class="header" href="#viewing-a-requirements-fingerprint">Viewing a Requirement's Fingerprint</a></h3>
<p>No built-in command yet, but you can compute it manually:</p>
<p><strong>Option 1: Link to a temporary requirement</strong></p>
<pre><code class="language-bash"># Create temp requirement
req add TEMP
# Link to target
req link TEMP-001 USR-001
# View fingerprint in TEMP-001.md
grep "fingerprint:" TEMP-001.md
# Clean up
rm TEMP-001.md
</code></pre>
<p><strong>Option 2: Use Rust/Python script</strong></p>
<p>Not currently exposed via CLI. Requires custom scripting.</p>
<h3 id="comparing-fingerprints"><a class="header" href="#comparing-fingerprints">Comparing Fingerprints</a></h3>
<p><strong>Problem</strong>: Is my child requirement's parent reference current?</p>
<p><strong>Solution</strong>: Use the <code>req suspect</code> command:</p>
<pre><code class="language-bash">req suspect
</code></pre>
<p>This automatically:</p>
<ol>
<li>Loads all requirements</li>
<li>Compares stored parent fingerprints with current parent fingerprints</li>
<li>Lists all mismatched fingerprints (suspect links)</li>
</ol>
<p><strong>Example output</strong>:</p>
<pre><code>Found 2 suspect link(s):

  SYS-001 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-002 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9
</code></pre>
<p>If no suspect links exist:</p>
<pre><code>No suspect links found.
</code></pre>
<p><strong>Exit codes</strong>:</p>
<ul>
<li><code>0</code>: All fingerprints current</li>
<li><code>1</code>: Suspect links found (useful for CI/CD)</li>
</ul>
<p><strong>Manual process</strong> (if needed):</p>
<ol>
<li>Find parent UUID and stored fingerprint in child:</li>
</ol>
<pre><code class="language-yaml"># SYS-001.md
parents:
- uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
  fingerprint: e533784ff58c16cbf08e436cb06f09e0076880fd707baaf55aa0f45dc4a6ccda
</code></pre>
<ol start="2">
<li>
<p>Compute current fingerprint of parent (see above)</p>
</li>
<li>
<p>Compare:</p>
<ul>
<li>Match: Child is current</li>
<li>Mismatch: Child needs review</li>
</ul>
</li>
</ol>
<h2 id="what-changes-affect-fingerprints"><a class="header" href="#what-changes-affect-fingerprints">What Changes Affect Fingerprints</a></h2>
<h3 id="changes-that-update-fingerprints"><a class="header" href="#changes-that-update-fingerprints">Changes that Update Fingerprints</a></h3>
<p><strong>Editing requirement text</strong>:</p>
<pre><code class="language-markdown"># Before
The system shall validate emails.

# After
The system shall validate emails according to RFC 5322.
</code></pre>
<p>‚Üí Fingerprint changes</p>
<p><strong>Adding/removing tags</strong>:</p>
<pre><code class="language-yaml"># Before
tags:
- authentication

# After
tags:
- authentication
- security
</code></pre>
<p>‚Üí Fingerprint changes</p>
<p><strong>Modifying tags</strong>:</p>
<pre><code class="language-yaml"># Before
tags:
- high-priority

# After
tags:
- medium-priority
</code></pre>
<p>‚Üí Fingerprint changes</p>
<p><strong>Whitespace changes in content</strong>:</p>
<pre><code class="language-markdown"># Before
The system shall validate emails.

# After
The system shall validate emails.

</code></pre>
<p>‚Üí Fingerprint changes (trailing whitespace added)</p>
<h3 id="changes-that-dont-affect-fingerprints"><a class="header" href="#changes-that-dont-affect-fingerprints">Changes that DON'T Affect Fingerprints</a></h3>
<p><strong>Renaming the requirement</strong>:</p>
<pre><code class="language-bash">mv USR-001.md USR-100.md
</code></pre>
<p>‚Üí Fingerprint unchanged (HRID is not part of content)</p>
<p><strong>Changing UUID</strong> (don't do this!):</p>
<pre><code class="language-yaml"># Before
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a

# After
uuid: 00000000-0000-0000-0000-000000000000
</code></pre>
<p>‚Üí Fingerprint unchanged (but breaks traceability!)</p>
<p><strong>Changing created timestamp</strong>:</p>
<pre><code class="language-yaml"># Before
created: 2025-07-22T12:19:56Z

# After
created: 2025-08-01T10:00:00Z
</code></pre>
<p>‚Üí Fingerprint unchanged</p>
<p><strong>Adding/removing parents</strong>:</p>
<pre><code class="language-yaml"># Before
parents:
- uuid: ...

# After
parents:
- uuid: ...
- uuid: ...  # Added parent
</code></pre>
<p>‚Üí Fingerprint unchanged</p>
<h2 id="fingerprint-algorithms"><a class="header" href="#fingerprint-algorithms">Fingerprint Algorithms</a></h2>
<h3 id="current-algorithm"><a class="header" href="#current-algorithm">Current Algorithm</a></h3>
<p><strong>Encoding</strong>: Borsh (Binary Object Representation Serializer for Hashing)</p>
<ul>
<li>Deterministic serialization</li>
<li>Consistent across platforms</li>
<li>Efficient for hashing</li>
</ul>
<p><strong>Hashing</strong>: SHA256</p>
<ul>
<li>Cryptographically secure</li>
<li>256-bit output (64 hex characters)</li>
<li>Collision resistant</li>
</ul>
<p><strong>Process</strong>:</p>
<pre><code>1. Collect content and tags
2. Serialize with Borsh: content + tags ‚Üí binary
3. Hash with SHA256: binary ‚Üí 256-bit hash
4. Encode as hex: hash ‚Üí 64-character string
</code></pre>
<h3 id="why-these-choices"><a class="header" href="#why-these-choices">Why These Choices?</a></h3>
<p><strong>Borsh</strong>:</p>
<ul>
<li>Stable encoding (no ambiguity)</li>
<li>Handles strings and collections consistently</li>
<li>Designed for hashing use cases</li>
</ul>
<p><strong>SHA256</strong>:</p>
<ul>
<li>Industry standard</li>
<li>Strong collision resistance</li>
<li>Fast to compute</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Consistent fingerprints across systems</li>
<li>Detects even small changes</li>
<li>Impossible to forge (cryptographically secure)</li>
</ul>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="example-1-detecting-stale-references"><a class="header" href="#example-1-detecting-stale-references">Example 1: Detecting Stale References</a></h3>
<p><strong>Scenario</strong>: USR-001 was updated 2 months ago. Are any child requirements out of date?</p>
<p><strong>Process</strong>:</p>
<pre><code class="language-bash"># Check for suspect links
req suspect
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Found 1 suspect link(s):

  SYS-001 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9
</code></pre>
<p><strong>Result</strong>: SYS-001 has a stale fingerprint and needs review.</p>
<p><strong>Next steps</strong>:</p>
<pre><code class="language-bash"># Review changes
vim USR-001.md  # See what changed
vim SYS-001.md  # Update if needed

# Accept the link
req accept SYS-001 USR-001

# Verify clean
req suspect
# Output: No suspect links found.
</code></pre>
<h3 id="example-2-tag-changes"><a class="header" href="#example-2-tag-changes">Example 2: Tag Changes</a></h3>
<p><strong>Scenario</strong>: Add a tag to a requirement.</p>
<p><strong>Before</strong>:</p>
<pre><code class="language-yaml"># USR-001.md
tags:
- authentication
</code></pre>
<p>Fingerprint: <code>e533784f...</code></p>
<p><strong>After</strong>:</p>
<pre><code class="language-yaml"># USR-001.md
tags:
- authentication
- security
</code></pre>
<p>Fingerprint: <code>c4020419...</code> (changed!)</p>
<p><strong>Impact</strong>: Any child requirements now have stale fingerprints.</p>
<h3 id="example-3-whitespace-only-changes"><a class="header" href="#example-3-whitespace-only-changes">Example 3: Whitespace-Only Changes</a></h3>
<p><strong>Scenario</strong>: Reformatting requirement text.</p>
<p><strong>Before</strong>:</p>
<pre><code class="language-markdown">The system shall validate emails.
</code></pre>
<p><strong>After</strong>:</p>
<pre><code class="language-markdown">The system shall validate emails.

</code></pre>
<p>(Added blank line)</p>
<p><strong>Result</strong>: Fingerprint changes!</p>
<p><strong>Caution</strong>: Even whitespace affects fingerprints. Be mindful of formatting changes.</p>
<h2 id="limitations-and-future-work"><a class="header" href="#limitations-and-future-work">Limitations and Future Work</a></h2>
<h3 id="implemented-features"><a class="header" href="#implemented-features">Implemented Features</a></h3>
<p><strong>‚úì Automatic suspect link detection</strong></p>
<p>Use <code>req suspect</code> to find all stale fingerprints:</p>
<pre><code class="language-bash">req suspect
# Lists all requirements with fingerprint mismatches
</code></pre>
<p><strong>‚úì Accepting suspect links</strong></p>
<p>Update fingerprints after review:</p>
<pre><code class="language-bash"># Accept individual link
req accept SYS-001 USR-001

# Accept all suspect links
req accept --all
</code></pre>
<p><strong>‚úì CI/CD integration</strong></p>
<p>Exit codes enable automation:</p>
<pre><code class="language-bash">req suspect
# Exit 0 if clean, exit 1 if suspect links found
</code></pre>
<h3 id="current-limitations"><a class="header" href="#current-limitations">Current Limitations</a></h3>
<p><strong>1. No review state tracking</strong></p>
<p>No tracking of review status (current, under review, approved).</p>
<p><strong>Planned</strong>: Review state management with status tracking and assignments.</p>
<p><strong>2. No reporting</strong></p>
<p>Can't generate comprehensive reports of requirement status.</p>
<p><strong>Planned</strong>: <code>req report</code> command for traceability and review status.</p>
<p><strong>3. No impact visualization</strong></p>
<p>Can't see full dependency tree affected by a change.</p>
<p><strong>Planned</strong>: <code>req impact USR-001</code> to show affected descendants.</p>
<p><strong>4. No fingerprint diff</strong></p>
<p>Can't see what content changed between fingerprints.</p>
<p><strong>Planned</strong>: <code>req diff USR-001</code> to show fingerprint changes and content diff.</p>
<p><strong>5. Whitespace sensitivity</strong></p>
<p>Formatting changes trigger fingerprint updates.</p>
<p><strong>Trade-off</strong>: Precision vs. false positives. Current design prioritizes detecting all changes.</p>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<p><strong>Review state management</strong>:</p>
<pre><code class="language-bash">req review start SYS-001
# Mark SYS-001 as "under review"

req review complete SYS-001
# Mark as "reviewed" and update fingerprints

req status
# Output:
# USR-001: current
# SYS-001: reviewed (parents unchanged since review)
# SYS-002: needs review (parent changed)
</code></pre>
<p><strong>Impact analysis</strong>:</p>
<pre><code class="language-bash">req impact USR-001
# Output:
# Direct children:
#   SYS-001, SYS-002
# Indirect descendants:
#   SWR-001 (via SYS-001)
#   TST-001 (via SWR-001)
# Total affected: 4 requirements
</code></pre>
<p><strong>Reporting</strong>:</p>
<pre><code class="language-bash">req report review
# Generate review status report with metrics
</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-link-immediately-after-creation"><a class="header" href="#1-link-immediately-after-creation">1. Link Immediately After Creation</a></h3>
<p>When creating a requirement with parents:</p>
<pre><code class="language-bash"># Create requirement
req add SYS --parents USR-001

# Fingerprint is captured immediately
</code></pre>
<p>This ensures the fingerprint represents the baseline.</p>
<h3 id="2-check-for-suspect-links-regularly"><a class="header" href="#2-check-for-suspect-links-regularly">2. Check for Suspect Links Regularly</a></h3>
<p>Periodically check for fingerprint mismatches:</p>
<pre><code class="language-bash"># Check for suspect links
req suspect

# Before committing changes
req suspect || (echo "Review needed" &amp;&amp; exit 1)

# In CI/CD pipeline
req suspect
</code></pre>
<h3 id="3-accept-links-after-review"><a class="header" href="#3-accept-links-after-review">3. Accept Links After Review</a></h3>
<p>After reviewing parent changes and updating children:</p>
<pre><code class="language-bash"># Accept individual link
req accept SYS-001 USR-001

# Or accept all after bulk review
req accept --all
</code></pre>
<p>This updates fingerprints to acknowledge the review.</p>
<h3 id="4-document-review-process"><a class="header" href="#4-document-review-process">4. Document Review Process</a></h3>
<p>Include fingerprint checking in your review process:</p>
<pre><code class="language-markdown">## Requirement Review Checklist

1. Check for suspect links: `req suspect`
2. For each suspect link:
   - Review parent changes
   - Review child requirement text
   - Update child if needed
   - Accept link: `req accept CHILD PARENT`
3. Verify all clean: `req suspect`
4. Commit changes
</code></pre>
<h3 id="5-avoid-trivial-changes"><a class="header" href="#5-avoid-trivial-changes">5. Avoid Trivial Changes</a></h3>
<p>Minimize whitespace-only or formatting changes to reduce fingerprint churn:</p>
<ul>
<li>Use consistent formatting from the start</li>
<li>Configure editor to preserve formatting</li>
<li>Avoid unnecessary reformatting</li>
</ul>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="unexpected-fingerprint-changes"><a class="header" href="#unexpected-fingerprint-changes">Unexpected Fingerprint Changes</a></h3>
<p><strong>Issue</strong>: Fingerprint changed but content looks the same.</p>
<p><strong>Causes</strong>:</p>
<ol>
<li>Whitespace changes (trailing spaces, blank lines)</li>
<li>Tag modifications</li>
<li>Character encoding differences</li>
</ol>
<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-bash"># Show all changes including whitespace
git diff --ws-error-highlight=all USR-001.md
</code></pre>
<h3 id="fingerprint-not-updating"><a class="header" href="#fingerprint-not-updating">Fingerprint Not Updating</a></h3>
<p><strong>Issue</strong>: Changed requirement but fingerprint seems unchanged.</p>
<p><strong>Explanation</strong>: Fingerprints are stored in parent references, not in the requirement itself.</p>
<p><strong>Check</strong>: Look at a child requirement's parent reference to see the fingerprint.</p>
<h3 id="manual-fingerprint-edit"><a class="header" href="#manual-fingerprint-edit">Manual Fingerprint Edit</a></h3>
<p><strong>Issue</strong>: Accidentally edited a fingerprint in frontmatter.</p>
<p><strong>Impact</strong>: Child will show incorrect fingerprint for parent.</p>
<p><strong>Fix</strong>: Re-link the requirement:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
# This recalculates and stores the correct fingerprint
</code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p><strong>Key Concepts</strong>:</p>
<ul>
<li><strong>Fingerprint</strong>: SHA256 hash of requirement content and tags</li>
<li><strong>Purpose</strong>: Detect when parent requirements change</li>
<li><strong>Storage</strong>: Stored in child's parent reference</li>
<li><strong>Automatic</strong>: Computed when linking requirements</li>
<li><strong>Immutable</strong>: Old fingerprints preserved in children, enabling change detection</li>
</ul>
<p><strong>What's Included</strong>: Markdown body + tags</p>
<p><strong>What's Excluded</strong>: HRID, UUID, timestamps, parent relationships</p>
<p><strong>Use Cases</strong>: Change detection, impact analysis, review tracking</p>
<p><strong>Commands Available</strong>:</p>
<ul>
<li><code>req suspect</code> - List all suspect links (fingerprint mismatches)</li>
<li><code>req accept &lt;CHILD&gt; &lt;PARENT&gt;</code> - Accept suspect link after review</li>
<li><code>req accept --all</code> - Accept all suspect links</li>
</ul>
<p><strong>Current State</strong>: Basic suspect link detection implemented</p>
<p><strong>Future</strong>: Advanced review workflows with state tracking and assignments</p>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li>Learn about <a href="maintaining/./review-workflows.html">Review Workflows</a> (planned feature)</li>
<li>Understand <a href="maintaining/./correcting-hrids.html">Correcting HRIDs</a> for maintaining references</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review-workflows"><a class="header" href="#review-workflows">Review Workflows</a></h1>
<blockquote>
<p><strong>Note</strong>: Basic suspect link detection is <strong>implemented</strong>. Advanced review workflow features (state tracking, assignments, notifications) are <strong>planned for future releases</strong>.</p>
</blockquote>
<p>Review workflows enable teams to track which requirements need review after upstream changes are detected via fingerprint mismatches.</p>
<h2 id="available-now-suspect-link-detection"><a class="header" href="#available-now-suspect-link-detection">Available Now: Suspect Link Detection</a></h2>
<p>Requiem can now automatically detect and manage suspect links:</p>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<p><strong><code>req suspect</code></strong> - List all requirements with fingerprint mismatches</p>
<pre><code class="language-bash">req suspect
</code></pre>
<p>Example output:</p>
<pre><code>Found 3 suspect link(s):

  SYS-001 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-002 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-005 ‚Üí USR-004
    Stored fingerprint:  407c6e3413d5b3fa
    Current fingerprint: c28afe188a974322
</code></pre>
<p>Exit codes:</p>
<ul>
<li><code>0</code>: No suspect links (all current)</li>
<li><code>1</code>: Suspect links found (useful for CI/CD)</li>
</ul>
<p><strong><code>req accept &lt;CHILD&gt; &lt;PARENT&gt;</code></strong> - Accept a suspect link after review</p>
<pre><code class="language-bash">req accept SYS-001 USR-001
# Output: Accepted suspect link: SYS-001 ‚Üí USR-001
</code></pre>
<p><strong><code>req accept --all</code></strong> - Accept all suspect links</p>
<pre><code class="language-bash">req accept --all
# Output:
# Accepted 3 suspect link(s):
#   SYS-001 ‚Üí USR-001
#   SYS-002 ‚Üí USR-001
#   SYS-005 ‚Üí USR-004
</code></pre>
<h3 id="basic-workflow"><a class="header" href="#basic-workflow">Basic Workflow</a></h3>
<pre><code class="language-bash"># 1. Check for suspect links
req suspect

# 2. Review parent changes
vim USR-001.md

# 3. Review and update affected children
vim SYS-001.md
vim SYS-002.md

# 4. Accept links after review
req accept SYS-001 USR-001
req accept SYS-002 USR-001

# Or accept all at once
req accept --all

# 5. Verify clean
req suspect
# Output: No suspect links found.
</code></pre>
<h3 id="cicd-integration-2"><a class="header" href="#cicd-integration-2">CI/CD Integration</a></h3>
<p>Use in continuous integration:</p>
<pre><code class="language-bash">#!/bin/bash
# Fail build if suspect links exist
req suspect
if [ $? -ne 0 ]; then
    echo "ERROR: Requirements need review"
    exit 1
fi
</code></pre>
<p>Or in GitHub Actions:</p>
<pre><code class="language-yaml">- name: Check for suspect links
  run: |
    req suspect || (echo "Requirements need review" &amp;&amp; exit 1)
</code></pre>
<h2 id="planned-advanced-functionality"><a class="header" href="#planned-advanced-functionality">Planned Advanced Functionality</a></h2>
<h3 id="automatic-review-triggers"><a class="header" href="#automatic-review-triggers">Automatic Review Triggers</a></h3>
<p>When a parent requirement changes:</p>
<ol>
<li>Requiem detects fingerprint mismatch in child requirements</li>
<li>Child requirements are flagged as "needs review"</li>
<li>Team members are notified (configurable)</li>
<li>Reviews are tracked until completed</li>
</ol>
<h3 id="review-states-1"><a class="header" href="#review-states-1">Review States</a></h3>
<p>Requirements will have review states:</p>
<ul>
<li><strong>Current</strong>: No parent changes; requirement is up to date</li>
<li><strong>Suspect</strong>: Parent changed (fingerprint mismatch); needs review</li>
<li><strong>Under Review</strong>: Review in progress</li>
<li><strong>Reviewed</strong>: Review completed; requirement updated as needed</li>
<li><strong>Approved</strong>: Reviewed and approved; baseline updated</li>
</ul>
<h3 id="commands-planned"><a class="header" href="#commands-planned">Commands (Planned)</a></h3>
<pre><code class="language-bash"># Check for requirements needing review
req check

# Mark requirement as under review
req review start SYS-001

# Complete review and update fingerprint
req review complete SYS-001

# Show review status
req status

# Generate review report
req report review
</code></pre>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p><strong>Scenario</strong>: A user requirement changes. Which system requirements are affected?</p>
<p><strong>Current state</strong>: Manual tracking required.</p>
<p><strong>Example</strong>:</p>
<ol>
<li>Edit USR-001: Change email validation rules</li>
<li>SYS-001, SYS-002, and SYS-005 reference USR-001</li>
<li><strong>Challenge</strong>: Remember to review all three system requirements</li>
<li><strong>Risk</strong>: Forget to review one; inconsistency results</li>
</ol>
<h3 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h3>
<p>Automatic review tracking:</p>
<ol>
<li>Edit USR-001</li>
<li>Requiem automatically flags SYS-001, SYS-002, SYS-005 as "needs review"</li>
<li>Team dashboard shows requirements pending review</li>
<li>Reviews are tracked and reported</li>
<li>Nothing falls through the cracks</li>
</ol>
<h2 id="how-it-works-current-implementation"><a class="header" href="#how-it-works-current-implementation">How It Works (Current Implementation)</a></h2>
<h3 id="step-1-make-changes"><a class="header" href="#step-1-make-changes">Step 1: Make Changes</a></h3>
<p>Edit a requirement:</p>
<pre><code class="language-bash">vim USR-001.md  # Make your changes
</code></pre>
<p>The fingerprint of USR-001 automatically changes when content or tags change.</p>
<h3 id="step-2-detect-suspect-links"><a class="header" href="#step-2-detect-suspect-links">Step 2: Detect Suspect Links</a></h3>
<p>Find affected children:</p>
<pre><code class="language-bash">req suspect
</code></pre>
<p>Output:</p>
<pre><code>Found 3 suspect link(s):

  SYS-001 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-002 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-005 ‚Üí USR-004
    Stored fingerprint:  407c6e3413d5b3fa
    Current fingerprint: c28afe188a974322
</code></pre>
<h3 id="step-3-conduct-review"><a class="header" href="#step-3-conduct-review">Step 3: Conduct Review</a></h3>
<p>Review each affected requirement:</p>
<pre><code class="language-bash"># Review parent changes
vim USR-001.md

# Review child and update if needed
vim SYS-001.md
</code></pre>
<h3 id="step-4-accept-links"><a class="header" href="#step-4-accept-links">Step 4: Accept Links</a></h3>
<p>After review, accept the fingerprint change:</p>
<pre><code class="language-bash"># Accept individual link
req accept SYS-001 USR-001

# Or accept all at once
req accept --all
</code></pre>
<p>Output:</p>
<pre><code>Accepted 3 suspect link(s):
  SYS-001 ‚Üí USR-001
  SYS-002 ‚Üí USR-001
  SYS-005 ‚Üí USR-004
</code></pre>
<h3 id="step-5-verify-clean"><a class="header" href="#step-5-verify-clean">Step 5: Verify Clean</a></h3>
<p>Confirm no suspect links remain:</p>
<pre><code class="language-bash">req suspect
# Output: No suspect links found.
</code></pre>
<h2 id="how-advanced-features-will-work-planned"><a class="header" href="#how-advanced-features-will-work-planned">How Advanced Features Will Work (Planned)</a></h2>
<h3 id="review-state-tracking"><a class="header" href="#review-state-tracking">Review State Tracking</a></h3>
<p>Track review progress with states:</p>
<pre><code class="language-bash">req review start SYS-001
# - Marks requirement as "under review"
# - Records reviewer and timestamp

req review complete SYS-001
# - Marks requirement as "reviewed"
# - Updates parent fingerprints
# - Clears review flag
</code></pre>
<h3 id="status-reports"><a class="header" href="#status-reports">Status Reports</a></h3>
<p>Generate review reports:</p>
<pre><code class="language-bash">req report review
</code></pre>
<p>Output:</p>
<pre><code>Review Status Report (2025-07-22)

Pending Reviews:
  SYS-002: parent USR-001 changed (flagged 3 days ago)
  SYS-005: parent USR-001 changed (flagged 3 days ago)

Recently Reviewed:
  SYS-001: reviewed by alice@example.com (2025-07-22)

All Current:
  SYS-003, SYS-004, ...
</code></pre>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="use-case-1-change-impact-analysis"><a class="header" href="#use-case-1-change-impact-analysis">Use Case 1: Change Impact Analysis</a></h3>
<p><strong>Scenario</strong>: Proposing a change to a critical requirement.</p>
<p><strong>Question</strong>: What's the impact?</p>
<p><strong>Workflow</strong>:</p>
<ol>
<li>Identify requirement to change (USR-001)</li>
<li>Check impact:</li>
</ol>
<pre><code class="language-bash">req impact USR-001
</code></pre>
<ol start="3">
<li>Output shows all descendants:</li>
</ol>
<pre><code>Requirements that depend on USR-001:
  Direct children:
    SYS-001, SYS-002, SYS-005
  Indirect descendants:
    SWR-001, SWR-003 (via SYS-001)
    TST-001, TST-002 (via SYS-001, SYS-002)

Total affected: 7 requirements
</code></pre>
<ol start="4">
<li>Decide if change is worth the review burden</li>
</ol>
<h3 id="use-case-2-release-readiness"><a class="header" href="#use-case-2-release-readiness">Use Case 2: Release Readiness</a></h3>
<p><strong>Scenario</strong>: Preparing for a release.</p>
<p><strong>Question</strong>: Are all requirements reviewed and current?</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash">req status
</code></pre>
<p>Sample output:</p>
<pre><code>Requirement Counts
==================
Kind       | Count
-----------+-----
SYS        | 118
TST        | 24
USR        | 6
-----------+-----
Total      | 148

Suspect links: 3
</code></pre>
<p>If the command exits with code <code>1</code>, use the suspect link total as your release checklist‚Äîclear
them before shipping:</p>
<pre><code class="language-bash">req check
# Review each flagged requirement
req review complete ...
</code></pre>
<h3 id="use-case-3-compliance-audits"><a class="header" href="#use-case-3-compliance-audits">Use Case 3: Compliance Audits</a></h3>
<p><strong>Scenario</strong>: Demonstrating requirements traceability for audit.</p>
<p><strong>Goal</strong>: Show that all requirements were reviewed after changes.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash">req report audit --since 2025-01-01
</code></pre>
<p>Output:</p>
<pre><code>Audit Report: Jan 1 - Jul 22, 2025

Requirements Changed: 23
  - USR-001, USR-005, SYS-003, ...

Reviews Conducted: 47
  - All downstream requirements reviewed
  - Average review time: 2.3 days

Compliance: ‚úì PASS
  - All changed requirements reviewed
  - All affected descendants reviewed
</code></pre>
<h2 id="configuration-planned"><a class="header" href="#configuration-planned">Configuration (Planned)</a></h2>
<h3 id="review-policies"><a class="header" href="#review-policies">Review Policies</a></h3>
<pre><code class="language-toml"># config.toml (planned)
[review]
# Automatically flag children when parent changes
auto_flag = true

# Require review completion before allowing further changes
block_on_pending_review = false

# Notification settings
notify_on_flag = true
notification_email = "team@example.com"

# Review SLA (days)
review_sla = 7
</code></pre>
<h3 id="review-rules"><a class="header" href="#review-rules">Review Rules</a></h3>
<pre><code class="language-toml"># config.toml (planned)
[review.rules]
# Require review for specific requirement kinds
require_review_for = ["USR", "SYS"]

# Skip review for certain kinds (e.g., documentation)
skip_review_for = ["DOC"]

# Require multiple approvers for critical requirements
require_approvals = 2  # For requirements tagged "critical"
</code></pre>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<h3 id="git-integration"><a class="header" href="#git-integration">Git Integration</a></h3>
<p>Reviews tracked alongside code changes:</p>
<pre><code class="language-bash"># Edit requirement
vim USR-001.md

# Flag affected requirements
req check

# Create PR with review tracking
git checkout -b update-usr-001
git add USR-001.md
git commit -m "Update USR-001: clarify email validation"

# PR description includes:
# - Changed requirement
# - Affected requirements
# - Review checklist
</code></pre>
<h3 id="cicd-integration-3"><a class="header" href="#cicd-integration-3">CI/CD Integration</a></h3>
<pre><code class="language-yaml"># .github/workflows/requirements.yml (planned)
- name: Check review status
  run: |
    req check
    if [ $? -ne 0 ]; then
      echo "Requirements need review"
      exit 1
    fi
</code></pre>
<h3 id="issue-tracker-integration"><a class="header" href="#issue-tracker-integration">Issue Tracker Integration</a></h3>
<p>Automatically create issues for flagged requirements:</p>
<pre><code class="language-bash">req check --create-issues
# Creates GitHub/Jira issues for each requirement needing review
</code></pre>
<h2 id="current-workflow-examples"><a class="header" href="#current-workflow-examples">Current Workflow Examples</a></h2>
<h3 id="example-1-daily-review-check"><a class="header" href="#example-1-daily-review-check">Example 1: Daily Review Check</a></h3>
<p>Check for suspect links before starting work:</p>
<pre><code class="language-bash">#!/bin/bash
# daily-check.sh

echo "Checking for suspect links..."
req suspect

if [ $? -eq 0 ]; then
    echo "‚úì All requirements current"
else
    echo "‚ö† Review needed - see above"
fi
</code></pre>
<h3 id="example-2-pre-commit-hook"><a class="header" href="#example-2-pre-commit-hook">Example 2: Pre-Commit Hook</a></h3>
<p>Prevent commits with unreviewed changes:</p>
<pre><code class="language-bash">#!/bin/bash
# .git/hooks/pre-commit

req suspect
if [ $? -ne 0 ]; then
    echo "ERROR: Suspect links found. Run 'req suspect' to see them."
    echo "Review and accept links before committing."
    exit 1
fi
</code></pre>
<h3 id="example-3-pull-request-workflow"><a class="header" href="#example-3-pull-request-workflow">Example 3: Pull Request Workflow</a></h3>
<pre><code class="language-bash"># 1. After making changes
git add -A
git commit -m "Update USR-001 validation rules"

# 2. Check for suspect links
req suspect

# 3. Review and update affected requirements
vim SYS-001.md
vim SYS-002.md

# 4. Accept all after review
req accept --all

# 5. Commit accepted fingerprints
git add -A
git commit -m "Accept fingerprints after USR-001 changes"

# 6. Push
git push
</code></pre>
<h3 id="example-4-bulk-review-session"><a class="header" href="#example-4-bulk-review-session">Example 4: Bulk Review Session</a></h3>
<p>Review all pending changes at once:</p>
<pre><code class="language-bash"># List all suspect links
req suspect &gt; review-list.txt

# Review each one
vim SYS-001.md
vim SYS-002.md
# ... review all

# Accept all at once
req accept --all

# Verify clean
req suspect
</code></pre>
<h2 id="supplementary-tracking-optional"><a class="header" href="#supplementary-tracking-optional">Supplementary Tracking (Optional)</a></h2>
<p>While <code>req suspect</code> and <code>req accept</code> handle basic detection and acceptance, you may want additional tracking:</p>
<h3 id="git-commit-messages"><a class="header" href="#git-commit-messages">Git Commit Messages</a></h3>
<p>Document reviews in commit messages:</p>
<pre><code class="language-bash">git commit -m "Review SYS-001 after USR-001 change

USR-001 updated email validation rules.
Reviewed SYS-001 and verified consistency.
No changes needed to SYS-001.

Accepted fingerprint: c4020419ead000e9"
</code></pre>
<h3 id="issue-tracking"><a class="header" href="#issue-tracking">Issue Tracking</a></h3>
<p>Create issues for complex reviews:</p>
<pre><code class="language-markdown">## Review affected requirements after USR-001 change

- [x] SYS-001: Reviewed, no changes needed
- [x] SYS-002: Updated validation logic
- [ ] SYS-005: Waiting for clarification
</code></pre>
<h3 id="tags-in-frontmatter"><a class="header" href="#tags-in-frontmatter">Tags in Frontmatter</a></h3>
<p>Track review priority with tags:</p>
<pre><code class="language-yaml"># SYS-001.md
tags:
- high-priority
- security-critical
</code></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<p>Beyond basic review workflows:</p>
<h3 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h3>
<p><strong>Review assignments</strong>:</p>
<pre><code class="language-bash">req review assign SYS-001 --to alice@example.com
</code></pre>
<p><strong>Review templates</strong>:</p>
<pre><code class="language-bash">req review start SYS-001 --template checklist.md
# Provides structured review checklist
</code></pre>
<p><strong>Review history</strong>:</p>
<pre><code class="language-bash">req history SYS-001
# Shows all reviews and changes over time
</code></pre>
<p><strong>Bulk operations</strong>:</p>
<pre><code class="language-bash">req review complete SYS-001 SYS-002 SYS-003
# Complete multiple reviews at once
</code></pre>
<h3 id="integrations"><a class="header" href="#integrations">Integrations</a></h3>
<p><strong>Slack/Teams notifications</strong>:</p>
<pre><code>@alice Your review is needed: SYS-001 (parent changed)
</code></pre>
<p><strong>Dashboard UI</strong>:
Web dashboard showing review status, pending items, team metrics.</p>
<p><strong>Approval workflows</strong>:
Multi-step approval for critical requirements.</p>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p><strong>Current status</strong>: <strong>Partially implemented</strong></p>
<p><strong>Available now</strong>:</p>
<ul>
<li>‚úÖ <code>req suspect</code> - Detect fingerprint mismatches</li>
<li>‚úÖ <code>req accept &lt;CHILD&gt; &lt;PARENT&gt;</code> - Accept individual suspect links</li>
<li>‚úÖ <code>req accept --all</code> - Accept all suspect links</li>
<li>‚úÖ CI/CD integration via exit codes</li>
</ul>
<p><strong>Planned for future releases</strong>:</p>
<ul>
<li>‚è≥ Review state tracking (under review, reviewed, approved)</li>
<li>‚è≥ Review assignments and notifications</li>
<li>‚è≥ Status reports and dashboards</li>
<li>‚è≥ Review history and audit logs</li>
<li>‚è≥ Multi-approver workflows</li>
</ul>
<p>See <a href="https://github.com/danieleades/requirements-manager">GitHub repository</a> for updates.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Interested in helping implement advanced review workflow features? See the project repository for contribution guidelines.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p><strong>Implemented features</strong>:</p>
<ul>
<li>Automatic suspect link detection (<code>req suspect</code>)</li>
<li>Accepting suspect links after review (<code>req accept</code>)</li>
<li>CI/CD integration with proper exit codes</li>
<li>Batch operations (<code>req accept --all</code>)</li>
</ul>
<p><strong>Use these commands now</strong>:</p>
<pre><code class="language-bash">req suspect              # List suspect links
req accept SYS-001 USR-001  # Accept single link
req accept --all         # Accept all suspect links
</code></pre>
<p><strong>Planned advanced features</strong>:</p>
<ul>
<li>Review state tracking (suspect ‚Üí under review ‚Üí reviewed ‚Üí approved)</li>
<li>Commands: <code>req review start/complete</code>, <code>req status</code>, <code>req report</code></li>
<li>Review assignments and team workflows</li>
<li>Notifications and integrations</li>
<li>Comprehensive audit reports</li>
</ul>
<p><strong>Current best practices</strong>:</p>
<ul>
<li>Use <code>req suspect</code> regularly to check for changes</li>
<li>Review requirements manually before accepting</li>
<li>Use <code>req accept</code> to update fingerprints after review</li>
<li>Integrate into CI/CD pipelines for automated checks</li>
<li>Document reviews in git commit messages</li>
</ul>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li>Use <a href="maintaining/./fingerprints.html">Fingerprints</a> for manual change detection</li>
<li>Implement <a href="maintaining/review-workflows.html#workarounds-until-implemented">workarounds</a> for your workflow</li>
<li>Watch GitHub repository for implementation updates</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-1"><a class="header" href="#integration-1">Integration</a></h1>
<p>Requiem integrates with existing tools in your development workflow. This chapter covers integration strategies and best practices.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Requiem's plain-text format enables integration with:</p>
<ul>
<li><strong><a href="./integration/mdbook.html">MdBook</a></strong> - Embed requirements in MdBook documentation</li>
<li><strong><a href="./integration/sphinx.html">Sphinx</a></strong> - Include requirements in Sphinx-generated docs</li>
<li><strong><a href="./integration/version-control.html">Version Control</a></strong> - Git workflows and best practices</li>
</ul>
<h2 id="philosophy-compose-dont-replace"><a class="header" href="#philosophy-compose-dont-replace">Philosophy: Compose, Don't Replace</a></h2>
<p>Requiem doesn't aim to replace your existing documentation or development tools. Instead, it composes with them:</p>
<h3 id="documentation-tools-1"><a class="header" href="#documentation-tools-1">Documentation Tools</a></h3>
<p>Requirements live alongside your documentation:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ user-guide.md
‚îú‚îÄ‚îÄ architecture.md
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md    ‚Üê Requirements
‚îÇ   ‚îî‚îÄ‚îÄ SYS-001.md
‚îî‚îÄ‚îÄ api-reference.md
</code></pre>
<p>Documentation can reference or embed requirements directly.</p>
<h3 id="version-control-2"><a class="header" href="#version-control-2">Version Control</a></h3>
<p>Requirements are plain text files that work naturally with Git:</p>
<ul>
<li>Meaningful diffs</li>
<li>Branch and merge workflows</li>
<li>Pull request reviews</li>
<li>Complete history</li>
</ul>
<h3 id="static-site-generators"><a class="header" href="#static-site-generators">Static Site Generators</a></h3>
<p>MdBook and Sphinx can include requirement files in generated documentation:</p>
<pre><code class="language-markdown"># User Guide

## Requirements

---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
---
# Plain Text Storage

## Statement

The tool shall store requirements as plain-text files that can be read and edited with any text editor.

## Rationale

Plain text storage enables:
- Version control integration with Git and other VCS tools
- Human review without specialized software
- Long-term archival and accessibility
- Integration with existing text-based workflows

## Acceptance Criteria

- Requirements are stored as `.md` (Markdown) files
- Files can be opened and edited in any text editor
- No proprietary or binary formats are required
- Files are compatible with standard version control systems
</code></pre>
<p>Requirements stay synchronized with documentation automatically.</p>
<h3 id="cicd-pipelines"><a class="header" href="#cicd-pipelines">CI/CD Pipelines</a></h3>
<p>Validate requirements in continuous integration:</p>
<pre><code class="language-yaml">- name: Validate requirements
  run: req clean
</code></pre>
<p>Catch errors before merging.</p>
<h3 id="custom-tools"><a class="header" href="#custom-tools">Custom Tools</a></h3>
<p>Plain text enables custom tooling:</p>
<pre><code class="language-python"># Custom analysis script
import glob

for req_file in glob.glob("USR-*.md"):
    # Parse, analyze, generate reports, etc.
</code></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="pattern-1-standalone-requirements"><a class="header" href="#pattern-1-standalone-requirements">Pattern 1: Standalone Requirements</a></h3>
<p>Requirements in dedicated directory:</p>
<pre><code>project/
‚îú‚îÄ‚îÄ src/           ‚Üê Source code
‚îú‚îÄ‚îÄ requirements/  ‚Üê Requirements (separate)
‚îÇ   ‚îú‚îÄ‚îÄ config.toml
‚îÇ   ‚îî‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ docs/          ‚Üê Documentation (separate)
</code></pre>
<p><strong>Best for</strong>: Clear separation of concerns, formal requirements management.</p>
<h3 id="pattern-2-requirements-with-documentation"><a class="header" href="#pattern-2-requirements-with-documentation">Pattern 2: Requirements with Documentation</a></h3>
<p>Requirements embedded in documentation:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ user-guide.md
‚îú‚îÄ‚îÄ USR-001.md      ‚Üê Mixed with docs
‚îú‚îÄ‚îÄ architecture.md
‚îî‚îÄ‚îÄ SYS-001.md      ‚Üê Mixed with docs
</code></pre>
<p>Configuration: <code>allow_unrecognised = true</code> (to ignore non-requirement markdown files).</p>
<p><strong>Best for</strong>: Integrated documentation, technical specifications.</p>
<h3 id="pattern-3-monorepo-with-multiple-projects"><a class="header" href="#pattern-3-monorepo-with-multiple-projects">Pattern 3: Monorepo with Multiple Projects</a></h3>
<p>Each project has its own requirements:</p>
<pre><code>monorepo/
‚îú‚îÄ‚îÄ project-a/
‚îÇ   ‚îî‚îÄ‚îÄ requirements/
‚îÇ       ‚îî‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ project-b/
‚îÇ   ‚îî‚îÄ‚îÄ requirements/
‚îÇ       ‚îî‚îÄ‚îÄ USR-001.md
‚îî‚îÄ‚îÄ shared/
    ‚îî‚îÄ‚îÄ requirements/
        ‚îî‚îÄ‚îÄ CORE-USR-001.md
</code></pre>
<p><strong>Best for</strong>: Multi-project organizations, shared requirements.</p>
<h2 id="integration-benefits"><a class="header" href="#integration-benefits">Integration Benefits</a></h2>
<h3 id="single-source-of-truth"><a class="header" href="#single-source-of-truth">Single Source of Truth</a></h3>
<p>Requirements are defined once, referenced everywhere:</p>
<ul>
<li>User documentation includes requirement text</li>
<li>Design docs reference requirements</li>
<li>Test plans trace to requirements</li>
<li>Code comments link to requirements</li>
</ul>
<p>Changes propagate automatically (when using includes/references).</p>
<h3 id="automated-consistency"><a class="header" href="#automated-consistency">Automated Consistency</a></h3>
<p>CI/CD ensures requirements remain valid:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml
- run: req clean
</code></pre>
<p>Prevents broken traceability or invalid formatting.</p>
<h3 id="developer-friendly"><a class="header" href="#developer-friendly">Developer-Friendly</a></h3>
<p>Plain text means developers can:</p>
<ul>
<li>Use their preferred editor</li>
<li>Search with grep/ripgrep</li>
<li>Script with Python/Bash</li>
<li>Review in pull requests</li>
</ul>
<p>No context switching to specialized tools.</p>
<h3 id="audit-trail"><a class="header" href="#audit-trail">Audit Trail</a></h3>
<p>Git provides complete history:</p>
<pre><code class="language-bash"># See all changes to a requirement
git log -p USR-001.md

# See who last modified
git blame USR-001.md

# See what changed in a sprint
git log --since="2 weeks ago" -- requirements/
</code></pre>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<p>Explore specific integrations:</p>
<ul>
<li><strong><a href="./integration/mdbook.html">Using with MdBook</a></strong> - Embed requirements in MdBook sites</li>
<li><strong><a href="./integration/sphinx.html">Using with Sphinx</a></strong> - Include requirements in Sphinx documentation</li>
<li><strong><a href="./integration/version-control.html">Version Control Best Practices</a></strong> - Git workflows for requirements</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-with-mdbook"><a class="header" href="#using-with-mdbook">Using with MdBook</a></h1>
<p><a href="https://github.com/rust-lang/mdBook">MdBook</a> is a popular tool for creating documentation from Markdown files. Requiem integrates seamlessly with MdBook, allowing requirements to live alongside documentation.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Requiem requirements are Markdown files, making them naturally compatible with MdBook. You can:</p>
<ul>
<li>Include requirements in your MdBook table of contents</li>
<li>Embed requirements in documentation chapters</li>
<li>Mix requirements with narrative documentation</li>
<li>Generate complete documentation sites with embedded requirements</li>
</ul>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<pre><code>my-book/
‚îú‚îÄ‚îÄ book.toml          ‚Üê MdBook configuration
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ SUMMARY.md     ‚Üê Table of contents
    ‚îú‚îÄ‚îÄ config.toml    ‚Üê Requiem configuration
    ‚îú‚îÄ‚îÄ chapter1.md    ‚Üê Documentation
    ‚îú‚îÄ‚îÄ USR-001.md     ‚Üê Requirement
    ‚îî‚îÄ‚îÄ USR-002.md     ‚Üê Requirement
</code></pre>
<h3 id="requiem-configuration"><a class="header" href="#requiem-configuration">Requiem Configuration</a></h3>
<p>Since the <code>src/</code> directory contains both requirements and documentation, configure Requiem to allow non-requirement files:</p>
<p><strong>src/config.toml</strong>:</p>
<pre><code class="language-toml">_version = "1"
allow_unrecognised = true  # Important: allows chapter1.md, SUMMARY.md, etc.
</code></pre>
<h3 id="mdbook-configuration"><a class="header" href="#mdbook-configuration">MdBook Configuration</a></h3>
<p><strong>book.toml</strong>:</p>
<pre><code class="language-toml">[book]
title = "My Project Documentation"
authors = ["Your Name"]
language = "en"
src = "src"

[build]
build-dir = "book"
</code></pre>
<p>No special MdBook configuration needed for Requiem requirements!</p>
<h2 id="including-requirements-in-table-of-contents"><a class="header" href="#including-requirements-in-table-of-contents">Including Requirements in Table of Contents</a></h2>
<p>Requirements can be listed in <code>SUMMARY.md</code> like any other chapter:</p>
<p><strong>src/SUMMARY.md</strong>:</p>
<pre><code class="language-markdown"># Summary

[Introduction](./introduction.md)

# Requirements

- [User Requirements](./user-requirements.md)
  - [USR-001: User Authentication](./USR-001.md)
  - [USR-002: Data Export](./USR-002.md)
  - [USR-003: Email Validation](./USR-003.md)

- [System Requirements](./system-requirements.md)
  - [SYS-001: Authentication Service](./SYS-001.md)
  - [SYS-002: Export API](./SYS-002.md)

# User Guide

- [Getting Started](./getting-started.md)
- [Features](./features.md)
</code></pre>
<p>Requirements appear as chapters in the generated book, with frontmatter and Markdown body rendered.</p>
<h2 id="embedding-requirements"><a class="header" href="#embedding-requirements">Embedding Requirements</a></h2>
<p>Use MdBook's include feature to embed requirements in documentation chapters:</p>
<p><strong>src/user-guide.md</strong>:</p>
<pre><code class="language-markdown"># User Guide

## Authentication

Our authentication system satisfies the following requirement:

{{#include USR-001.md}}

To log in, navigate to...
</code></pre>
<p>When MdBook builds, <code>USR-001.md</code> content is embedded directly.</p>
<h3 id="selective-inclusion"><a class="header" href="#selective-inclusion">Selective Inclusion</a></h3>
<p>Include only the requirement body (skip frontmatter):</p>
<pre><code class="language-markdown">{{#include USR-001.md:7:}}
</code></pre>
<p>This skips the YAML frontmatter (lines 1-6 typically) and includes only the markdown body.</p>
<p><strong>Line counting</strong>:</p>
<pre><code class="language-markdown">---
_version: '1'
uuid: ...
created: ...
---                    ‚Üê Line 6

Requirement text...    ‚Üê Line 7 onwards
</code></pre>
<p>Adjust the line number based on your frontmatter length.</p>
<h2 id="formatting-requirements"><a class="header" href="#formatting-requirements">Formatting Requirements</a></h2>
<h3 id="display-frontmatter"><a class="header" href="#display-frontmatter">Display Frontmatter</a></h3>
<p>To show frontmatter in documentation:</p>
<p><strong>src/requirements-format.md</strong>:</p>
<pre><code class="language-markdown"># Requirement Format

Requirements include metadata in YAML frontmatter:

{{#include USR-001.md}}
</code></pre>
<p>MdBook renders the entire file, including frontmatter as a code block.</p>
<h3 id="hide-frontmatter"><a class="header" href="#hide-frontmatter">Hide Frontmatter</a></h3>
<p>To show only the requirement text:</p>
<p><strong>Option 1: Use line ranges</strong></p>
<pre><code class="language-markdown">{{#include USR-001.md:7:}}
</code></pre>
<p><strong>Option 2: Create requirement summary files</strong></p>
<p><strong>src/usr-001-summary.md</strong>:</p>
<pre><code class="language-markdown">&lt;!-- Manually maintained summary without frontmatter --&gt;
The system shall validate user email addresses according to RFC 5322.
</code></pre>
<p>Then include the summary file in documentation.</p>
<h3 id="custom-formatting-with-preprocessors"><a class="header" href="#custom-formatting-with-preprocessors">Custom Formatting with Preprocessors</a></h3>
<p>For advanced formatting (e.g., extracting specific fields), use MdBook preprocessors:</p>
<ul>
<li><a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck">mdbook-linkcheck</a> - Validate links</li>
<li><a href="https://github.com/badboy/mdbook-toc">mdbook-toc</a> - Generate table of contents</li>
<li>Custom preprocessor - Extract HRID, UUID, parent links from frontmatter</li>
</ul>
<h2 id="working-example"><a class="header" href="#working-example">Working Example</a></h2>
<p>See the complete example in the Requiem repository:</p>
<pre><code class="language-bash">git clone https://github.com/danieleades/requirements-manager
cd requirements-manager/examples/mdbook
</code></pre>
<h3 id="example-structure"><a class="header" href="#example-structure">Example Structure</a></h3>
<pre><code>examples/mdbook/
‚îú‚îÄ‚îÄ book.toml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ chapter_1.md
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ USR-002.md
‚îî‚îÄ‚îÄ README.md
</code></pre>
<h3 id="build-the-example"><a class="header" href="#build-the-example">Build the Example</a></h3>
<ol>
<li>Install MdBook:</li>
</ol>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<ol start="2">
<li>Build the book:</li>
</ol>
<pre><code class="language-bash">mdbook build
</code></pre>
<ol start="3">
<li>View output:</li>
</ol>
<pre><code class="language-bash">mdbook serve --open
</code></pre>
<p>Your browser opens showing the documentation with requirements included.</p>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="1-organize-by-type"><a class="header" href="#1-organize-by-type">1. Organize by Type</a></h3>
<p>Group requirements in <code>SUMMARY.md</code>:</p>
<pre><code class="language-markdown"># Summary

# User Requirements
- [USR-001](./USR-001.md)
- [USR-002](./USR-002.md)

# System Requirements
- [SYS-001](./SYS-001.md)
- [SYS-002](./SYS-002.md)
</code></pre>
<h3 id="2-use-subdirectories"><a class="header" href="#2-use-subdirectories">2. Use Subdirectories</a></h3>
<p>For large projects, organize requirements in subdirectories:</p>
<pre><code>src/
‚îú‚îÄ‚îÄ SUMMARY.md
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ USR-002.md
‚îÇ   ‚îî‚îÄ‚îÄ system/
‚îÇ       ‚îú‚îÄ‚îÄ SYS-001.md
‚îÇ       ‚îî‚îÄ‚îÄ SYS-002.md
‚îî‚îÄ‚îÄ guides/
    ‚îî‚îÄ‚îÄ user-guide.md
</code></pre>
<p><strong>SUMMARY.md</strong>:</p>
<pre><code class="language-markdown"># Summary

# Requirements
- [User Requirements](./requirements/user/USR-001.md)
- [System Requirements](./requirements/system/SYS-001.md)
</code></pre>
<h3 id="3-link-requirements"><a class="header" href="#3-link-requirements">3. Link Requirements</a></h3>
<p>Link between requirements using standard Markdown links:</p>
<p><strong>USR-001.md</strong>:</p>
<pre><code class="language-markdown">This requirement is implemented by [SYS-001](./SYS-001.md).
</code></pre>
<p>MdBook generates clickable links in the output.</p>
<h3 id="4-embed-in-context"><a class="header" href="#4-embed-in-context">4. Embed in Context</a></h3>
<p>Embed requirements in relevant documentation sections:</p>
<p><strong>user-guide.md</strong>:</p>
<pre><code class="language-markdown"># User Guide

## Email Validation

{{#include requirements/USR-003.md:7:}}

To validate emails, the system checks...
</code></pre>
<p>Keeps requirements and documentation synchronized.</p>
<h3 id="5-separate-config"><a class="header" href="#5-separate-config">5. Separate Config</a></h3>
<p>Use separate <code>config.toml</code> for Requiem:</p>
<pre><code>src/
‚îú‚îÄ‚îÄ config.toml      ‚Üê Requiem config (allow_unrecognised = true)
‚îú‚îÄ‚îÄ book.toml        ‚Üê Don't confuse with MdBook config
‚îî‚îÄ‚îÄ ...
</code></pre>
<p>Note: MdBook's config is <code>book.toml</code> in the root, not in <code>src/</code>.</p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<h3 id="frontmatter-rendering"><a class="header" href="#frontmatter-rendering">Frontmatter Rendering</a></h3>
<p>MdBook doesn't parse YAML frontmatter specially. It renders as:</p>
<pre><code>---
_version: '1'
uuid: 4bfeb7d5-...
created: 2025-07-22T12:19:56.950194157Z
---

Requirement text...
</code></pre>
<p>The frontmatter appears as a code block (triple-dash markers).</p>
<p><strong>Workaround</strong>: Use line ranges to skip frontmatter (see <a href="integration/mdbook.html#formatting-requirements">Formatting Requirements</a>).</p>
<h3 id="no-dynamic-traceability"><a class="header" href="#no-dynamic-traceability">No Dynamic Traceability</a></h3>
<p>MdBook doesn't generate traceability matrices or parent-child diagrams automatically.</p>
<p><strong>Workaround</strong>: Generate diagrams with external tools and include as images:</p>
<pre><code class="language-markdown"># Traceability

![Requirement Hierarchy](./diagrams/traceability.svg)
</code></pre>
<h3 id="no-hrid-validation"><a class="header" href="#no-hrid-validation">No HRID Validation</a></h3>
<p>MdBook doesn't validate requirement references.</p>
<p><strong>Workaround</strong>: Use CI to validate:</p>
<pre><code class="language-yaml"># .github/workflows/docs.yml
- name: Validate requirements
  run: req clean
  working-directory: ./src

- name: Build documentation
  run: mdbook build
</code></pre>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="generating-traceability-pages"><a class="header" href="#generating-traceability-pages">Generating Traceability Pages</a></h3>
<p>Use scripts to generate traceability documentation:</p>
<p><strong>generate-traceability.sh</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
# Generate a markdown page showing parent-child relationships

echo "# Requirement Traceability" &gt; traceability.md
echo "" &gt;&gt; traceability.md

for req in USR-*.md; do
    hrid=$(basename "$req" .md)
    echo "## $hrid" &gt;&gt; traceability.md
    # Extract and format parent links
    # ...
done
</code></pre>
<p>Run before MdBook build:</p>
<pre><code class="language-bash">./generate-traceability.sh
mdbook build
</code></pre>
<h3 id="custom-mdbook-preprocessor"><a class="header" href="#custom-mdbook-preprocessor">Custom MdBook Preprocessor</a></h3>
<p>Create a preprocessor to enhance requirement rendering:</p>
<p><strong>Rust preprocessor example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extract HRID and UUID from frontmatter
// Add custom formatting
// Generate cross-reference links
<span class="boring">}</span></code></pre></pre>
<p>See <a href="https://rust-lang.github.io/mdBook/format/configuration/preprocessors.html">MdBook documentation</a> for details.</p>
<h3 id="github-pages-deployment"><a class="header" href="#github-pages-deployment">GitHub Pages Deployment</a></h3>
<p>Host your requirements documentation:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
name: Deploy Documentation

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install MdBook
        run: cargo install mdbook
      - name: Build book
        run: mdbook build
        working-directory: ./docs
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/book
</code></pre>
<h2 id="example-documentation-structure"><a class="header" href="#example-documentation-structure">Example Documentation Structure</a></h2>
<p>Comprehensive documentation with requirements:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ book.toml
‚îî‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ SUMMARY.md
    ‚îú‚îÄ‚îÄ config.toml             ‚Üê Requiem config
    ‚îÇ
    ‚îú‚îÄ‚îÄ introduction.md          ‚Üê Narrative docs
    ‚îú‚îÄ‚îÄ architecture.md
    ‚îú‚îÄ‚îÄ getting-started.md
    ‚îÇ
    ‚îú‚îÄ‚îÄ requirements/            ‚Üê Requirements
    ‚îÇ   ‚îú‚îÄ‚îÄ user/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ USR-002.md
    ‚îÇ   ‚îú‚îÄ‚îÄ system/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SYS-001.md
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SYS-002.md
    ‚îÇ   ‚îî‚îÄ‚îÄ traceability.md      ‚Üê Generated
    ‚îÇ
    ‚îî‚îÄ‚îÄ user-guide/              ‚Üê User guides
        ‚îú‚îÄ‚îÄ authentication.md    ‚Üê Embeds USR-001, SYS-001
        ‚îî‚îÄ‚îÄ export.md            ‚Üê Embeds USR-002, SYS-002
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="requirements-not-appearing-in-book"><a class="header" href="#requirements-not-appearing-in-book">Requirements Not Appearing in Book</a></h3>
<p><strong>Problem</strong>: Requirements listed in <code>SUMMARY.md</code> don't appear.</p>
<p><strong>Diagnosis</strong>:</p>
<ol>
<li>Check file paths in <code>SUMMARY.md</code> are correct</li>
<li>Ensure files exist at specified paths</li>
<li>Run <code>mdbook build -v</code> for verbose output</li>
</ol>
<p><strong>Solution</strong>: Verify paths match file structure exactly.</p>
<h3 id="frontmatter-renders-as-code-block"><a class="header" href="#frontmatter-renders-as-code-block">Frontmatter Renders as Code Block</a></h3>
<p><strong>Problem</strong>: YAML frontmatter shows as markdown code block.</p>
<p><strong>Explanation</strong>: Expected behavior. MdBook doesn't parse YAML frontmatter.</p>
<p><strong>Solution</strong>: Use line ranges to skip frontmatter (see <a href="integration/mdbook.html#selective-inclusion">Selective Inclusion</a>).</p>
<h3 id="requiem-validation-fails"><a class="header" href="#requiem-validation-fails">Requiem Validation Fails</a></h3>
<p><strong>Problem</strong>: <code>req clean</code> reports errors about non-requirement files.</p>
<p><strong>Solution</strong>: Set <code>allow_unrecognised = true</code> in <code>config.toml</code>:</p>
<pre><code class="language-toml">_version = "1"
allow_unrecognised = true
</code></pre>
<h3 id="includes-dont-work"><a class="header" href="#includes-dont-work">Includes Don't Work</a></h3>
<p><strong>Problem</strong>: <code>{{#include USR-001.md}}</code> doesn't embed content.</p>
<p><strong>Diagnosis</strong>:</p>
<ol>
<li>Check file path is correct relative to including file</li>
<li>Check MdBook version (includes supported in 0.3.0+)</li>
</ol>
<p><strong>Solution</strong>: Use correct relative paths:</p>
<pre><code class="language-markdown">{{#include ./USR-001.md}}  # If in same directory
{{#include ../requirements/USR-001.md}}  # If in subdirectory
</code></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p><strong>Key Points</strong>:</p>
<ul>
<li>Requiem requirements are compatible with MdBook out of the box</li>
<li>Set <code>allow_unrecognised = true</code> in Requiem config when mixing with docs</li>
<li>Include requirements in <code>SUMMARY.md</code> or embed with <code>{{#include}}</code></li>
<li>Use line ranges to skip frontmatter if desired</li>
<li>Combine requirements with narrative documentation for comprehensive docs</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Single source of truth</li>
<li>Requirements stay synchronized with docs</li>
<li>Easy navigation and search</li>
<li>Professional-looking documentation</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>Frontmatter renders as code block</li>
<li>No automatic traceability diagrams</li>
<li>No HRID validation (use external tools)</li>
</ul>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li>See <a href="integration/./sphinx.html">Using with Sphinx</a> for Python documentation</li>
<li>Review <a href="integration/./version-control.html">Version Control Best Practices</a> for managing requirements in Git</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-with-sphinx"><a class="header" href="#using-with-sphinx">Using with Sphinx</a></h1>
<p><a href="https://www.sphinx-doc.org/">Sphinx</a> is a powerful documentation generator widely used in Python projects. Requiem requirements can be integrated with Sphinx documentation.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Sphinx traditionally uses reStructuredText (RST), but with the <a href="https://myst-parser.readthedocs.io/">MyST Parser</a> extension, Sphinx can process Markdown files including Requiem requirements.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Python 3.7 or later</li>
<li>Sphinx</li>
<li>MyST Parser extension</li>
</ul>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>Using pip:</p>
<pre><code class="language-bash">pip install sphinx myst-parser
</code></pre>
<p>Using uv (recommended):</p>
<pre><code class="language-bash">uv pip install sphinx myst-parser
</code></pre>
<h3 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h3>
<pre><code>docs/
‚îú‚îÄ‚îÄ conf.py             ‚Üê Sphinx configuration
‚îú‚îÄ‚îÄ index.md            ‚Üê Main documentation
‚îú‚îÄ‚îÄ requirements/       ‚Üê Requirements directory
‚îÇ   ‚îú‚îÄ‚îÄ config.toml     ‚Üê Requiem configuration
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
‚îÇ   ‚îú‚îÄ‚îÄ USR-002.md
‚îÇ   ‚îú‚îÄ‚îÄ SYS-001.md
‚îÇ   ‚îî‚îÄ‚îÄ SYS-002.md
‚îî‚îÄ‚îÄ guides/
    ‚îî‚îÄ‚îÄ user-guide.md
</code></pre>
<h3 id="sphinx-configuration"><a class="header" href="#sphinx-configuration">Sphinx Configuration</a></h3>
<p>Configure Sphinx to use MyST Parser for Markdown:</p>
<p><strong>conf.py</strong>:</p>
<pre><code class="language-python">project = 'My Project'
copyright = '2025, Your Name'
author = 'Your Name'

# Add MyST Parser extension
extensions = ["myst_parser"]

# Exclude non-documentation files
exclude_patterns = [
    '_build',
    'Thumbs.db',
    '.DS_Store',
    'requirements/config.toml',  # Exclude Requiem config
]

# Optional: Configure MyST Parser
myst_enable_extensions = [
    "colon_fence",
    "deflist",
    "tasklist",
]

html_theme = 'alabaster'  # Or your preferred theme
</code></pre>
<h3 id="requiem-configuration-1"><a class="header" href="#requiem-configuration-1">Requiem Configuration</a></h3>
<p>Since requirements live in a subdirectory with other Sphinx content, configure Requiem appropriately:</p>
<p><strong>requirements/config.toml</strong>:</p>
<pre><code class="language-toml">_version = "1"
# Strict mode OK here since requirements are in dedicated directory
allow_unrecognised = false
</code></pre>
<h2 id="including-requirements"><a class="header" href="#including-requirements">Including Requirements</a></h2>
<h3 id="option-1-direct-inclusion-via-table-of-contents"><a class="header" href="#option-1-direct-inclusion-via-table-of-contents">Option 1: Direct Inclusion via Table of Contents</a></h3>
<p>Create a toctree including requirement files:</p>
<p><strong>index.md</strong> (or <strong>index.rst</strong>):</p>
<pre><code class="language-markdown"># Project Documentation

## Contents

```{toctree}
:maxdepth: 2

guides/user-guide
requirements/USR-001
requirements/USR-002
requirements/SYS-001
\```
</code></pre>
<p>Requirements appear as pages in generated documentation.</p>
<h3 id="option-2-include-directive"><a class="header" href="#option-2-include-directive">Option 2: Include Directive</a></h3>
<p>Use the MyST <code>{include}</code> directive to embed requirements:</p>
<p><strong>guides/user-guide.md</strong>:</p>
<pre><code class="language-markdown"># User Guide

## Authentication

Our authentication system satisfies this requirement:

```{include} ../requirements/USR-001.md
:start-line: 6
\```

The `:start-line: 6` skips the YAML frontmatter (adjust based on your frontmatter length).
</code></pre>
<h3 id="option-3-literalinclude-for-requirements"><a class="header" href="#option-3-literalinclude-for-requirements">Option 3: Literalinclude for Requirements</a></h3>
<p>To show requirements as examples:</p>
<p><strong>requirements-format.md</strong>:</p>
<pre><code class="language-markdown"># Requirement Format

Requirements are Markdown files with YAML frontmatter:

```{literalinclude} requirements/USR-001.md
:language: markdown
\```
</code></pre>
<h2 id="working-example-1"><a class="header" href="#working-example-1">Working Example</a></h2>
<p>The Requiem repository includes a complete Sphinx example:</p>
<pre><code class="language-bash">git clone https://github.com/danieleades/requirements-manager
cd requirements-manager/examples/sphinx
</code></pre>
<h3 id="example-structure-1"><a class="header" href="#example-structure-1">Example Structure</a></h3>
<pre><code>examples/sphinx/
‚îú‚îÄ‚îÄ conf.py
‚îú‚îÄ‚îÄ index.md
‚îú‚îÄ‚îÄ requirements/
‚îÇ   ‚îú‚îÄ‚îÄ USR-001.md
‚îÇ   ‚îî‚îÄ‚îÄ USR-002.md
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ README.md
</code></pre>
<h3 id="build-the-example-1"><a class="header" href="#build-the-example-1">Build the Example</a></h3>
<ol>
<li>Install dependencies:</li>
</ol>
<pre><code class="language-bash">uv pip install -r requirements.txt
</code></pre>
<p>Or with pip:</p>
<pre><code class="language-bash">pip install sphinx myst-parser
</code></pre>
<ol start="2">
<li>Build documentation:</li>
</ol>
<pre><code class="language-bash">uv run make html
</code></pre>
<p>Or:</p>
<pre><code class="language-bash">make html
</code></pre>
<ol start="3">
<li>View output:</li>
</ol>
<pre><code class="language-bash"># Open _build/html/index.html in your browser
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<h3 id="1-dedicated-requirements-directory"><a class="header" href="#1-dedicated-requirements-directory">1. Dedicated Requirements Directory</a></h3>
<p>Keep requirements in a separate directory:</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ conf.py
‚îú‚îÄ‚îÄ requirements/          ‚Üê Requirements
‚îÇ   ‚îú‚îÄ‚îÄ config.toml
‚îÇ   ‚îî‚îÄ‚îÄ *.md
‚îî‚îÄ‚îÄ source/               ‚Üê Other docs
    ‚îî‚îÄ‚îÄ *.md
</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Clear separation</li>
<li>Easier Requiem configuration</li>
<li>Simpler to manage</li>
</ul>
<h3 id="2-use-myst-directives"><a class="header" href="#2-use-myst-directives">2. Use MyST Directives</a></h3>
<p>Leverage MyST's powerful directives:</p>
<p><strong>Include with line selection</strong>:</p>
<pre><code class="language-markdown">```{include} requirements/USR-001.md
:start-line: 7
:end-line: 20
\```
</code></pre>
<p><strong>Add captions</strong>:</p>
<pre><code class="language-markdown">```{literalinclude} requirements/USR-001.md
:language: markdown
:caption: USR-001: Email Validation Requirement
\```
</code></pre>
<h3 id="3-create-requirement-indexes"><a class="header" href="#3-create-requirement-indexes">3. Create Requirement Indexes</a></h3>
<p>Generate index pages for requirement types:</p>
<p><strong>requirements/user-requirements.md</strong>:</p>
<pre><code class="language-markdown"># User Requirements

```{toctree}
:maxdepth: 1

USR-001
USR-002
USR-003
\```
</code></pre>
<h3 id="4-cross-reference-with-sphinx-roles"><a class="header" href="#4-cross-reference-with-sphinx-roles">4. Cross-Reference with Sphinx Roles</a></h3>
<p>Use Sphinx's cross-referencing:</p>
<p><strong>guides/user-guide.md</strong>:</p>
<pre><code class="language-markdown">See {doc}`requirements/USR-001` for authentication requirements.
</code></pre>
<p>Sphinx generates proper links.</p>
<h3 id="5-integrate-with-autodoc"><a class="header" href="#5-integrate-with-autodoc">5. Integrate with Autodoc</a></h3>
<p>For Python projects, link code documentation to requirements:</p>
<p><strong>api/auth.py docstring</strong>:</p>
<pre><code class="language-python">def validate_email(email: str) -&gt; bool:
    """Validate email address.

    Implements requirement :doc:`requirements/USR-001`.
    """
    ...
</code></pre>
<h2 id="handling-frontmatter"><a class="header" href="#handling-frontmatter">Handling Frontmatter</a></h2>
<h3 id="problem-yaml-frontmatter-renders-as-code-block"><a class="header" href="#problem-yaml-frontmatter-renders-as-code-block">Problem: YAML Frontmatter Renders as Code Block</a></h3>
<p>Sphinx/MyST renders YAML frontmatter as a code block:</p>
<pre><code>---
_version: '1'
uuid: 4bfeb7d5-...
---
</code></pre>
<p>This is usually undesirable in rendered documentation.</p>
<h3 id="solution-1-skip-frontmatter-with-line-selection"><a class="header" href="#solution-1-skip-frontmatter-with-line-selection">Solution 1: Skip Frontmatter with Line Selection</a></h3>
<pre><code class="language-markdown">```{include} requirements/USR-001.md
:start-line: 7
\```
</code></pre>
<p>Only includes the requirement body, skipping frontmatter.</p>
<p><strong>Determining start line</strong>:
Typical frontmatter structure:</p>
<pre><code>Line 1: ---
Line 2: _version: '1'
Line 3: uuid: ...
Line 4: created: ...
Line 5: ---
Line 6: (empty line)
Line 7: Requirement text starts here
</code></pre>
<p>Use <code>:start-line: 7</code> to skip to content.</p>
<h3 id="solution-2-custom-myst-extension"><a class="header" href="#solution-2-custom-myst-extension">Solution 2: Custom MyST Extension</a></h3>
<p>Create a custom directive that parses frontmatter:</p>
<p><strong>conf.py</strong>:</p>
<pre><code class="language-python">from docutils import nodes
from docutils.parsers.rst import Directive
import yaml

class RequirementDirective(Directive):
    required_arguments = 1  # Requirement file path

    def run(self):
        # Parse requirement file
        # Extract frontmatter and body
        # Render as desired
        ...

def setup(app):
    app.add_directive("requirement", RequirementDirective)
</code></pre>
<p>Usage:</p>
<pre><code class="language-markdown">```{requirement} requirements/USR-001.md
\```
</code></pre>
<p>This allows custom rendering of requirements with frontmatter metadata.</p>
<h3 id="solution-3-preprocessing-script"><a class="header" href="#solution-3-preprocessing-script">Solution 3: Preprocessing Script</a></h3>
<p>Generate requirement markdown without frontmatter:</p>
<p><strong>generate-docs.sh</strong>:</p>
<pre><code class="language-bash">#!/bin/bash
mkdir -p _generated

for req in requirements/*.md; do
    # Skip frontmatter (lines 1-6), extract body
    tail -n +7 "$req" &gt; "_generated/$(basename "$req")"
done
</code></pre>
<p>Then include from <code>_generated/</code>:</p>
<pre><code class="language-markdown">```{include} _generated/USR-001.md
\```
</code></pre>
<h2 id="advanced-integration"><a class="header" href="#advanced-integration">Advanced Integration</a></h2>
<h3 id="requirement-traceability-matrix"><a class="header" href="#requirement-traceability-matrix">Requirement Traceability Matrix</a></h3>
<p>Generate traceability tables with Python scripts:</p>
<p><strong>generate-traceability.py</strong>:</p>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import yaml
import re

def parse_requirement(path):
    with open(path) as f:
        content = f.read()
    # Extract frontmatter
    match = re.match(r'^---\n(.*?)\n---\n(.*)$', content, re.DOTALL)
    if match:
        frontmatter = yaml.safe_load(match.group(1))
        body = match.group(2)
        return frontmatter, body
    return None, content

def generate_matrix():
    matrix = []
    for req_file in glob.glob("requirements/*.md"):
        frontmatter, body = parse_requirement(req_file)
        if frontmatter:
            hrid = req_file.split('/')[-1].replace('.md', '')
            parents = frontmatter.get('parents', [])
            parent_hrids = [p['hrid'] for p in parents]
            matrix.append((hrid, parent_hrids))

    # Generate Markdown table
    print("| Child | Parents |")
    print("|-------|---------|")
    for child, parents in matrix:
        print(f"| {child} | {', '.join(parents) if parents else '-'} |")

if __name__ == '__main__':
    generate_matrix()
</code></pre>
<p>Run before Sphinx build:</p>
<pre><code class="language-bash">python generate-traceability.py &gt; traceability.md
</code></pre>
<p>Include in documentation:</p>
<p><strong>index.md</strong>:</p>
<pre><code class="language-markdown">```{include} traceability.md
\```
</code></pre>
<h3 id="graphviz-diagrams"><a class="header" href="#graphviz-diagrams">Graphviz Diagrams</a></h3>
<p>Generate requirement hierarchy diagrams:</p>
<p><strong>generate-graph.py</strong>:</p>
<pre><code class="language-python">import glob
import yaml
import re

def generate_dot():
    print("digraph requirements {")
    for req_file in glob.glob("requirements/*.md"):
        with open(req_file) as f:
            content = f.read()
        match = re.match(r'^---\n(.*?)\n---', content, re.DOTALL)
        if match:
            frontmatter = yaml.safe_load(match.group(1))
            hrid = req_file.split('/')[-1].replace('.md', '')
            parents = frontmatter.get('parents', [])
            for parent in parents:
                print(f'    "{parent["hrid"]}" -&gt; "{hrid}";')
    print("}")

if __name__ == '__main__':
    generate_dot()
</code></pre>
<p>Generate diagram:</p>
<pre><code class="language-bash">python generate-graph.py | dot -Tpng &gt; hierarchy.png
</code></pre>
<p>Include in Sphinx:</p>
<pre><code class="language-markdown">![Requirement Hierarchy](hierarchy.png)
</code></pre>
<p>Or use Sphinx's <code>graphviz</code> directive:</p>
<p><strong>conf.py</strong>:</p>
<pre><code class="language-python">extensions = ["myst_parser", "sphinx.ext.graphviz"]
</code></pre>
<p><strong>docs/hierarchy.md</strong>:</p>
<pre><code class="language-markdown">```{graphviz}
:caption: Requirement Hierarchy

digraph requirements {
    "USR-001" -&gt; "SYS-001";
    "USR-002" -&gt; "SYS-001";
    "USR-002" -&gt; "SYS-002";
}
\```
</code></pre>
<h2 id="cicd-integration-4"><a class="header" href="#cicd-integration-4">CI/CD Integration</a></h2>
<p>Validate requirements and build docs in CI:</p>
<p><strong>.github/workflows/docs.yml</strong>:</p>
<pre><code class="language-yaml">name: Documentation

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install sphinx myst-parser

      - name: Validate requirements
        run: |
          cargo install requirements-manager
          req clean
        working-directory: ./docs/requirements

      - name: Build documentation
        run: make html
        working-directory: ./docs

      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/_build/html
</code></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="myst-parser-not-found"><a class="header" href="#myst-parser-not-found">MyST Parser Not Found</a></h3>
<p><strong>Error</strong>: <code>Extension error: Could not import extension myst_parser</code></p>
<p><strong>Solution</strong>: Install MyST Parser:</p>
<pre><code class="language-bash">pip install myst-parser
</code></pre>
<h3 id="markdown-files-not-processed"><a class="header" href="#markdown-files-not-processed">Markdown Files Not Processed</a></h3>
<p><strong>Problem</strong>: Markdown files don't appear in generated docs.</p>
<p><strong>Diagnosis</strong>: Check if MyST Parser is in <code>extensions</code> list.</p>
<p><strong>Solution</strong>: Add to <strong>conf.py</strong>:</p>
<pre><code class="language-python">extensions = ["myst_parser"]
</code></pre>
<h3 id="frontmatter-renders-incorrectly"><a class="header" href="#frontmatter-renders-incorrectly">Frontmatter Renders Incorrectly</a></h3>
<p><strong>Problem</strong>: YAML frontmatter shows as code block.</p>
<p><strong>Explanation</strong>: Expected behavior. MyST doesn't parse YAML frontmatter.</p>
<p><strong>Solution</strong>: Use line selection to skip frontmatter (see <a href="integration/sphinx.html#handling-frontmatter">Handling Frontmatter</a>).</p>
<h3 id="include-directive-not-working"><a class="header" href="#include-directive-not-working">Include Directive Not Working</a></h3>
<p><strong>Problem</strong>: <code>{include}</code> directive doesn't embed content.</p>
<p><strong>Diagnosis</strong>: Check file path is correct relative to source file.</p>
<p><strong>Solution</strong>: Use correct relative paths:</p>
<pre><code class="language-markdown">```{include} ../requirements/USR-001.md
\```
</code></pre>
<h2 id="comparison-sphinx-vs-mdbook"><a class="header" href="#comparison-sphinx-vs-mdbook">Comparison: Sphinx vs. MdBook</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Sphinx</th><th>MdBook</th></tr></thead><tbody>
<tr><td><strong>Language</strong></td><td>Python ecosystem</td><td>Rust ecosystem</td></tr>
<tr><td><strong>Markup</strong></td><td>RST + Markdown (via MyST)</td><td>Markdown only</td></tr>
<tr><td><strong>Extensions</strong></td><td>Extensive ecosystem</td><td>Growing ecosystem</td></tr>
<tr><td><strong>API Docs</strong></td><td>Excellent (autodoc)</td><td>Limited</td></tr>
<tr><td><strong>Themes</strong></td><td>Many available</td><td>Fewer options</td></tr>
<tr><td><strong>Speed</strong></td><td>Slower (Python)</td><td>Faster (Rust)</td></tr>
<tr><td><strong>Requirement Integration</strong></td><td>Good with MyST</td><td>Native (both Markdown)</td></tr>
</tbody></table>
</div>
<p><strong>Choose Sphinx if</strong>:</p>
<ul>
<li>Python project</li>
<li>Need autodoc/API documentation</li>
<li>Want extensive extension ecosystem</li>
</ul>
<p><strong>Choose MdBook if</strong>:</p>
<ul>
<li>Rust project</li>
<li>Simpler setup</li>
<li>Pure Markdown workflow</li>
</ul>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p><strong>Key Points</strong>:</p>
<ul>
<li>Use MyST Parser extension for Markdown support</li>
<li>Requirements integrate naturally with MyST directives</li>
<li>Skip frontmatter with line selection (<code>:start-line:</code>)</li>
<li>Generate traceability matrices and diagrams with scripts</li>
<li>Validate requirements in CI before building docs</li>
</ul>
<p><strong>Best Practices</strong>:</p>
<ul>
<li>Dedicated requirements directory</li>
<li>Use MyST directives for rich formatting</li>
<li>Create requirement indexes</li>
<li>Cross-reference with Sphinx roles</li>
<li>Integrate with CI/CD</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>Frontmatter renders as code block (use line selection)</li>
<li>Requires MyST Parser (additional dependency)</li>
<li>Less "native" than MdBook (Sphinx primarily RST)</li>
</ul>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<ul>
<li>Review the <a href="https://github.com/danieleades/requirements-manager/tree/main/examples/sphinx">Sphinx example</a> in the repository</li>
<li>See <a href="integration/./version-control.html">Version Control Best Practices</a> for managing requirements</li>
<li>Compare with <a href="integration/./mdbook.html">Using with MdBook</a> for Rust projects</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="version-control-best-practices"><a class="header" href="#version-control-best-practices">Version Control Best Practices</a></h1>
<p>Requiem's plain-text format makes requirements ideal for version control. This chapter covers Git workflows and best practices.</p>
<h2 id="why-version-control-matters"><a class="header" href="#why-version-control-matters">Why Version Control Matters</a></h2>
<p>Requirements benefit from version control:</p>
<ul>
<li><strong>Complete history</strong>: Track all changes over time</li>
<li><strong>Audit trail</strong>: Know who changed what and when</li>
<li><strong>Branching</strong>: Develop requirements in parallel</li>
<li><strong>Review</strong>: Use pull requests for requirement reviews</li>
<li><strong>Rollback</strong>: Revert problematic changes</li>
<li><strong>Tagging</strong>: Mark requirement baselines (releases)</li>
</ul>
<h2 id="git-basics-for-requirements"><a class="header" href="#git-basics-for-requirements">Git Basics for Requirements</a></h2>
<h3 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h3>
<p>Create a Git repository for your requirements:</p>
<pre><code class="language-bash">mkdir my-requirements
cd my-requirements
git init

# Create first requirement
req add USR
git add config.toml USR-001.md
git commit -m "Initial commit: add USR-001"
</code></pre>
<h3 id="adding-requirements"><a class="header" href="#adding-requirements">Adding Requirements</a></h3>
<p>When creating requirements:</p>
<pre><code class="language-bash"># Create requirement
req add USR

# Stage and commit
git add USR-002.md
git commit -m "Add USR-002: user data export requirement"
</code></pre>
<h3 id="editing-requirements-1"><a class="header" href="#editing-requirements-1">Editing Requirements</a></h3>
<p>When modifying requirements:</p>
<pre><code class="language-bash"># Edit requirement
vim USR-001.md

# Review changes
git diff USR-001.md

# Stage and commit
git add USR-001.md
git commit -m "Update USR-001: clarify email validation format"
</code></pre>
<h3 id="linking-requirements-2"><a class="header" href="#linking-requirements-2">Linking Requirements</a></h3>
<p>When linking requirements:</p>
<pre><code class="language-bash"># Create link
req link SYS-001 USR-001

# Both files change (child gets parent reference)
git diff

# Commit both
git add SYS-001.md
git commit -m "Link SYS-001 to USR-001"
</code></pre>
<h2 id="commit-message-best-practices"><a class="header" href="#commit-message-best-practices">Commit Message Best Practices</a></h2>
<h3 id="format"><a class="header" href="#format">Format</a></h3>
<p>Use clear, descriptive commit messages:</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-bash">git commit -m "update"
git commit -m "fix typo"
git commit -m "changes"
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-bash">git commit -m "Add USR-042: user data export requirement"
git commit -m "Update USR-001: change email validation to RFC 5322"
git commit -m "Link SYS-001 to USR-001 and USR-002"
</code></pre>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<p>Use conventional commit format:</p>
<pre><code>&lt;type&gt;: &lt;HRID&gt;: &lt;description&gt;

[optional body]

[optional footer]
</code></pre>
<p><strong>Types</strong>:</p>
<ul>
<li><code>add</code>: New requirement</li>
<li><code>update</code>: Modify existing requirement</li>
<li><code>link</code>: Create requirement link</li>
<li><code>remove</code>: Delete requirement</li>
<li><code>refactor</code>: Reorganize without changing content</li>
<li><code>docs</code>: Update documentation (non-requirement changes)</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash"># Add new requirement
git commit -m "add: USR-042: user data export"

# Update existing
git commit -m "update: USR-001: clarify email validation

Changed from 'valid email' to 'RFC 5322 compliant'
to remove ambiguity."

# Link requirements
git commit -m "link: SYS-001 -&gt; USR-001, USR-002

SYS-001 satisfies both user requirements for authentication."

# Bulk operation
git commit -m "refactor: reorganize requirements into subdirectories

- Move USR-*.md to user/
- Move SYS-*.md to system/
- Update config.toml"
</code></pre>
<h2 id="branching-strategies"><a class="header" href="#branching-strategies">Branching Strategies</a></h2>
<h3 id="feature-branches"><a class="header" href="#feature-branches">Feature Branches</a></h3>
<p>Develop requirements for new features in branches:</p>
<pre><code class="language-bash"># Create feature branch
git checkout -b feature/payment-system

# Add requirements
req add USR  # USR-042
req add SYS  # SYS-012
# Edit and link requirements

# Commit changes
git add .
git commit -m "add: payment system requirements (USR-042, SYS-012)"

# Push for review
git push origin feature/payment-system
</code></pre>
<h3 id="requirement-change-branches"><a class="header" href="#requirement-change-branches">Requirement Change Branches</a></h3>
<p>For significant requirement changes:</p>
<pre><code class="language-bash"># Create change branch
git checkout -b change/update-usr-001

# Edit requirement
vim USR-001.md

# Update dependent requirements
req clean

# Commit
git add .
git commit -m "update: USR-001: clarify email validation

Updated email validation to reference RFC 5322.
Corrected parent HRIDs in dependent requirements."

# Create pull request
gh pr create
</code></pre>
<h3 id="release-branches"><a class="header" href="#release-branches">Release Branches</a></h3>
<p>Stabilize requirements for releases:</p>
<pre><code class="language-bash"># Create release branch
git checkout -b release/v1.0

# Freeze requirements (no new additions)
# Allow only bug fixes and clarifications

# Tag when stable
git tag v1.0.0
git push origin v1.0.0
</code></pre>
<h2 id="pull-request-workflows"><a class="header" href="#pull-request-workflows">Pull Request Workflows</a></h2>
<h3 id="creating-pull-requests"><a class="header" href="#creating-pull-requests">Creating Pull Requests</a></h3>
<p>When changing requirements:</p>
<ol>
<li><strong>Create branch</strong>:</li>
</ol>
<pre><code class="language-bash">git checkout -b update-auth-requirements
</code></pre>
<ol start="2">
<li><strong>Make changes</strong>:</li>
</ol>
<pre><code class="language-bash">vim USR-001.md
req clean
</code></pre>
<ol start="3">
<li><strong>Commit</strong>:</li>
</ol>
<pre><code class="language-bash">git add -A
git commit -m "update: USR-001: strengthen password requirements"
</code></pre>
<ol start="4">
<li><strong>Push and create PR</strong>:</li>
</ol>
<pre><code class="language-bash">git push origin update-auth-requirements
gh pr create --title "Update authentication requirements" \
             --body "Strengthens password requirements to meet new security policy"
</code></pre>
<h3 id="pr-description-template"><a class="header" href="#pr-description-template">PR Description Template</a></h3>
<p>Use a template for requirement PRs:</p>
<pre><code class="language-markdown">## Summary
Adds/updates/removes requirements for [feature/change].

## Changed Requirements
- USR-001: [description of change]
- SYS-005: [description of change]

## Impact Analysis
- Affects: SYS-001, SYS-003, TST-001
- Reviewed: ‚úì All dependent requirements checked

## Checklist
- [x] `req clean` passes
- [x] Commit messages follow convention
- [x] Dependent requirements reviewed
- [x] Tests updated (if applicable)
- [ ] Approved by: @stakeholder
</code></pre>
<h3 id="reviewing-pull-requests"><a class="header" href="#reviewing-pull-requests">Reviewing Pull Requests</a></h3>
<p>When reviewing requirement PRs:</p>
<ol>
<li><strong>Check diffs carefully</strong>:</li>
</ol>
<pre><code class="language-bash"># Review line-by-line changes
gh pr diff 123
</code></pre>
<ol start="2">
<li><strong>Verify UUIDs unchanged</strong>:</li>
</ol>
<pre><code class="language-bash"># Ensure UUIDs haven't been modified
git diff main..HEAD -- '*.md' | grep 'uuid:'
</code></pre>
<ol start="3">
<li><strong>Check req clean passes</strong>:</li>
</ol>
<pre><code class="language-bash"># Validate requirements
req clean
</code></pre>
<ol start="4">
<li><strong>Review dependent requirements</strong>:</li>
</ol>
<pre><code class="language-bash"># Find affected requirements
grep -r "uuid: &lt;changed-req-uuid&gt;" *.md
</code></pre>
<ol start="5">
<li><strong>Approve and merge</strong>:</li>
</ol>
<pre><code class="language-bash">gh pr review 123 --approve
gh pr merge 123
</code></pre>
<h2 id="handling-conflicts"><a class="header" href="#handling-conflicts">Handling Conflicts</a></h2>
<h3 id="merge-conflicts-in-requirements"><a class="header" href="#merge-conflicts-in-requirements">Merge Conflicts in Requirements</a></h3>
<p>Conflicts occur when two branches modify the same requirement.</p>
<p><strong>Example conflict</strong>:</p>
<pre><code class="language-markdown">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
The system shall validate emails using RFC 5321.
=======
The system shall validate emails using RFC 5322.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/update-email-validation
</code></pre>
<p><strong>Resolution</strong>:</p>
<ol>
<li>
<p><strong>Understand both changes</strong>: Read both versions.</p>
</li>
<li>
<p><strong>Choose or combine</strong>: Decide which is correct or merge both:</p>
</li>
</ol>
<pre><code class="language-markdown">The system shall validate emails using RFC 5322.
</code></pre>
<ol start="3">
<li><strong>Mark resolved</strong>:</li>
</ol>
<pre><code class="language-bash">git add USR-001.md
git commit
</code></pre>
<h3 id="frontmatter-conflicts"><a class="header" href="#frontmatter-conflicts">Frontmatter Conflicts</a></h3>
<p><strong>UUID conflicts</strong> (should never happen):</p>
<pre><code class="language-yaml">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
=======
uuid: 00000000-0000-0000-0000-000000000000
&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-branch
</code></pre>
<p><strong>Resolution</strong>: Keep the original UUID (HEAD). Changing UUIDs breaks traceability.</p>
<p><strong>Parent conflicts</strong> (both branches added parents):</p>
<pre><code class="language-yaml">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
parents:
- uuid: aaaa...
  hrid: USR-001
=======
parents:
- uuid: bbbb...
  hrid: USR-002
&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-branch
</code></pre>
<p><strong>Resolution</strong>: Merge both parents:</p>
<pre><code class="language-yaml">parents:
- uuid: aaaa...
  hrid: USR-001
- uuid: bbbb...
  hrid: USR-002
</code></pre>
<p>Then run:</p>
<pre><code class="language-bash">req clean  # Validate merged result
</code></pre>
<h2 id="tagging-and-releases"><a class="header" href="#tagging-and-releases">Tagging and Releases</a></h2>
<h3 id="creating-baseline-tags"><a class="header" href="#creating-baseline-tags">Creating Baseline Tags</a></h3>
<p>Tag stable requirement sets:</p>
<pre><code class="language-bash"># Tag current state
git tag -a v1.0.0 -m "Release 1.0.0 requirements baseline"
git push origin v1.0.0
</code></pre>
<h3 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h3>
<p>Use semantic versioning:</p>
<ul>
<li><code>v1.0.0</code> - Major release</li>
<li><code>v1.1.0</code> - Minor release (new requirements)</li>
<li><code>v1.0.1</code> - Patch release (clarifications, typo fixes)</li>
</ul>
<p>Or use date-based tags:</p>
<ul>
<li><code>baseline-2025-07-22</code></li>
<li><code>release-2025-q3</code></li>
</ul>
<h3 id="comparing-baselines"><a class="header" href="#comparing-baselines">Comparing Baselines</a></h3>
<p>Compare requirement changes between releases:</p>
<pre><code class="language-bash"># List changed requirements
git diff v1.0.0..v2.0.0 --name-only -- '*.md'

# Show detailed changes
git diff v1.0.0..v2.0.0 -- USR-001.md

# Generate changelog
git log v1.0.0..v2.0.0 --oneline -- '*.md'
</code></pre>
<h2 id="advanced-git-techniques"><a class="header" href="#advanced-git-techniques">Advanced Git Techniques</a></h2>
<h3 id="git-blame-for-requirements"><a class="header" href="#git-blame-for-requirements">Git Blame for Requirements</a></h3>
<p>See who last modified each line:</p>
<pre><code class="language-bash">git blame USR-001.md
</code></pre>
<p>Output:</p>
<pre><code>4bfeb7d5 (Alice  2025-07-20) The system shall validate
a1b2c3d4 (Bob    2025-07-22) user email addresses according
e5f6g7h8 (Alice  2025-07-23) to RFC 5322.
</code></pre>
<h3 id="git-log-for-requirement-history"><a class="header" href="#git-log-for-requirement-history">Git Log for Requirement History</a></h3>
<p>View complete history:</p>
<pre><code class="language-bash"># All commits affecting USR-001
git log -p USR-001.md

# One-line summary
git log --oneline USR-001.md

# Show who, when, what
git log --format="%h %an %ad %s" --date=short -- USR-001.md
</code></pre>
<h3 id="git-diff-for-requirement-changes"><a class="header" href="#git-diff-for-requirement-changes">Git Diff for Requirement Changes</a></h3>
<p>Compare versions:</p>
<pre><code class="language-bash"># Current vs. last commit
git diff HEAD~1 USR-001.md

# Current vs. specific commit
git diff a1b2c3d4 USR-001.md

# Between branches
git diff main..feature/update USR-001.md

# Ignore whitespace
git diff -w USR-001.md
</code></pre>
<h3 id="bisect-to-find-breaking-changes"><a class="header" href="#bisect-to-find-breaking-changes">Bisect to Find Breaking Changes</a></h3>
<p>Find when a requirement changed incorrectly:</p>
<pre><code class="language-bash">git bisect start
git bisect bad HEAD
git bisect good v1.0.0

# Git checks out middle commit
req clean  # Test if requirements are valid
git bisect good  # or 'bad'

# Repeat until found
git bisect reset
</code></pre>
<h2 id="ignoring-files"><a class="header" href="#ignoring-files">Ignoring Files</a></h2>
<h3 id="gitignore-for-requirements-projects"><a class="header" href="#gitignore-for-requirements-projects">.gitignore for Requirements Projects</a></h3>
<p>Exclude generated or temporary files:</p>
<p><strong>.gitignore</strong>:</p>
<pre><code># Requiem temp files
*.tmp

# Editor files
*.swp
*.swo
*~
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Build outputs (if using MdBook/Sphinx)
book/
_build/
_generated/

# Python
__pycache__/
*.pyc
.venv/
</code></pre>
<p><strong>Don't ignore</strong>:</p>
<ul>
<li><code>config.toml</code> (Requiem configuration)</li>
<li><code>*.md</code> (requirements)</li>
</ul>
<h2 id="cicd-integration-5"><a class="header" href="#cicd-integration-5">CI/CD Integration</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>Validate requirements automatically:</p>
<p><strong>.github/workflows/requirements.yml</strong>:</p>
<pre><code class="language-yaml">name: Requirements Validation

on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install Requiem
        run: cargo install requirements-manager

      - name: Validate requirements
        run: req clean
        working-directory: ./requirements

      - name: Check for uncommitted changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "Error: req clean modified files. Run req clean locally."
            git diff
            exit 1
          fi
</code></pre>
<h3 id="pre-commit-hook-1"><a class="header" href="#pre-commit-hook-1">Pre-commit Hook</a></h3>
<p>Validate before every commit:</p>
<p><strong>.git/hooks/pre-commit</strong>:</p>
<pre><code class="language-bash">#!/bin/bash

echo "Validating requirements..."
req clean

if [ $? -ne 0 ]; then
    echo "Error: Requirements validation failed"
    exit 1
fi

# Stage any changes made by req clean
git add -u

exit 0
</code></pre>
<p>Make executable:</p>
<pre><code class="language-bash">chmod +x .git/hooks/pre-commit
</code></pre>
<h2 id="collaboration-best-practices"><a class="header" href="#collaboration-best-practices">Collaboration Best Practices</a></h2>
<h3 id="1-clear-ownership"><a class="header" href="#1-clear-ownership">1. Clear Ownership</a></h3>
<p>Define requirement ownership:</p>
<pre><code class="language-markdown"># CODEOWNERS
# Assign reviewers for requirement changes

requirements/USR-*.md @product-team
requirements/SYS-*.md @architecture-team
requirements/TST-*.md @qa-team
</code></pre>
<h3 id="2-require-reviews"><a class="header" href="#2-require-reviews">2. Require Reviews</a></h3>
<p>Enforce PR reviews:</p>
<p><strong>GitHub branch protection</strong>:</p>
<ul>
<li>Require pull request reviews before merging</li>
<li>Require status checks (req clean) to pass</li>
<li>Require up-to-date branches</li>
</ul>
<h3 id="3-communication"><a class="header" href="#3-communication">3. Communication</a></h3>
<p>Use commit messages and PR descriptions to communicate:</p>
<ul>
<li><strong>Why</strong> the change was made</li>
<li><strong>What</strong> requirements are affected</li>
<li><strong>Who</strong> should review</li>
</ul>
<h3 id="4-regular-syncs"><a class="header" href="#4-regular-syncs">4. Regular Syncs</a></h3>
<p>Prevent divergence:</p>
<pre><code class="language-bash"># Update from main frequently
git checkout feature/my-branch
git pull origin main
git merge main

# Resolve conflicts if any
req clean
</code></pre>
<h3 id="5-atomic-commits"><a class="header" href="#5-atomic-commits">5. Atomic Commits</a></h3>
<p>One logical change per commit:</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-bash"># Single commit with unrelated changes
git commit -m "Add USR-042, update USR-001, fix typo in SYS-003"
</code></pre>
<p><strong>Good</strong>:</p>
<pre><code class="language-bash"># Separate commits
git commit -m "add: USR-042: user data export"
git commit -m "update: USR-001: clarify email validation"
git commit -m "fix: SYS-003: correct typo in authentication flow"
</code></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="large-diffs"><a class="header" href="#large-diffs">Large Diffs</a></h3>
<p><strong>Problem</strong>: Git diffs for requirement files are hard to read.</p>
<p><strong>Solution</strong>: Use word-level diffs:</p>
<pre><code class="language-bash">git diff --word-diff USR-001.md
</code></pre>
<p>Or color-words:</p>
<pre><code class="language-bash">git diff --color-words USR-001.md
</code></pre>
<h3 id="accidental-uuid-changes"><a class="header" href="#accidental-uuid-changes">Accidental UUID Changes</a></h3>
<p><strong>Problem</strong>: Someone accidentally changed a UUID.</p>
<p><strong>Detection</strong>:</p>
<pre><code class="language-bash"># Find UUID changes
git log -p --all -S'uuid:' -- USR-001.md
</code></pre>
<p><strong>Recovery</strong>:</p>
<pre><code class="language-bash"># Restore correct UUID from history
git show a1b2c3d4:USR-001.md | grep 'uuid:'
# Manually fix or revert
</code></pre>
<h3 id="lost-requirements"><a class="header" href="#lost-requirements">Lost Requirements</a></h3>
<p><strong>Problem</strong>: Requirement file was deleted.</p>
<p><strong>Recovery</strong>:</p>
<pre><code class="language-bash"># Find when it was deleted
git log --all --full-history -- USR-099.md

# Restore from last good commit
git checkout a1b2c3d4 -- USR-099.md
</code></pre>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p><strong>Key Practices</strong>:</p>
<ol>
<li><strong>Commit frequently</strong> with clear messages</li>
<li><strong>Use branches</strong> for features and changes</li>
<li><strong>Create PRs</strong> for reviews</li>
<li><strong>Validate</strong> with <code>req clean</code> before committing</li>
<li><strong>Tag releases</strong> for baselines</li>
<li><strong>Review carefully</strong> to catch UUID changes</li>
<li><strong>Resolve conflicts</strong> thoughtfully (never change UUIDs)</li>
<li><strong>Use CI/CD</strong> for automated validation</li>
</ol>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Complete audit trail</li>
<li>Easy collaboration</li>
<li>Reversible changes</li>
<li>Formal review process</li>
<li>Baseline management</li>
</ul>
<p><strong>Common Pitfalls</strong>:</p>
<ul>
<li>Changing UUIDs (breaks traceability)</li>
<li>Poor commit messages (lost context)</li>
<li>Ignoring conflicts (inconsistent requirements)</li>
<li>Skipping validation (invalid requirements reach main)</li>
</ul>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li>Set up <a href="integration/version-control.html#cicd-integration">CI/CD validation</a> for your requirements</li>
<li>Create <a href="integration/version-control.html#commit-message-best-practices">commit message templates</a></li>
<li>Configure <a href="integration/version-control.html#2-require-reviews">branch protection</a></li>
<li>Review <a href="integration/../advanced.html">Advanced Topics</a> for more techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>This chapter covers advanced features and techniques for requirements management with Requiem.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>Advanced topics include:</p>
<ul>
<li><strong><a href="./advanced/coverage.html">Coverage Reports</a></strong> - Traceability coverage analysis (planned)</li>
<li><strong><a href="./advanced/cycles.html">Cycle Detection</a></strong> - Finding circular dependencies (planned)</li>
<li><strong><a href="./advanced/import-export.html">Import and Export</a></strong> - Interoperability with other tools (planned)</li>
</ul>
<h2 id="current-capabilities"><a class="header" href="#current-capabilities">Current Capabilities</a></h2>
<p>Requiem currently provides core functionality:</p>
<ul>
<li>Plain-text requirements in Markdown</li>
<li>Human-readable IDs with namespace support</li>
<li>Parent-child relationships with multiple parents</li>
<li>Content fingerprinting for change detection</li>
<li>Fast parallel loading</li>
<li>Integration with MdBook and Sphinx</li>
</ul>
<h2 id="planned-capabilities"><a class="header" href="#planned-capabilities">Planned Capabilities</a></h2>
<p>Future releases will add:</p>
<ul>
<li><strong>Coverage reports</strong>: Analyze requirement traceability</li>
<li><strong>Cycle detection</strong>: Find and report circular dependencies</li>
<li><strong>Review workflows</strong>: Automated review triggering</li>
<li><strong>Import/export</strong>: ReqIF, JSON, CSV formats</li>
<li><strong>Validation rules</strong>: Custom requirement quality checks</li>
<li><strong>Query language</strong>: Advanced filtering and searching</li>
</ul>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>These features are planned but not yet implemented. Interested in contributing? See the <a href="https://github.com/danieleades/requirements-manager">GitHub repository</a> for:</p>
<ul>
<li>Feature roadmap</li>
<li>Open issues</li>
<li>Contribution guidelines</li>
<li>Development setup</li>
</ul>
<h2 id="workarounds"><a class="header" href="#workarounds">Workarounds</a></h2>
<p>Until advanced features are implemented, consider these approaches:</p>
<h3 id="manual-coverage-analysis"><a class="header" href="#manual-coverage-analysis">Manual Coverage Analysis</a></h3>
<p>Use scripts to analyze traceability:</p>
<pre><code class="language-bash">#!/bin/bash
# Find USR requirements without SYS children

comm -23 \
  &lt;(ls USR-*.md | sed 's/.md//' | sort) \
  &lt;(grep -oh "USR-[0-9]*" SYS-*.md | sort -u)
</code></pre>
<h3 id="manual-cycle-detection"><a class="header" href="#manual-cycle-detection">Manual Cycle Detection</a></h3>
<p>Trace requirement chains manually:</p>
<pre><code class="language-bash"># Follow parent chain
grep "uuid:" USR-001.md  # Get UUID
grep "&lt;uuid&gt;" *.md        # Find children
# Repeat for each child
</code></pre>
<h3 id="export-with-scripts"><a class="header" href="#export-with-scripts">Export with Scripts</a></h3>
<p>Generate reports in various formats:</p>
<pre><code class="language-python">import glob
import yaml
import re
import json

requirements = []
for path in glob.glob("*.md"):
    with open(path) as f:
        content = f.read()
    # Parse frontmatter and body
    # Add to requirements list

# Export as JSON
with open("requirements.json", "w") as f:
    json.dump(requirements, f, indent=2)
</code></pre>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<p>Explore planned features:</p>
<ul>
<li><strong><a href="./advanced/coverage.html">Coverage Reports</a></strong> - What coverage analysis will provide</li>
<li><strong><a href="./advanced/cycles.html">Cycle Detection</a></strong> - How cycle detection will work</li>
<li><strong><a href="./advanced/import-export.html">Import and Export</a></strong> - Planned interoperability formats</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage-reports"><a class="header" href="#coverage-reports">Coverage Reports</a></h1>
<blockquote>
<p><strong>Note</strong>: Coverage reporting is <strong>planned but not yet implemented</strong>. This chapter describes how the feature will work when available.</p>
</blockquote>
<p>Coverage reports analyze requirement traceability, identifying gaps in the requirement hierarchy and ensuring all requirements are properly traced.</p>
<h2 id="what-is-coverage"><a class="header" href="#what-is-coverage">What is Coverage?</a></h2>
<p>Coverage measures how completely requirements are traced across levels:</p>
<ul>
<li><strong>Downstream coverage</strong>: Do all user requirements have system requirements?</li>
<li><strong>Upstream coverage</strong>: Do all test cases trace to requirements?</li>
<li><strong>Bidirectional traceability</strong>: Can you trace from user needs to implementation and tests?</li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code>USR-001 ‚Üê User requirement
  ‚îú‚îÄ SYS-001 ‚Üê System requirement (traced)
  ‚îî‚îÄ SYS-002 ‚Üê System requirement (traced)

USR-002 ‚Üê User requirement
  ‚îî‚îÄ (no children) ‚Üê Coverage gap!

SYS-003 ‚Üê System requirement
  ‚îî‚îÄ (no parents) ‚Üê Orphan requirement!
</code></pre>
<p><strong>Coverage report identifies</strong>:</p>
<ul>
<li>USR-002 has no system requirements (gap)</li>
<li>SYS-003 has no parent (orphan)</li>
</ul>
<h2 id="planned-functionality"><a class="header" href="#planned-functionality">Planned Functionality</a></h2>
<h3 id="coverage-analysis-command"><a class="header" href="#coverage-analysis-command">Coverage Analysis Command</a></h3>
<pre><code class="language-bash">req coverage
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Coverage Report

User Requirements (USR):
  Total: 25
  With children: 23 (92%)
  Without children: 2 (8%)
    - USR-002: User data export
    - USR-018: Password recovery

System Requirements (SYS):
  Total: 47
  With parents: 45 (96%)
  With children: 43 (91%)
  Orphans: 2 (4%)
    - SYS-003: Logging service
    - SYS-029: Cache invalidation

Test Cases (TST):
  Total: 156
  With parents: 150 (96%)
  Orphans: 6 (4%)

Overall Coverage: 93%
</code></pre>
<h3 id="coverage-by-kind"><a class="header" href="#coverage-by-kind">Coverage by Kind</a></h3>
<p>Analyze specific requirement kinds:</p>
<pre><code class="language-bash">req coverage --kind USR
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>User Requirement Coverage

Total: 25

With children: 23 (92%)
  USR-001 ‚Üí SYS-001, SYS-002
  USR-003 ‚Üí SYS-005, SYS-006, SYS-007
  ...

Without children (gaps): 2 (8%)
  USR-002: User data export
  USR-018: Password recovery

Recommendation: Add system requirements for USR-002 and USR-018
</code></pre>
<h3 id="detailed-reports"><a class="header" href="#detailed-reports">Detailed Reports</a></h3>
<p>Generate detailed coverage information:</p>
<pre><code class="language-bash">req coverage --detailed &gt; coverage-report.md
</code></pre>
<p><strong>Output format</strong> (Markdown):</p>
<pre><code class="language-markdown"># Coverage Report

## Summary
- User Requirements: 92% covered
- System Requirements: 96% traced upstream, 91% traced downstream
- Tests: 96% traced

## Gaps

### User Requirements Without Children
- **USR-002**: User data export
  - Status: No system requirements
  - Action: Create SYS requirements

- **USR-018**: Password recovery
  - Status: No system requirements
  - Action: Create SYS requirements

### Orphan System Requirements
- **SYS-003**: Logging service
  - Status: No parent requirement
  - Action: Link to USR requirement or remove

...
</code></pre>
<h3 id="visual-reports"><a class="header" href="#visual-reports">Visual Reports</a></h3>
<p>Generate coverage diagrams:</p>
<pre><code class="language-bash">req coverage --format html &gt; coverage.html
</code></pre>
<p><strong>Features</strong>:</p>
<ul>
<li>Interactive traceability matrix</li>
<li>Heatmap showing coverage density</li>
<li>Clickable requirement links</li>
<li>Filterable by kind, tag, or namespace</li>
</ul>
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<h3 id="use-case-1-requirement-review"><a class="header" href="#use-case-1-requirement-review">Use Case 1: Requirement Review</a></h3>
<p><strong>Scenario</strong>: Preparing for a requirements review.</p>
<p><strong>Goal</strong>: Identify incomplete traceability.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Generate coverage report
req coverage --detailed &gt; review-report.md

# Review gaps
# - USR-002: No system requirements
# - SYS-003: Orphan requirement

# Fix gaps
req add SYS --parent USR-002  # Add missing SYS requirement
req link SYS-003 USR-007      # Link orphan to parent

# Verify
req coverage
# Coverage improved to 100%
</code></pre>
<h3 id="use-case-2-release-readiness-1"><a class="header" href="#use-case-2-release-readiness-1">Use Case 2: Release Readiness</a></h3>
<p><strong>Scenario</strong>: Ensuring all requirements are traced before release.</p>
<p><strong>Goal</strong>: 100% coverage required for release.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Check coverage
req coverage --minimum 100

# Output (if &lt; 100%):
# Error: Coverage is 93%, minimum required is 100%
# Gaps:
#   - USR-002: No children
#   - USR-018: No children
#   - SYS-003: No parent

# Fix gaps...

# Verify
req coverage --minimum 100
# Success: Coverage is 100%
</code></pre>
<h3 id="use-case-3-compliance-audit"><a class="header" href="#use-case-3-compliance-audit">Use Case 3: Compliance Audit</a></h3>
<p><strong>Scenario</strong>: Demonstrating traceability for compliance audit.</p>
<p><strong>Goal</strong>: Prove all user requirements are traced to implementation and tests.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Generate audit report
req coverage --audit \
  --trace-from USR \
  --trace-to TST \
  --output audit-report.pdf

# Report shows:
# - Complete traceability chain: USR ‚Üí SYS ‚Üí SWR ‚Üí TST
# - No gaps
# - All requirements covered
</code></pre>
<h2 id="configuration-planned-1"><a class="header" href="#configuration-planned-1">Configuration (Planned)</a></h2>
<h3 id="coverage-rules"><a class="header" href="#coverage-rules">Coverage Rules</a></h3>
<pre><code class="language-toml"># config.toml (planned)
[coverage]
# Minimum coverage percentage required
minimum = 95

# Require specific kinds to have children
require_children = ["USR", "SYS"]

# Require specific kinds to have parents
require_parents = ["SYS", "SWR", "TST"]

# Allowed to have no children (leaf requirements)
leaf_kinds = ["TST", "DOC"]

# Allowed to have no parents (root requirements)
root_kinds = ["USR"]
</code></pre>
<h3 id="coverage-thresholds"><a class="header" href="#coverage-thresholds">Coverage Thresholds</a></h3>
<pre><code class="language-toml">[coverage.thresholds]
# Per-kind minimum coverage
USR = 100  # All user requirements must have children
SYS = 95   # 95% of system requirements must have children
SWR = 90   # 90% of software requirements must have children
TST = 100  # All tests must have parents
</code></pre>
<h2 id="report-formats"><a class="header" href="#report-formats">Report Formats</a></h2>
<h3 id="plain-text"><a class="header" href="#plain-text">Plain Text</a></h3>
<p>Simple text output:</p>
<pre><code class="language-bash">req coverage
</code></pre>
<h3 id="markdown"><a class="header" href="#markdown">Markdown</a></h3>
<p>Detailed Markdown report:</p>
<pre><code class="language-bash">req coverage --format markdown &gt; coverage.md
</code></pre>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<p>Interactive HTML dashboard:</p>
<pre><code class="language-bash">req coverage --format html &gt; coverage.html
</code></pre>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>Machine-readable output:</p>
<pre><code class="language-bash">req coverage --format json &gt; coverage.json
</code></pre>
<p><strong>Example JSON</strong>:</p>
<pre><code class="language-json">{
  "timestamp": "2025-07-22T12:00:00Z",
  "overall_coverage": 93,
  "by_kind": {
    "USR": {
      "total": 25,
      "with_children": 23,
      "without_children": 2,
      "coverage": 92
    },
    "SYS": {
      "total": 47,
      "with_parents": 45,
      "with_children": 43,
      "coverage": 96
    }
  },
  "gaps": [
    {
      "hrid": "USR-002",
      "type": "no_children",
      "description": "User data export"
    }
  ]
}
</code></pre>
<h3 id="csv"><a class="header" href="#csv">CSV</a></h3>
<p>Spreadsheet-compatible output:</p>
<pre><code class="language-bash">req coverage --format csv &gt; coverage.csv
</code></pre>
<h2 id="traceability-matrix"><a class="header" href="#traceability-matrix">Traceability Matrix</a></h2>
<p>Generate traceability matrices showing parent-child relationships:</p>
<pre><code class="language-bash">req coverage --matrix
</code></pre>
<p><strong>Output</strong> (simplified):</p>
<pre><code>         | USR-001 | USR-002 | USR-003
---------|---------|---------|---------
SYS-001  |    X    |         |
SYS-002  |    X    |         |    X
SYS-003  |         |         |
SYS-004  |         |         |    X
</code></pre>
<p><strong>Features</strong>:</p>
<ul>
<li>Rows: Child requirements</li>
<li>Columns: Parent requirements</li>
<li>X: Link exists</li>
<li>Empty: No link</li>
<li>Highlights gaps and orphans</li>
</ul>
<h2 id="integration-2"><a class="header" href="#integration-2">Integration</a></h2>
<h3 id="cicd"><a class="header" href="#cicd">CI/CD</a></h3>
<p>Enforce coverage in CI:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml (planned)
- name: Check requirement coverage
  run: |
    req coverage --minimum 95
    if [ $? -ne 0 ]; then
      echo "Coverage below minimum"
      req coverage --detailed
      exit 1
    fi
</code></pre>
<h3 id="pull-request-comments"><a class="header" href="#pull-request-comments">Pull Request Comments</a></h3>
<p>Automatically comment on PRs with coverage impact:</p>
<pre><code class="language-yaml">- name: Coverage report
  run: |
    req coverage --format markdown &gt; coverage.md
    gh pr comment ${{ github.event.number }} --body-file coverage.md
</code></pre>
<h3 id="dashboard-integration"><a class="header" href="#dashboard-integration">Dashboard Integration</a></h3>
<p>Export coverage to dashboards:</p>
<pre><code class="language-bash"># Export for Grafana/Prometheus
req coverage --format prometheus &gt; metrics.txt
</code></pre>
<h2 id="metrics-planned"><a class="header" href="#metrics-planned">Metrics (Planned)</a></h2>
<h3 id="coverage-percentage"><a class="header" href="#coverage-percentage">Coverage Percentage</a></h3>
<pre><code>coverage = (requirements_with_links / total_requirements) * 100
</code></pre>
<h3 id="downstream-coverage"><a class="header" href="#downstream-coverage">Downstream Coverage</a></h3>
<pre><code>downstream_coverage = (parents_with_children / total_parents) * 100
</code></pre>
<h3 id="upstream-coverage"><a class="header" href="#upstream-coverage">Upstream Coverage</a></h3>
<pre><code>upstream_coverage = (children_with_parents / total_children) * 100
</code></pre>
<h3 id="orphan-rate"><a class="header" href="#orphan-rate">Orphan Rate</a></h3>
<pre><code>orphan_rate = (requirements_without_parents / total_requirements) * 100
</code></pre>
<h2 id="workarounds-until-implemented"><a class="header" href="#workarounds-until-implemented">Workarounds (Until Implemented)</a></h2>
<p>Manual coverage analysis:</p>
<h3 id="script-to-find-gaps"><a class="header" href="#script-to-find-gaps">Script to Find Gaps</a></h3>
<pre><code class="language-bash">#!/bin/bash
# find-gaps.sh

echo "USR requirements without SYS children:"
comm -23 \
  &lt;(ls USR-*.md | sed 's/.md//' | sort) \
  &lt;(grep -oh "USR-[0-9]*" SYS-*.md | sort -u)

echo ""
echo "SYS requirements without parents:"
for sys in SYS-*.md; do
    if ! grep -q "parents:" "$sys"; then
        echo "  $(basename "$sys" .md)"
    fi
done
</code></pre>
<h3 id="spreadsheet-analysis"><a class="header" href="#spreadsheet-analysis">Spreadsheet Analysis</a></h3>
<p>Create a spreadsheet:</p>
<div class="table-wrapper"><table><thead><tr><th>Requirement</th><th>Has Parents</th><th>Has Children</th><th>Coverage</th></tr></thead><tbody>
<tr><td>USR-001</td><td>N/A</td><td>Yes</td><td>‚úì</td></tr>
<tr><td>USR-002</td><td>N/A</td><td>No</td><td>‚úó</td></tr>
<tr><td>SYS-001</td><td>Yes</td><td>Yes</td><td>‚úì</td></tr>
<tr><td>SYS-003</td><td>No</td><td>No</td><td>‚úó</td></tr>
</tbody></table>
</div>
<p>Track manually until coverage reporting is implemented.</p>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p><strong>Planned functionality</strong>:</p>
<ul>
<li>Coverage percentage by requirement kind</li>
<li>Gap identification (requirements without parents/children)</li>
<li>Orphan detection</li>
<li>Traceability matrices</li>
<li>Multiple report formats (text, Markdown, HTML, JSON, CSV)</li>
<li>CI/CD integration</li>
<li>Configurable coverage thresholds</li>
</ul>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Requirement reviews</li>
<li>Release readiness checks</li>
<li>Compliance audits</li>
<li>Quality assurance</li>
</ul>
<p><strong>Timeline</strong>: Implementation planned for future release</p>
<h2 id="next-steps-22"><a class="header" href="#next-steps-22">Next Steps</a></h2>
<ul>
<li>Use <a href="advanced/coverage.html#workarounds-until-implemented">workarounds</a> for manual coverage analysis</li>
<li>Plan your <a href="advanced/coverage.html#configuration-planned">coverage requirements</a> for when feature is available</li>
<li>See <a href="advanced/./cycles.html">Cycle Detection</a> for finding circular dependencies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle Detection</a></h1>
<blockquote>
<p><strong>Note</strong>: Cycle detection is <strong>planned but not yet implemented</strong>. This chapter describes how the feature will work when available.</p>
</blockquote>
<p>Cycle detection identifies circular dependencies in requirement graphs, which are usually errors that break valid traceability hierarchies.</p>
<h2 id="what-are-cycles"><a class="header" href="#what-are-cycles">What are Cycles?</a></h2>
<p>A cycle occurs when requirements form a circular dependency chain:</p>
<pre><code>USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001
</code></pre>
<p>Requirements form a loop: USR-001 depends on SYS-001, which depends on SYS-002, which depends back on USR-001.</p>
<h3 id="why-cycles-are-problematic"><a class="header" href="#why-cycles-are-problematic">Why Cycles are Problematic</a></h3>
<p><strong>Break hierarchy assumptions</strong>:</p>
<ul>
<li>Requirements should form a Directed Acyclic Graph (DAG)</li>
<li>Cycles violate DAG properties</li>
</ul>
<p><strong>Logical impossibility</strong>:</p>
<ul>
<li>A cannot be satisfied until B is satisfied</li>
<li>B cannot be satisfied until C is satisfied</li>
<li>C cannot be satisfied until A is satisfied</li>
<li>Nothing can be satisfied!</li>
</ul>
<p><strong>Review complexity</strong>:</p>
<ul>
<li>Changes propagate indefinitely</li>
<li>Impossible to determine impact</li>
</ul>
<p><strong>Compliance issues</strong>:</p>
<ul>
<li>Many standards require acyclic traceability</li>
<li>Auditors expect clear hierarchies</li>
</ul>
<h2 id="example-cycles"><a class="header" href="#example-cycles">Example Cycles</a></h2>
<h3 id="simple-cycle-2-requirements"><a class="header" href="#simple-cycle-2-requirements">Simple Cycle (2 requirements)</a></h3>
<pre><code>USR-001 ‚Üí SYS-001 ‚Üí USR-001
</code></pre>
<p><strong>Why it happens</strong>: Accidental bi-directional linking.</p>
<p><strong>Detection</strong>: SYS-001 lists USR-001 as parent; USR-001 lists SYS-001 as parent.</p>
<h3 id="complex-cycle-3-requirements"><a class="header" href="#complex-cycle-3-requirements">Complex Cycle (3+ requirements)</a></h3>
<pre><code>USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí SWR-001 ‚Üí USR-001
</code></pre>
<p><strong>Why it happens</strong>: Accumulation of links over time without oversight.</p>
<p><strong>Detection</strong>: Following parent chain eventually returns to starting requirement.</p>
<h3 id="self-reference"><a class="header" href="#self-reference">Self-Reference</a></h3>
<pre><code>USR-001 ‚Üí USR-001
</code></pre>
<p><strong>Why it happens</strong>: Data entry error.</p>
<p><strong>Detection</strong>: Requirement lists itself as a parent.</p>
<h2 id="planned-functionality-1"><a class="header" href="#planned-functionality-1">Planned Functionality</a></h2>
<h3 id="cycle-detection-command"><a class="header" href="#cycle-detection-command">Cycle Detection Command</a></h3>
<pre><code class="language-bash">req check-cycles
</code></pre>
<p><strong>Output</strong> (if cycles found):</p>
<pre><code>Error: Cycles detected in requirement graph

Cycle 1 (length 3):
  USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001

Cycle 2 (length 2):
  SYS-005 ‚Üí SWR-003 ‚Üí SYS-005

Cycle 3 (self-reference):
  SWR-012 ‚Üí SWR-012

Total cycles: 3

Fix these cycles to ensure valid traceability.
</code></pre>
<p><strong>Output</strong> (no cycles):</p>
<pre><code>No cycles detected. Requirement graph is acyclic.
</code></pre>
<h3 id="detailed-cycle-information"><a class="header" href="#detailed-cycle-information">Detailed Cycle Information</a></h3>
<pre><code class="language-bash">req check-cycles --detailed
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Cycle 1:
  Path: USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001
  Length: 3
  Requirements involved:
    - USR-001: User authentication
      Parent: SYS-002 (creates cycle)
    - SYS-001: Authentication service
      Parent: USR-001
    - SYS-002: Session management
      Parent: SYS-001

  Suggested fix:
    Remove parent link from USR-001 to SYS-002
    (User requirements should not depend on system requirements)
</code></pre>
<h3 id="visualization"><a class="header" href="#visualization">Visualization</a></h3>
<p>Generate cycle diagrams:</p>
<pre><code class="language-bash">req check-cycles --visualize &gt; cycles.dot
dot -Tpng cycles.dot -o cycles.png
</code></pre>
<p><strong>Output</strong>: Graph highlighting cyclic paths in red.</p>
<h2 id="how-detection-works"><a class="header" href="#how-detection-works">How Detection Works</a></h2>
<h3 id="algorithm-depth-first-search"><a class="header" href="#algorithm-depth-first-search">Algorithm: Depth-First Search</a></h3>
<p>Requiem will use DFS with cycle detection:</p>
<ol>
<li><strong>Start from each requirement</strong></li>
<li><strong>Follow parent links</strong> (or child links for reverse traversal)</li>
<li><strong>Track visited requirements</strong> in current path</li>
<li><strong>If revisit a requirement in current path</strong>: Cycle detected</li>
<li><strong>Report cycle</strong>: Full path from requirement back to itself</li>
</ol>
<h3 id="example-walkthrough"><a class="header" href="#example-walkthrough">Example Walkthrough</a></h3>
<p>Requirements:</p>
<pre><code>USR-001 ‚Üí SYS-001
SYS-001 ‚Üí SYS-002
SYS-002 ‚Üí USR-001  (creates cycle)
</code></pre>
<p><strong>Detection</strong>:</p>
<pre><code>1. Start at USR-001
2. Visit SYS-001 (parent of USR-001)
3. Visit SYS-002 (parent of SYS-001)
4. Visit USR-001 (parent of SYS-002)
5. USR-001 is already in path ‚Üí Cycle detected!
6. Report: USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001
</code></pre>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<ul>
<li><strong>Time complexity</strong>: O(V + E) where V = requirements, E = links</li>
<li><strong>Expected runtime</strong>: Milliseconds for 1000s of requirements</li>
<li><strong>Parallel detection</strong>: Possible for disconnected subgraphs</li>
</ul>
<h2 id="use-cases-4"><a class="header" href="#use-cases-4">Use Cases</a></h2>
<h3 id="use-case-1-continuous-validation"><a class="header" href="#use-case-1-continuous-validation">Use Case 1: Continuous Validation</a></h3>
<p><strong>Scenario</strong>: Automatically check for cycles in CI.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-yaml"># .github/workflows/requirements.yml (planned)
- name: Check for cycles
  run: |
    req check-cycles
    if [ $? -ne 0 ]; then
      echo "Cycles detected!"
      req check-cycles --detailed
      exit 1
    fi
</code></pre>
<p><strong>Benefit</strong>: Cycles are caught before merging.</p>
<h3 id="use-case-2-fixing-legacy-requirements"><a class="header" href="#use-case-2-fixing-legacy-requirements">Use Case 2: Fixing Legacy Requirements</a></h3>
<p><strong>Scenario</strong>: Inherited a requirement set with unknown quality.</p>
<p><strong>Goal</strong>: Find and fix all cycles.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Detect cycles
req check-cycles --detailed

# Output:
# Cycle 1: USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001
# Suggested fix: Remove link from USR-001 to SYS-002

# Fix cycle
vim USR-001.md  # Remove SYS-002 from parents

# Verify
req check-cycles
# No cycles detected
</code></pre>
<h3 id="use-case-3-incremental-checking"><a class="header" href="#use-case-3-incremental-checking">Use Case 3: Incremental Checking</a></h3>
<p><strong>Scenario</strong>: Adding a new link between requirements.</p>
<p><strong>Goal</strong>: Ensure the new link doesn't create a cycle.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Add link
req link SWR-001 SYS-005

# Check if cycle created
req check-cycles

# If cycle:
# Error: Cycle detected: SYS-005 ‚Üí ... ‚Üí SWR-001 ‚Üí SYS-005

# If no cycle:
# No cycles detected
</code></pre>
<p><strong>Benefit</strong>: Immediate feedback; don't commit cycle-inducing links.</p>
<h2 id="breaking-cycles"><a class="header" href="#breaking-cycles">Breaking Cycles</a></h2>
<h3 id="strategy-1-remove-link"><a class="header" href="#strategy-1-remove-link">Strategy 1: Remove Link</a></h3>
<p>Identify the "weakest" link in the cycle and remove it:</p>
<pre><code>USR-001 ‚Üí SYS-001 ‚Üí SYS-002 ‚Üí USR-001
                               ^^^^^^^
                        Remove this link
</code></pre>
<p><strong>Criteria for "weakest"</strong>:</p>
<ul>
<li>Violates hierarchy (e.g., user requirement depending on system requirement)</li>
<li>Accidental or incorrect</li>
<li>Least impactful to remove</li>
</ul>
<h3 id="strategy-2-reverse-hierarchy"><a class="header" href="#strategy-2-reverse-hierarchy">Strategy 2: Reverse Hierarchy</a></h3>
<p>If requirements are at wrong levels, reassign:</p>
<pre><code>Before (cycle):
  USR-001 ‚Üí SYS-001
  SYS-001 ‚Üí USR-002
  USR-002 ‚Üí USR-001

After (fixed):
  USR-001, USR-002 ‚Üí SYS-001
  (SYS-001 now has both as parents; no cycle)
</code></pre>
<h3 id="strategy-3-introduce-intermediate-requirement"><a class="header" href="#strategy-3-introduce-intermediate-requirement">Strategy 3: Introduce Intermediate Requirement</a></h3>
<p>Break cycle by adding a requirement:</p>
<pre><code>Before (cycle):
  USR-001 ‚Üí SYS-001 ‚Üí USR-001

After (fixed):
  USR-001 ‚Üí SYS-001 ‚Üí SYS-002
  (SYS-002 is new, breaks cycle)
</code></pre>
<h3 id="strategy-4-merge-requirements"><a class="header" href="#strategy-4-merge-requirements">Strategy 4: Merge Requirements</a></h3>
<p>If cycle indicates redundancy, merge:</p>
<pre><code>Before (cycle):
  REQ-A ‚Üí REQ-B ‚Üí REQ-A

After (merged):
  REQ-AB (combines A and B; no cycle)
</code></pre>
<h2 id="configuration-planned-2"><a class="header" href="#configuration-planned-2">Configuration (Planned)</a></h2>
<h3 id="enabledisable-cycle-checking"><a class="header" href="#enabledisable-cycle-checking">Enable/Disable Cycle Checking</a></h3>
<pre><code class="language-toml"># config.toml (planned)
[cycles]
# Enable cycle detection
enabled = true

# Fail on cycle detection (exit with error)
fail_on_cycle = true

# Report self-references separately
detect_self_references = true
</code></pre>
<h3 id="ci-integration"><a class="header" href="#ci-integration">CI Integration</a></h3>
<pre><code class="language-toml">[cycles.ci]
# Run cycle detection in CI
enabled = true

# Block merge if cycles detected
block_on_cycle = true
</code></pre>
<h2 id="exceptions-planned"><a class="header" href="#exceptions-planned">Exceptions (Planned)</a></h2>
<p>In rare cases, cycles might be intentional. Allow marking exceptions:</p>
<pre><code class="language-yaml"># USR-001.md (hypothetical)
---
_version: '1'
uuid: ...
parents:
- uuid: ...
  hrid: SYS-002
  cycle_exception: true  # Mark as intentional cycle
---
</code></pre>
<p>Or in config:</p>
<pre><code class="language-toml">[cycles.exceptions]
# Allow specific cycles
allowed = [
    ["USR-001", "SYS-001", "USR-001"],
]
</code></pre>
<p><strong>Use sparingly</strong>: Cycles are almost always errors.</p>
<h2 id="related-features"><a class="header" href="#related-features">Related Features</a></h2>
<h3 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h3>
<p>After ensuring no cycles, enable topological sorting:</p>
<pre><code class="language-bash">req sort --topological
</code></pre>
<p><strong>Output</strong>: Requirements in dependency order (parents before children).</p>
<p><strong>Use case</strong>: Determine implementation order.</p>
<h3 id="dependency-depth"><a class="header" href="#dependency-depth">Dependency Depth</a></h3>
<p>Analyze requirement depth in hierarchy:</p>
<pre><code class="language-bash">req depth USR-001
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>USR-001:
  Depth: 0 (root requirement)
  Max descendant depth: 4

  Path to deepest descendant:
    USR-001 ‚Üí SYS-001 ‚Üí SWR-003 ‚Üí TST-012
</code></pre>
<h2 id="workarounds-until-implemented-1"><a class="header" href="#workarounds-until-implemented-1">Workarounds (Until Implemented)</a></h2>
<p>Manual cycle detection:</p>
<h3 id="script-to-detect-simple-cycles"><a class="header" href="#script-to-detect-simple-cycles">Script to Detect Simple Cycles</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import yaml
import re

def parse_requirement(path):
    with open(path) as f:
        content = f.read()
    match = re.match(r'^---\n(.*?)\n---', content, re.DOTALL)
    if match:
        frontmatter = yaml.safe_load(match.group(1))
        return frontmatter
    return None

def find_cycles():
    # Build graph
    graph = {}
    for req_file in glob.glob("*.md"):
        hrid = req_file.replace('.md', '')
        frontmatter = parse_requirement(req_file)
        if frontmatter:
            parents = frontmatter.get('parents', [])
            parent_hrids = [p['hrid'] for p in parents]
            graph[hrid] = parent_hrids

    # Detect cycles with DFS
    def visit(req, path):
        if req in path:
            cycle = path[path.index(req):] + [req]
            print(f"Cycle detected: {' ‚Üí '.join(cycle)}")
            return True
        if req not in graph:
            return False
        for parent in graph[req]:
            if visit(parent, path + [req]):
                return True
        return False

    for req in graph:
        visit(req, [])

if __name__ == '__main__':
    find_cycles()
</code></pre>
<p>Run:</p>
<pre><code class="language-bash">python detect-cycles.py
</code></pre>
<h3 id="manual-inspection"><a class="header" href="#manual-inspection">Manual Inspection</a></h3>
<p>For small requirement sets, manually trace parent chains:</p>
<ol>
<li>Pick a requirement (e.g., USR-001)</li>
<li>Follow parent links</li>
<li>Track visited requirements</li>
<li>If you return to the starting requirement, cycle exists</li>
</ol>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p><strong>Key concepts</strong>:</p>
<ul>
<li><strong>Cycle</strong>: Circular dependency chain in requirement graph</li>
<li><strong>Problem</strong>: Breaks hierarchy, causes logical impossibility</li>
<li><strong>Detection</strong>: Depth-first search with path tracking</li>
<li><strong>Resolution</strong>: Remove links, reverse hierarchy, introduce intermediate requirements</li>
</ul>
<p><strong>Planned functionality</strong>:</p>
<ul>
<li>Automatic cycle detection</li>
<li>Detailed cycle reports with suggested fixes</li>
<li>Visualization of cyclic paths</li>
<li>CI/CD integration</li>
<li>Configurable checking</li>
</ul>
<p><strong>Use cases</strong>:</p>
<ul>
<li>CI validation</li>
<li>Legacy requirement cleanup</li>
<li>Incremental validation</li>
</ul>
<p><strong>Timeline</strong>: Implementation planned for future release</p>
<h2 id="next-steps-23"><a class="header" href="#next-steps-23">Next Steps</a></h2>
<ul>
<li>Use <a href="advanced/cycles.html#workarounds-until-implemented">workarounds</a> for manual cycle detection</li>
<li>Plan your <a href="advanced/cycles.html#configuration-planned">cycle detection requirements</a> for when feature is available</li>
<li>See <a href="advanced/./coverage.html">Coverage Reports</a> for traceability analysis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<blockquote>
<p><strong>Note</strong>: Import and export features are <strong>planned but not yet implemented</strong>. This chapter describes how these features will work when available.</p>
</blockquote>
<p>Import and export enable interoperability with other requirements management tools and formats.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>Planned import/export formats:</p>
<ul>
<li><strong>ReqIF</strong>: Requirements Interchange Format (OMG standard)</li>
<li><strong>JSON</strong>: Machine-readable format for custom tools</li>
<li><strong>CSV</strong>: Spreadsheet format for analysis</li>
<li><strong>Doorstop YAML</strong>: Migrate from Doorstop projects</li>
<li><strong>HTML</strong>: Human-readable export for documentation</li>
<li><strong>PDF</strong>: Formal document generation</li>
</ul>
<h2 id="why-importexport-matters"><a class="header" href="#why-importexport-matters">Why Import/Export Matters</a></h2>
<p><strong>Migration</strong>: Move requirements from other tools to Requiem</p>
<p><strong>Integration</strong>: Exchange requirements with other systems</p>
<p><strong>Analysis</strong>: Export to spreadsheets for custom analysis</p>
<p><strong>Documentation</strong>: Generate formal requirement documents</p>
<p><strong>Backup</strong>: Archive requirements in multiple formats</p>
<p><strong>Compliance</strong>: Provide requirements in auditor-requested formats</p>
<h2 id="export-functionality"><a class="header" href="#export-functionality">Export Functionality</a></h2>
<h3 id="export-to-json"><a class="header" href="#export-to-json">Export to JSON</a></h3>
<pre><code class="language-bash">req export --format json --output requirements.json
</code></pre>
<p><strong>Output format</strong>:</p>
<pre><code class="language-json">{
  "version": "1",
  "exported_at": "2025-07-22T12:00:00Z",
  "requirements": [
    {
      "hrid": "USR-001",
      "uuid": "4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a",
      "created": "2025-07-22T10:00:00Z",
      "content": "The system shall validate...",
      "tags": ["authentication", "security"],
      "parents": [
        {
          "uuid": "3fc6800c-5acc-457e-baf9-a29b42b663fd",
          "hrid": "USR-002",
          "fingerprint": "e533784ff58c16cbf08e436cb06f09e0..."
        }
      ]
    }
  ]
}
</code></pre>
<h3 id="export-to-csv"><a class="header" href="#export-to-csv">Export to CSV</a></h3>
<pre><code class="language-bash">req export --format csv --output requirements.csv
</code></pre>
<p><strong>Output format</strong>:</p>
<pre><code class="language-csv">HRID,UUID,Created,Content,Tags,Parents
USR-001,4bfeb7d5-...,2025-07-22T10:00:00Z,"The system shall...","authentication,security","USR-002"
USR-002,3fc6800c-...,2025-07-22T09:00:00Z,"Users shall be able to...","",""
SYS-001,81e63bac-...,2025-07-22T11:00:00Z,"The authentication service...","","USR-001,USR-002"
</code></pre>
<p>Open in Excel, Google Sheets, or other spreadsheet tools.</p>
<h3 id="export-to-reqif"><a class="header" href="#export-to-reqif">Export to ReqIF</a></h3>
<pre><code class="language-bash">req export --format reqif --output requirements.reqif
</code></pre>
<p><strong>ReqIF</strong>: OMG standard for requirements exchange, compatible with:</p>
<ul>
<li>IBM DOORS</li>
<li>Siemens Polarion</li>
<li>PTC Integrity</li>
<li>Jama Connect</li>
<li>Many other tools</li>
</ul>
<p><strong>Use case</strong>: Send requirements to partners/customers using commercial tools.</p>
<h3 id="export-to-html"><a class="header" href="#export-to-html">Export to HTML</a></h3>
<pre><code class="language-bash">req export --format html --output requirements.html
</code></pre>
<p><strong>Features</strong>:</p>
<ul>
<li>Styled requirement documents</li>
<li>Clickable traceability links</li>
<li>Filterable by kind, tag</li>
<li>Printable</li>
<li>Standalone (no external dependencies)</li>
</ul>
<h3 id="export-to-pdf"><a class="header" href="#export-to-pdf">Export to PDF</a></h3>
<pre><code class="language-bash">req export --format pdf --output requirements.pdf
</code></pre>
<p><strong>Use case</strong>: Formal requirement documents for:</p>
<ul>
<li>Reviews</li>
<li>Approvals</li>
<li>Audits</li>
<li>Archival</li>
</ul>
<h2 id="import-functionality"><a class="header" href="#import-functionality">Import Functionality</a></h2>
<h3 id="import-from-json"><a class="header" href="#import-from-json">Import from JSON</a></h3>
<pre><code class="language-bash">req import --format json --input requirements.json
</code></pre>
<p>Creates <code>.md</code> files from JSON requirement data.</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Checks for UUID conflicts</li>
<li>Validates HRID format</li>
<li>Ensures parent references are valid</li>
</ul>
<p><strong>Conflict resolution</strong>:</p>
<pre><code class="language-bash">req import --format json --input requirements.json --on-conflict skip
req import --format json --input requirements.json --on-conflict overwrite
req import --format json --input requirements.json --on-conflict rename
</code></pre>
<h3 id="import-from-csv"><a class="header" href="#import-from-csv">Import from CSV</a></h3>
<pre><code class="language-bash">req import --format csv --input requirements.csv
</code></pre>
<p><strong>CSV format requirements</strong>:</p>
<ul>
<li>Must have headers: <code>HRID</code>, <code>UUID</code>, <code>Content</code></li>
<li>Optional: <code>Created</code>, <code>Tags</code>, <code>Parents</code></li>
<li><code>Parents</code> column: comma-separated HRIDs or UUIDs</li>
</ul>
<p><strong>Example CSV</strong>:</p>
<pre><code class="language-csv">HRID,UUID,Content,Tags,Parents
USR-001,4bfeb7d5-...,The system shall validate emails,authentication,
SYS-001,81e63bac-...,Email validation service,authentication,USR-001
</code></pre>
<h3 id="import-from-doorstop"><a class="header" href="#import-from-doorstop">Import from Doorstop</a></h3>
<p>Migrate from Doorstop projects:</p>
<pre><code class="language-bash">req import --format doorstop --input /path/to/doorstop/project
</code></pre>
<p><strong>What's imported</strong>:</p>
<ul>
<li>Doorstop documents ‚Üí Requiem requirement kinds</li>
<li>Doorstop items ‚Üí Requiem requirements</li>
<li>Links ‚Üí Parent relationships</li>
<li>Attributes ‚Üí Tags or content</li>
</ul>
<p><strong>Mapping</strong>:</p>
<pre><code>Doorstop                  Requiem
--------                  -------
Document PREFIX           Requirement KIND (e.g., USR)
Item UID                  UUID (generated or preserved)
Item text                 Requirement content
Item links                Parent relationships
Item attributes           Tags
</code></pre>
<h3 id="import-from-reqif"><a class="header" href="#import-from-reqif">Import from ReqIF</a></h3>
<pre><code class="language-bash">req import --format reqif --input requirements.reqif
</code></pre>
<p><strong>Use case</strong>: Import from commercial tools (DOORS, Polarion, etc.)</p>
<p><strong>Challenges</strong>:</p>
<ul>
<li>ReqIF is complex; not all features map to Requiem</li>
<li>May require manual cleanup after import</li>
</ul>
<h2 id="selective-exportimport"><a class="header" href="#selective-exportimport">Selective Export/Import</a></h2>
<h3 id="export-specific-requirements"><a class="header" href="#export-specific-requirements">Export Specific Requirements</a></h3>
<p>By kind:</p>
<pre><code class="language-bash">req export --kind USR --format json --output usr-requirements.json
</code></pre>
<p>By tag:</p>
<pre><code class="language-bash">req export --tag security --format csv --output security-reqs.csv
</code></pre>
<p>By namespace:</p>
<pre><code class="language-bash">req export --namespace AUTH --format html --output auth-reqs.html
</code></pre>
<h3 id="import-with-filtering"><a class="header" href="#import-with-filtering">Import with Filtering</a></h3>
<p>Skip certain requirements:</p>
<pre><code class="language-bash">req import --format json --input reqs.json --exclude-kind DOC
</code></pre>
<p>Rename on import:</p>
<pre><code class="language-bash">req import --format json --input reqs.json --rename-kind USR=USER
</code></pre>
<h2 id="transformation-during-importexport"><a class="header" href="#transformation-during-importexport">Transformation During Import/Export</a></h2>
<h3 id="hrid-remapping"><a class="header" href="#hrid-remapping">HRID Remapping</a></h3>
<p>Change HRIDs during import:</p>
<pre><code class="language-bash">req import --format json --input reqs.json --remap-hrids
</code></pre>
<p>Generates new HRIDs while preserving UUIDs (maintains traceability).</p>
<p><strong>Use case</strong>: Merging requirement sets with conflicting HRIDs.</p>
<h3 id="namespace-addition"><a class="header" href="#namespace-addition">Namespace Addition</a></h3>
<p>Add namespace during import:</p>
<pre><code class="language-bash">req import --format json --input reqs.json --add-namespace LEGACY
</code></pre>
<p>Imports USR-001 as LEGACY-USR-001.</p>
<p><strong>Use case</strong>: Integrating acquired projects.</p>
<h3 id="tag-transformation"><a class="header" href="#tag-transformation">Tag Transformation</a></h3>
<p>Add tags during import:</p>
<pre><code class="language-bash">req import --format json --input reqs.json --add-tag imported --add-tag legacy
</code></pre>
<h2 id="round-trip-compatibility"><a class="header" href="#round-trip-compatibility">Round-Trip Compatibility</a></h2>
<p><strong>Goal</strong>: Export and re-import without data loss.</p>
<p><strong>Guaranteed for</strong>:</p>
<ul>
<li>JSON format (lossless)</li>
<li>ReqIF format (best effort)</li>
</ul>
<p><strong>Limitations</strong>:</p>
<ul>
<li>CSV format (lossy: no complex structures)</li>
<li>HTML/PDF (read-only export, no import)</li>
</ul>
<p><strong>Validation</strong>:</p>
<pre><code class="language-bash"># Export
req export --format json --output export.json

# Import to clean directory
mkdir test &amp;&amp; cd test
req import --format json --input ../export.json

# Compare
diff -r ../original ./
# Should be identical
</code></pre>
<h2 id="use-cases-5"><a class="header" href="#use-cases-5">Use Cases</a></h2>
<h3 id="use-case-1-migrating-from-doorstop"><a class="header" href="#use-case-1-migrating-from-doorstop">Use Case 1: Migrating from Doorstop</a></h3>
<p><strong>Scenario</strong>: Existing project using Doorstop.</p>
<p><strong>Goal</strong>: Migrate to Requiem.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Export from Doorstop (if needed)
doorstop export all doorstop-export.json

# Import to Requiem
mkdir requiem-reqs &amp;&amp; cd requiem-reqs
req import --format doorstop --input ../doorstop-project

# Validate
req clean

# Compare manually
# Adjust as needed

# Commit
git init
git add .
git commit -m "Migrate from Doorstop to Requiem"
</code></pre>
<h3 id="use-case-2-exchanging-requirements-with-partners"><a class="header" href="#use-case-2-exchanging-requirements-with-partners">Use Case 2: Exchanging Requirements with Partners</a></h3>
<p><strong>Scenario</strong>: Partner uses IBM DOORS; you use Requiem.</p>
<p><strong>Goal</strong>: Exchange requirements.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Export from Requiem to ReqIF
req export --format reqif --output requirements.reqif

# Send to partner
# Partner imports into DOORS

# Receive updated ReqIF from partner
# Import updates
req import --format reqif --input updated-requirements.reqif --on-conflict merge

# Review changes
git diff

# Accept or reject
</code></pre>
<h3 id="use-case-3-spreadsheet-analysis"><a class="header" href="#use-case-3-spreadsheet-analysis">Use Case 3: Spreadsheet Analysis</a></h3>
<p><strong>Scenario</strong>: Need to analyze requirements in Excel.</p>
<p><strong>Goal</strong>: Export to CSV, analyze, re-import.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Export to CSV
req export --format csv --output requirements.csv

# Open in Excel
# Add column "Priority" with values
# Save as requirements-with-priority.csv

# Import with new tags
req import --format csv --input requirements-with-priority.csv \
  --map-column Priority=tag

# Priority values become tags
</code></pre>
<h3 id="use-case-4-generating-formal-documents"><a class="header" href="#use-case-4-generating-formal-documents">Use Case 4: Generating Formal Documents</a></h3>
<p><strong>Scenario</strong>: Need PDF for customer review.</p>
<p><strong>Goal</strong>: Professional requirement document.</p>
<p><strong>Workflow</strong>:</p>
<pre><code class="language-bash"># Export to PDF
req export --format pdf --output requirements.pdf \
  --template formal \
  --include-toc \
  --include-traceability

# Review
open requirements.pdf

# Send to customer
</code></pre>
<h2 id="configuration-planned-3"><a class="header" href="#configuration-planned-3">Configuration (Planned)</a></h2>
<h3 id="export-settings"><a class="header" href="#export-settings">Export Settings</a></h3>
<pre><code class="language-toml"># config.toml (planned)
[export]
# Default export format
default_format = "json"

# Include fingerprints in export
include_fingerprints = true

# Include timestamps
include_timestamps = true

[export.json]
# Pretty-print JSON
pretty = true
indent = 2

[export.csv]
# CSV delimiter
delimiter = ","

# Include header row
include_header = true

[export.pdf]
# Template to use
template = "formal"

# Include table of contents
include_toc = true

# Include traceability matrix
include_traceability = true
</code></pre>
<h3 id="import-settings"><a class="header" href="#import-settings">Import Settings</a></h3>
<pre><code class="language-toml">[import]
# Action on UUID conflict
on_conflict = "skip"  # skip, overwrite, rename

# Validate after import
validate = true

# Automatically run req clean after import
auto_clean = true
</code></pre>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="uuid-conflicts"><a class="header" href="#uuid-conflicts">UUID Conflicts</a></h3>
<p><strong>Problem</strong>: Importing requirements with UUIDs that already exist.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li><code>--on-conflict skip</code>: Skip conflicting requirements</li>
<li><code>--on-conflict overwrite</code>: Replace existing</li>
<li><code>--on-conflict rename</code>: Generate new UUIDs</li>
</ul>
<h3 id="invalid-hrids-1"><a class="header" href="#invalid-hrids-1">Invalid HRIDs</a></h3>
<p><strong>Problem</strong>: Imported HRIDs don't match Requiem format.</p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash">req import --format csv --input reqs.csv --remap-hrids
</code></pre>
<p>Generates valid HRIDs automatically.</p>
<h3 id="broken-links-after-import"><a class="header" href="#broken-links-after-import">Broken Links After Import</a></h3>
<p><strong>Problem</strong>: Parent references don't resolve.</p>
<p><strong>Diagnosis</strong>:</p>
<pre><code class="language-bash">req clean
# Reports missing parent requirements
</code></pre>
<p><strong>Solution</strong>: Ensure all referenced requirements are imported.</p>
<h2 id="workarounds-until-implemented-2"><a class="header" href="#workarounds-until-implemented-2">Workarounds (Until Implemented)</a></h2>
<p>Manual export/import with scripts:</p>
<h3 id="export-to-json-manual"><a class="header" href="#export-to-json-manual">Export to JSON (Manual)</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
import glob
import yaml
import re
import json

requirements = []
for path in glob.glob("*.md"):
    with open(path) as f:
        content = f.read()
    match = re.match(r'^---\n(.*?)\n---\n(.*)$', content, re.DOTALL)
    if match:
        frontmatter = yaml.safe_load(match.group(1))
        body = match.group(2).strip()
        hrid = path.replace('.md', '')
        requirements.append({
            "hrid": hrid,
            "uuid": frontmatter['uuid'],
            "created": frontmatter['created'],
            "content": body,
            "tags": frontmatter.get('tags', []),
            "parents": frontmatter.get('parents', [])
        })

with open("requirements.json", "w") as f:
    json.dump({"requirements": requirements}, f, indent=2, default=str)

print(f"Exported {len(requirements)} requirements to requirements.json")
</code></pre>
<h3 id="import-from-csv-manual"><a class="header" href="#import-from-csv-manual">Import from CSV (Manual)</a></h3>
<pre><code class="language-python">#!/usr/bin/env python3
import csv
import uuid
from datetime import datetime

with open("requirements.csv") as f:
    reader = csv.DictReader(f)
    for row in reader:
        hrid = row['HRID']
        req_uuid = row.get('UUID', str(uuid.uuid4()))
        content = row['Content']
        tags = row.get('Tags', '').split(',') if row.get('Tags') else []

        frontmatter = f"""---
_version: '1'
uuid: {req_uuid}
created: {datetime.utcnow().isoformat()}Z
"""
        if tags:
            frontmatter += "tags:\n"
            for tag in tags:
                frontmatter += f"- {tag.strip()}\n"

        frontmatter += "---\n\n"

        with open(f"{hrid}.md", "w") as f:
            f.write(frontmatter + content + "\n")

print("Import complete")
</code></pre>
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p><strong>Planned formats</strong>:</p>
<ul>
<li><strong>Export</strong>: JSON, CSV, ReqIF, HTML, PDF</li>
<li><strong>Import</strong>: JSON, CSV, ReqIF, Doorstop</li>
</ul>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Migration from other tools</li>
<li>Partner/customer exchange</li>
<li>Spreadsheet analysis</li>
<li>Formal document generation</li>
<li>Backup and archival</li>
</ul>
<p><strong>Key features</strong>:</p>
<ul>
<li>Selective export/import</li>
<li>Format transformation</li>
<li>Conflict resolution</li>
<li>Round-trip compatibility (JSON, ReqIF)</li>
<li>Validation</li>
</ul>
<p><strong>Timeline</strong>: Implementation planned for future release</p>
<h2 id="next-steps-24"><a class="header" href="#next-steps-24">Next Steps</a></h2>
<ul>
<li>Use <a href="advanced/import-export.html#workarounds-until-implemented">manual workarounds</a> for current export/import needs</li>
<li>Plan your <a href="advanced/import-export.html#configuration-planned">import/export requirements</a> for when feature is available</li>
<li>Review <a href="advanced/./coverage.html">Coverage Reports</a> and <a href="advanced/./cycles.html">Cycle Detection</a> for other advanced features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-requiems-own-requirements"><a class="header" href="#example-requiems-own-requirements">Example: Requiem's Own Requirements</a></h1>
<p>This section contains Requiem's actual project requirements - the specification that defines what this tool does. These requirements serve a dual purpose:</p>
<ol>
<li><strong>Project Specification</strong>: Formal requirements that guide Requiem's development</li>
<li><strong>Worked Example</strong>: A real-world demonstration of Requiem managing its own requirements</li>
</ol>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>Most requirements management tools provide toy examples with a handful of simple requirements. By using Requiem to manage Requiem's own requirements, we demonstrate:</p>
<ul>
<li><strong>Dogfooding</strong>: We trust our own tool for serious work</li>
<li><strong>Real traceability</strong>: User requirements flow down to system requirements</li>
<li><strong>Best practices</strong>: Professional structure, clear writing, proper linking</li>
<li><strong>Scale</strong>: A complete requirements set, not just a demo</li>
<li><strong>Integration</strong>: Requirements living alongside documentation (MdBook)</li>
</ul>
<h2 id="requirements-structure"><a class="header" href="#requirements-structure">Requirements Structure</a></h2>
<p>Requiem's requirements follow a two-level hierarchy:</p>
<h3 id="user-requirements-usr"><a class="header" href="#user-requirements-usr">User Requirements (USR)</a></h3>
<p>High-level requirements that describe <strong>what</strong> users need from the tool. These focus on user-facing functionality and capabilities.</p>
<ul>
<li><a href="./requirements/USR-001.html">USR-001</a>: Plain Text Storage</li>
<li><a href="./requirements/USR-002.html">USR-002</a>: Unique and Stable Identifiers</li>
<li><a href="./requirements/USR-003.html">USR-003</a>: Requirement Relationships and Traceability</li>
<li><a href="./requirements/USR-004.html">USR-004</a>: Graph Analysis and Validation</li>
<li><a href="./requirements/USR-005.html">USR-005</a>: Static Site Generator Integration</li>
<li><a href="./requirements/USR-006.html">USR-006</a>: Requirement Templates</li>
<li><a href="./requirements/USR-007.html">USR-007</a>: Requirement Visibility and Navigation</li>
</ul>
<p><a href="./requirements/user-requirements.html">View all user requirements ‚Üí</a></p>
<h3 id="system-requirements-sys"><a class="header" href="#system-requirements-sys">System Requirements (SYS)</a></h3>
<p>Detailed technical requirements that describe <strong>how</strong> the system implements user needs. These specify file formats, algorithms, CLI commands, and implementation details.</p>
<ul>
<li><a href="./requirements/SYS-001.html">SYS-001</a>: Markdown File Format with YAML Frontmatter</li>
<li><a href="./requirements/SYS-002.html">SYS-002</a>: UUID and HRID Fields</li>
<li><a href="./requirements/SYS-003.html">SYS-003</a>: Parent Requirement Links</li>
<li>... and 17 more system requirements</li>
</ul>
<p><a href="./requirements/system-requirements.html">View all system requirements ‚Üí</a></p>
<h2 id="traceability-in-action"><a class="header" href="#traceability-in-action">Traceability in Action</a></h2>
<p>Notice how system requirements trace back to user requirements. For example:</p>
<p><strong>USR-006: Requirement Templates</strong> has five child system requirements:</p>
<ul>
<li>SYS-011: Template File Storage</li>
<li>SYS-012: Default Template Application</li>
<li>SYS-013: Template Override via CLI</li>
<li>SYS-014: Template Format</li>
<li>SYS-015: Namespace-Specific Templates</li>
</ul>
<p>This demonstrates the USR‚ÜíSYS traceability that Requiem was built to support. Each user need is decomposed into specific technical requirements.</p>
<h2 id="using-this-as-a-learning-resource"><a class="header" href="#using-this-as-a-learning-resource">Using This as a Learning Resource</a></h2>
<p>As you read through the user guide, refer back to these requirements to see concepts in practice:</p>
<ul>
<li><strong>File Format</strong>: See <a href="./requirements/SYS-001.html">SYS-001</a> for the actual specification</li>
<li><strong>HRIDs</strong>: See <a href="./requirements/SYS-002.html">SYS-002</a> for identifier format rules</li>
<li><strong>Parent Links</strong>: See <a href="./requirements/SYS-003.html">SYS-003</a> for linking structure</li>
<li><strong>Fingerprints</strong>: See <a href="./requirements/SYS-005.html">SYS-005</a> for suspect link detection</li>
<li><strong>Templates</strong>: See SYS-011 through SYS-015 for complete template system specification</li>
<li><strong>CLI Visibility</strong>: See SYS-017 through SYS-019 for the listing and navigation interface</li>
</ul>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>This requirements directory includes:</p>
<ul>
<li><code>config.toml</code>: Requiem configuration (version only)</li>
<li><code>.req/templates/</code>: Template files for new requirements
<ul>
<li><code>USR.md</code>: Template for user requirements</li>
<li><code>SYS.md</code>: Template for system requirements</li>
</ul>
</li>
</ul>
<h2 id="exploring-further"><a class="header" href="#exploring-further">Exploring Further</a></h2>
<p>Browse the requirements directly:</p>
<ul>
<li><a href="./requirements/user-requirements.html">User Requirements Overview</a></li>
<li><a href="./requirements/system-requirements.html">System Requirements Overview</a></li>
</ul>
<p>Or jump to specific requirements using the links above.</p>
<hr />
<p><strong>Note</strong>: These requirements are managed using Requiem itself. Any changes go through the same review process documented in <a href="./maintaining.html">Maintaining Requirements</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-requirements-1"><a class="header" href="#user-requirements-1">User Requirements</a></h1>
<p>User requirements (USR) define the high-level capabilities that Requiem must provide to its users. These requirements focus on <strong>what</strong> the tool enables users to accomplish, from the user's perspective.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Requiem has 7 user requirements that establish the core value proposition:</p>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./USR-001.html">USR-001</a></td><td>Plain Text Storage</td><td>Requirements stored as plain text files readable in any editor</td></tr>
<tr><td><a href="requirements/./USR-002.html">USR-002</a></td><td>Unique and Stable Identifiers</td><td>Dual identifiers: UUIDs for machines, HRIDs for humans</td></tr>
<tr><td><a href="requirements/./USR-003.html">USR-003</a></td><td>Requirement Relationships and Traceability</td><td>Parent-child relationships forming traceable hierarchies</td></tr>
<tr><td><a href="requirements/./USR-004.html">USR-004</a></td><td>Graph Analysis and Validation</td><td>Cycle detection and change impact analysis</td></tr>
<tr><td><a href="requirements/./USR-005.html">USR-005</a></td><td>Static Site Generator Integration</td><td>Compatibility with MdBook and Sphinx</td></tr>
<tr><td><a href="requirements/./USR-006.html">USR-006</a></td><td>Requirement Templates</td><td>Support for templates when creating new requirements</td></tr>
<tr><td><a href="requirements/./USR-007.html">USR-007</a></td><td>Requirement Visibility and Navigation</td><td>CLI listing and graph exploration for working sets</td></tr>
</tbody></table>
</div>
<h2 id="detailed-requirements"><a class="header" href="#detailed-requirements">Detailed Requirements</a></h2>
<h3 id="usr-001-plain-text-storage"><a class="header" href="#usr-001-plain-text-storage">USR-001: Plain Text Storage</a></h3>
<p>The tool shall store requirements as plain-text files that can be read and edited with any text editor.</p>
<p><strong>Why this matters</strong>: Plain text enables version control integration, human review without specialized software, long-term archival, and integration with existing text-based workflows.</p>
<p><strong>Child requirements</strong>: SYS-001, SYS-002</p>
<p><a href="requirements/./USR-001.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-002-unique-and-stable-identifiers"><a class="header" href="#usr-002-unique-and-stable-identifiers">USR-002: Unique and Stable Identifiers</a></h3>
<p>The tool shall assign each requirement both a UUID (for technical stability) and a human-readable ID/HRID (for human reference).</p>
<p><strong>Why this matters</strong>: UUIDs prevent conflicts and enable merging, while HRIDs like "USR-001" make requirements easy to discuss, link, and remember.</p>
<p><strong>Child requirements</strong>: SYS-002</p>
<p><a href="requirements/./USR-002.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-003-requirement-relationships-and-traceability"><a class="header" href="#usr-003-requirement-relationships-and-traceability">USR-003: Requirement Relationships and Traceability</a></h3>
<p>The tool shall support defining parent-child relationships between requirements, enabling traceability from high-level needs to detailed specifications.</p>
<p><strong>Why this matters</strong>: Traceability is essential for understanding requirement flow, impact analysis, coverage verification, and compliance in regulated industries.</p>
<p><strong>Child requirements</strong>: SYS-003</p>
<p><a href="requirements/./USR-003.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-004-graph-analysis-and-validation"><a class="header" href="#usr-004-graph-analysis-and-validation">USR-004: Graph Analysis and Validation</a></h3>
<p>The tool shall analyze the requirement graph to detect invalid structures (cycles) and identify the impact of changes.</p>
<p><strong>Why this matters</strong>: Requirements form a directed acyclic graph (DAG). Cycles are errors. Impact analysis shows what's affected when requirements change.</p>
<p><strong>Child requirements</strong>: SYS-004, SYS-005, SYS-008, SYS-009, SYS-010</p>
<p><a href="requirements/./USR-004.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-005-static-site-generator-integration"><a class="header" href="#usr-005-static-site-generator-integration">USR-005: Static Site Generator Integration</a></h3>
<p>The tool shall integrate with documentation frameworks (Sphinx, MdBook) so requirements can be included in generated documentation.</p>
<p><strong>Why this matters</strong>: Requirements shouldn't live in isolation. They should integrate with design docs, user guides, and API documentation in a single published site.</p>
<p><strong>Child requirements</strong>: SYS-006, SYS-007</p>
<p><a href="requirements/./USR-005.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-006-requirement-templates"><a class="header" href="#usr-006-requirement-templates">USR-006: Requirement Templates</a></h3>
<p>The tool shall support defining templates that provide default content and structure for new requirements.</p>
<p><strong>Why this matters</strong>: Templates ensure consistency, reduce boilerplate, encode best practices, and make requirement creation faster.</p>
<p><strong>Child requirements</strong>: SYS-011, SYS-012, SYS-013, SYS-014, SYS-015</p>
<p><a href="requirements/./USR-006.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="usr-007-requirement-visibility-and-navigation"><a class="header" href="#usr-007-requirement-visibility-and-navigation">USR-007: Requirement Visibility and Navigation</a></h3>
<p>The tool shall let users quickly locate, inspect, and summarize requirements from the command line without opening individual files.</p>
<p><strong>Why this matters</strong>: Reviewers and systems engineers need instant visibility into requirement sets during audits, change control, and release prep. Native listing and navigation commands eliminate manual grepping and ad-hoc spreadsheets.</p>
<p><strong>Child requirements</strong>: SYS-017, SYS-018, SYS-019</p>
<p><a href="requirements/./USR-007.html">Read full requirement ‚Üí</a></p>
<hr />
<h2 id="traceability-2"><a class="header" href="#traceability-2">Traceability</a></h2>
<p>Each USR requirement traces down to one or more SYS (system) requirements that provide technical implementation details:</p>
<pre><code>USR-001 (Plain Text Storage)
  ‚îú‚îÄ‚îÄ SYS-001 (Markdown File Format with YAML Frontmatter)
  ‚îî‚îÄ‚îÄ SYS-002 (UUID and HRID Fields)

USR-002 (Unique and Stable Identifiers)
  ‚îî‚îÄ‚îÄ SYS-002 (UUID and HRID Fields)

USR-003 (Requirement Relationships and Traceability)
  ‚îî‚îÄ‚îÄ SYS-003 (Parent Requirement Links)

USR-004 (Graph Analysis and Validation)
  ‚îú‚îÄ‚îÄ SYS-004 (Cycle Detection in Requirement Graph)
  ‚îú‚îÄ‚îÄ SYS-005 (Suspect Link Detection)
  ‚îú‚îÄ‚îÄ SYS-008 (Suspect Links CLI Command)
  ‚îú‚îÄ‚îÄ SYS-009 (Accept Individual Suspect Links)
  ‚îî‚îÄ‚îÄ SYS-010 (Accept All Suspect Links in Bulk)

USR-005 (Static Site Generator Integration)
  ‚îú‚îÄ‚îÄ SYS-006 (Sphinx and MyST Parser Compatibility)
  ‚îî‚îÄ‚îÄ SYS-007 (MdBook Compatibility)

USR-006 (Requirement Templates)
  ‚îú‚îÄ‚îÄ SYS-011 (Template File Storage)
  ‚îú‚îÄ‚îÄ SYS-012 (Default Template Application)
  ‚îú‚îÄ‚îÄ SYS-013 (Template Override via CLI)
  ‚îú‚îÄ‚îÄ SYS-014 (Template Format)
  ‚îî‚îÄ‚îÄ SYS-015 (Namespace-Specific Templates)

USR-007 (Requirement Visibility and Navigation)
  ‚îú‚îÄ‚îÄ SYS-017 (Requirements Listing CLI Command)
  ‚îú‚îÄ‚îÄ SYS-018 (Listing Filters and Scopes)
  ‚îú‚îÄ‚îÄ SYS-019 (Relationship Navigation Views)
  ‚îî‚îÄ‚îÄ SYS-020 (Status Dashboard CLI Command)
</code></pre>
<p>This hierarchy demonstrates requirement decomposition from user needs down to technical implementation.</p>
<h2 id="next-steps-25"><a class="header" href="#next-steps-25">Next Steps</a></h2>
<ul>
<li><a href="requirements/./system-requirements.html">View System Requirements ‚Üí</a></li>
<li><a href="requirements/../requirements.html">Back to Requirements Overview ‚Üí</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-requirements-1"><a class="header" href="#system-requirements-1">System Requirements</a></h1>
<p>System requirements (SYS) define the technical implementation details for Requiem. While user requirements describe <strong>what</strong> users need, system requirements specify <strong>how</strong> the tool delivers those capabilities.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>Requiem has 20 system requirements organized by functional area:</p>
<h3 id="file-format--identifiers"><a class="header" href="#file-format--identifiers">File Format &amp; Identifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Parent</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./SYS-001.html">SYS-001</a></td><td>Markdown File Format with YAML Frontmatter</td><td>USR-001</td><td>Files contain YAML metadata block and Markdown body</td></tr>
<tr><td><a href="requirements/./SYS-002.html">SYS-002</a></td><td>UUID and HRID Fields</td><td>USR-001, USR-002</td><td>Frontmatter includes UUID, HRID, version, created timestamp</td></tr>
<tr><td><a href="requirements/./SYS-003.html">SYS-003</a></td><td>Parent Requirement Links</td><td>USR-003</td><td>Parent links stored as arrays with UUID, HRID, fingerprint</td></tr>
</tbody></table>
</div>
<h3 id="graph-analysis--validation"><a class="header" href="#graph-analysis--validation">Graph Analysis &amp; Validation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Parent</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./SYS-004.html">SYS-004</a></td><td>Cycle Detection in Requirement Graph</td><td>USR-004</td><td>Tool validates requirements form a DAG with no cycles</td></tr>
<tr><td><a href="requirements/./SYS-005.html">SYS-005</a></td><td>Suspect Link Detection</td><td>USR-004</td><td>Detects when parent fingerprint doesn't match stored value</td></tr>
<tr><td><a href="requirements/./SYS-008.html">SYS-008</a></td><td>Suspect Links CLI Command</td><td>USR-004</td><td><code>req suspect</code> command lists all suspect links</td></tr>
<tr><td><a href="requirements/./SYS-009.html">SYS-009</a></td><td>Accept Individual Suspect Links</td><td>USR-004</td><td><code>req accept &lt;child&gt; &lt;parent&gt;</code> updates one suspect link</td></tr>
<tr><td><a href="requirements/./SYS-010.html">SYS-010</a></td><td>Accept All Suspect Links in Bulk</td><td>USR-004</td><td><code>req accept --all</code> updates all suspect links with dry-run/force</td></tr>
</tbody></table>
</div>
<h3 id="static-site-integration"><a class="header" href="#static-site-integration">Static Site Integration</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Parent</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./SYS-006.html">SYS-006</a></td><td>Sphinx and MyST Parser Compatibility</td><td>USR-005</td><td>Requirements compatible with Sphinx + MyST Parser</td></tr>
<tr><td><a href="requirements/./SYS-007.html">SYS-007</a></td><td>MdBook Compatibility</td><td>USR-005</td><td>Requirements render correctly in MdBook</td></tr>
</tbody></table>
</div>
<h3 id="template-system"><a class="header" href="#template-system">Template System</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Parent</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./SYS-011.html">SYS-011</a></td><td>Template File Storage</td><td>USR-006</td><td>Templates stored as markdown files in <code>.req/templates/</code></td></tr>
<tr><td><a href="requirements/./SYS-012.html">SYS-012</a></td><td>Default Template Application</td><td>USR-006</td><td>Creating requirement uses template content as default body</td></tr>
<tr><td><a href="requirements/./SYS-013.html">SYS-013</a></td><td>Template Override via CLI</td><td>USR-006</td><td><code>-t</code> and <code>-b</code> flags override template content</td></tr>
<tr><td><a href="requirements/./SYS-014.html">SYS-014</a></td><td>Template Format</td><td>USR-006</td><td>Templates support full CommonMark markdown</td></tr>
<tr><td><a href="requirements/./SYS-015.html">SYS-015</a></td><td>Namespace-Specific Templates</td><td>USR-006</td><td>Different templates for same KIND with different namespaces</td></tr>
</tbody></table>
</div>
<h3 id="cli-visibility--navigation"><a class="header" href="#cli-visibility--navigation">CLI Visibility &amp; Navigation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Title</th><th>Parent</th><th>Summary</th></tr></thead><tbody>
<tr><td><a href="requirements/./SYS-017.html">SYS-017</a></td><td>Requirements Listing CLI Command</td><td>USR-007</td><td><code>req list</code> enumerates requirements with key metadata</td></tr>
<tr><td><a href="requirements/./SYS-018.html">SYS-018</a></td><td>Listing Filters and Scopes</td><td>USR-007</td><td>Filters restrict results by kind, namespace, tags, text</td></tr>
<tr><td><a href="requirements/./SYS-019.html">SYS-019</a></td><td>Relationship Navigation Views</td><td>USR-007</td><td>Options expose parents, children, ancestors, descendants</td></tr>
<tr><td><a href="requirements/./SYS-020.html">SYS-020</a></td><td>Status Dashboard CLI Command</td><td>USR-007</td><td><code>req status</code> shows counts by kind and suspect total</td></tr>
</tbody></table>
</div>
<h2 id="detailed-requirements-1"><a class="header" href="#detailed-requirements-1">Detailed Requirements</a></h2>
<h3 id="file-format--identifiers-1"><a class="header" href="#file-format--identifiers-1">File Format &amp; Identifiers</a></h3>
<h4 id="sys-001-markdown-file-format-with-yaml-frontmatter"><a class="header" href="#sys-001-markdown-file-format-with-yaml-frontmatter">SYS-001: Markdown File Format with YAML Frontmatter</a></h4>
<p>Each requirement shall be stored as a single plain-text Markdown file containing a YAML frontmatter block and a Markdown body. Files are named <code>{HRID}.md</code> with frontmatter delimited by <code>---</code> markers.</p>
<p><a href="requirements/./SYS-001.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-002-uuid-and-hrid-fields"><a class="header" href="#sys-002-uuid-and-hrid-fields">SYS-002: UUID and HRID Fields</a></h4>
<p>The YAML frontmatter shall include required fields: <code>_version</code> (format version), <code>uuid</code> (globally unique identifier), <code>created</code> (ISO 8601 timestamp). The HRID is derived from the filename.</p>
<p><a href="requirements/./SYS-002.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-003-parent-requirement-links"><a class="header" href="#sys-003-parent-requirement-links">SYS-003: Parent Requirement Links</a></h4>
<p>Parent links shall be stored in a <code>parents</code> array, where each link contains <code>uuid</code>, <code>hrid</code>, and <code>fingerprint</code> (SHA256 hash of parent content) for change detection.</p>
<p><a href="requirements/./SYS-003.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="graph-analysis--validation-1"><a class="header" href="#graph-analysis--validation-1">Graph Analysis &amp; Validation</a></h3>
<h4 id="sys-004-cycle-detection-in-requirement-graph"><a class="header" href="#sys-004-cycle-detection-in-requirement-graph">SYS-004: Cycle Detection in Requirement Graph</a></h4>
<p>The tool shall validate that requirements form a directed acyclic graph (DAG). Cycles are invalid because they create circular dependencies. Detection uses depth-first traversal.</p>
<p><a href="requirements/./SYS-004.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-005-suspect-link-detection"><a class="header" href="#sys-005-suspect-link-detection">SYS-005: Suspect Link Detection</a></h4>
<p>When a parent's fingerprint doesn't match the stored value in a child's frontmatter, the link is "suspect" - indicating the parent changed. The tool identifies these for review.</p>
<p><a href="requirements/./SYS-005.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-008-suspect-links-cli-command"><a class="header" href="#sys-008-suspect-links-cli-command">SYS-008: Suspect Links CLI Command</a></h4>
<p>The <code>req suspect</code> command lists all suspect links in the graph, showing child HRID and suspect parent HRID. Exits with non-zero status if suspect links found (useful for CI).</p>
<p><a href="requirements/./SYS-008.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-009-accept-individual-suspect-links"><a class="header" href="#sys-009-accept-individual-suspect-links">SYS-009: Accept Individual Suspect Links</a></h4>
<p>The <code>req accept &lt;child-hrid&gt; &lt;parent-hrid&gt;</code> command accepts a specific suspect link by updating the fingerprint in the child's frontmatter to match the parent's current content hash.</p>
<p><a href="requirements/./SYS-009.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-010-accept-all-suspect-links-in-bulk"><a class="header" href="#sys-010-accept-all-suspect-links-in-bulk">SYS-010: Accept All Suspect Links in Bulk</a></h4>
<p>The <code>req accept --all</code> command accepts all suspect links in bulk. Supports <code>--dry-run</code> to preview changes and <code>--force</code> to bypass confirmation prompt.</p>
<p><a href="requirements/./SYS-010.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="static-site-integration-1"><a class="header" href="#static-site-integration-1">Static Site Integration</a></h3>
<h4 id="sys-006-sphinx-and-myst-parser-compatibility"><a class="header" href="#sys-006-sphinx-and-myst-parser-compatibility">SYS-006: Sphinx and MyST Parser Compatibility</a></h4>
<p>Requirement files shall be compatible with Sphinx using the MyST Parser, rendering frontmatter as metadata and body content correctly. YAML syntax must be MyST-compatible.</p>
<p><a href="requirements/./SYS-006.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-007-mdbook-compatibility"><a class="header" href="#sys-007-mdbook-compatibility">SYS-007: MdBook Compatibility</a></h4>
<p>Requirement files shall render correctly in MdBook. YAML frontmatter is ignored (not rendered), and markdown body content displays properly following CommonMark specification.</p>
<p><a href="requirements/./SYS-007.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="template-system-1"><a class="header" href="#template-system-1">Template System</a></h3>
<h4 id="sys-011-template-file-storage"><a class="header" href="#sys-011-template-file-storage">SYS-011: Template File Storage</a></h4>
<p>Templates are stored as individual markdown files in the <code>.req/templates/</code> directory, named after requirement kind: <code>{KIND}.md</code>. Namespace-specific templates use <code>{NAMESPACE}-{KIND}.md</code>.</p>
<p><a href="requirements/./SYS-011.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-012-default-template-application"><a class="header" href="#sys-012-default-template-application">SYS-012: Default Template Application</a></h4>
<p>When creating a requirement via <code>req add &lt;KIND&gt;</code>, if a template file exists for that kind, the tool uses the template content as the default body content.</p>
<p><a href="requirements/./SYS-012.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-013-template-override-via-cli"><a class="header" href="#sys-013-template-override-via-cli">SYS-013: Template Override via CLI</a></h4>
<p>The <code>-t/--title</code> and <code>-b/--body</code> flags allow users to override template content. If either flag is provided, the template is completely ignored.</p>
<p><a href="requirements/./SYS-013.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-014-template-format"><a class="header" href="#sys-014-template-format">SYS-014: Template Format</a></h4>
<p>Template files contain plain markdown text supporting standard markdown formatting: headings, lists, code blocks, links, etc. No special template syntax required - content is inserted verbatim.</p>
<p><a href="requirements/./SYS-014.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-015-namespace-specific-templates"><a class="header" href="#sys-015-namespace-specific-templates">SYS-015: Namespace-Specific Templates</a></h4>
<p>Different templates can be configured for the same KIND with different namespaces (e.g., <code>AUTH-USR.md</code> vs <code>USR.md</code>). Template lookup tries full prefix first, then falls back to KIND only.</p>
<p><a href="requirements/./SYS-015.html">Read full requirement ‚Üí</a></p>
<hr />
<h3 id="cli-visibility--navigation-1"><a class="header" href="#cli-visibility--navigation-1">CLI Visibility &amp; Navigation</a></h3>
<h4 id="sys-017-requirements-listing-cli-command"><a class="header" href="#sys-017-requirements-listing-cli-command">SYS-017: Requirements Listing CLI Command</a></h4>
<p>The <code>req list</code> command enumerates requirements with key metadata, supporting multiple output formats for human and machine consumption.</p>
<p><a href="requirements/./SYS-017.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-018-listing-filters-and-scopes"><a class="header" href="#sys-018-listing-filters-and-scopes">SYS-018: Listing Filters and Scopes</a></h4>
<p>The listing command provides filters (kind, namespace, tag, text search) and pagination controls so users can focus on relevant subsets.</p>
<p><a href="requirements/./SYS-018.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-019-relationship-navigation-views"><a class="header" href="#sys-019-relationship-navigation-views">SYS-019: Relationship Navigation Views</a></h4>
<p>Relationship-centric options expose parents, children, ancestors, descendants, and tree views to assist with impact analysis and reviews.</p>
<p><a href="requirements/./SYS-019.html">Read full requirement ‚Üí</a></p>
<hr />
<h4 id="sys-020-status-dashboard-cli-command"><a class="header" href="#sys-020-status-dashboard-cli-command">SYS-020: Status Dashboard CLI Command</a></h4>
<p>The <code>req status</code> command prints requirement counts per kind, reports the overall total, and highlights the suspect link count with a non-zero exit when attention is required.</p>
<p><a href="requirements/./SYS-020.html">Read full requirement ‚Üí</a></p>
<hr />
<h2 id="implementation-status-1"><a class="header" href="#implementation-status-1">Implementation Status</a></h2>
<p><strong>Implemented</strong> ‚úÖ:</p>
<ul>
<li>All file format requirements (SYS-001, SYS-002, SYS-003)</li>
<li>Fingerprints and suspect link detection (SYS-005, SYS-008)</li>
<li>Static site integration (SYS-006, SYS-007)</li>
<li>Complete template system (SYS-011 through SYS-015)</li>
<li>Individual suspect link acceptance (SYS-009)</li>
<li>Status dashboard command (SYS-020)</li>
</ul>
<p><strong>In Progress</strong> üöß:</p>
<ul>
<li>Cycle detection (SYS-004)</li>
<li>Bulk suspect link acceptance (SYS-010)</li>
</ul>
<p><strong>Planned</strong> üìù:</p>
<ul>
<li>Requirements listing and navigation (SYS-017, SYS-018, SYS-019)</li>
</ul>
<h2 id="traceability-3"><a class="header" href="#traceability-3">Traceability</a></h2>
<p>Each system requirement traces back to one or more user requirements. See the "Parent" column in the tables above, or view the <a href="requirements/./user-requirements.html">User Requirements page</a> for the complete traceability tree.</p>
<h2 id="next-steps-26"><a class="header" href="#next-steps-26">Next Steps</a></h2>
<ul>
<li><a href="requirements/./user-requirements.html">View User Requirements ‚Üí</a></li>
<li><a href="requirements/../requirements.html">Back to Requirements Overview ‚Üí</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-command-reference"><a class="header" href="#cli-command-reference">CLI Command Reference</a></h1>
<p>Complete reference for the <code>req</code> command-line interface.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>The <code>req</code> command is the main interface to Requiem. It provides commands for creating, linking, and managing requirements.</p>
<h3 id="global-synopsis"><a class="header" href="#global-synopsis">Global Synopsis</a></h3>
<pre><code>req [OPTIONS] &lt;COMMAND&gt;
</code></pre>
<p>Running <code>req</code> with no subcommand defaults to <code>req status</code>, providing a quick health
dashboard for the repository.</p>
<h3 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h3>
<pre><code class="language-bash"># General help
req --help

# Command-specific help
req add --help
req link --help
req clean --help
</code></pre>
<h3 id="version-information"><a class="header" href="#version-information">Version Information</a></h3>
<pre><code class="language-bash">req --version
</code></pre>
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<p>Options that apply to all commands.</p>
<h3 id="-v---verbose"><a class="header" href="#-v---verbose"><code>-v, --verbose</code></a></h3>
<p>Increase logging verbosity. Can be specified multiple times.</p>
<p><strong>Levels</strong>:</p>
<ul>
<li>No <code>-v</code>: WARN level (errors and warnings only)</li>
<li><code>-v</code>: INFO level (general information)</li>
<li><code>-vv</code>: DEBUG level (detailed debugging information)</li>
<li><code>-vvv</code>: TRACE level (very detailed trace information)</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash">req -v clean              # INFO level
req -vv add USR           # DEBUG level
req -vvv link SYS-001 USR-001  # TRACE level
</code></pre>
<p><strong>Use cases</strong>:</p>
<ul>
<li><strong>Normal use</strong>: No <code>-v</code> flag</li>
<li><strong>Troubleshooting</strong>: <code>-v</code> or <code>-vv</code></li>
<li><strong>Development/debugging</strong>: <code>-vvv</code></li>
</ul>
<h3 id="-r---root-path"><a class="header" href="#-r---root-path"><code>-r, --root &lt;PATH&gt;</code></a></h3>
<p>Specify the root directory containing requirements.</p>
<p><strong>Default</strong>: Current directory (<code>.</code>)</p>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash">req --root /path/to/requirements add USR
req -r ./reqs clean
req --root ~/project/requirements link SYS-001 USR-001
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Path can be absolute or relative</li>
<li>Must be a directory</li>
<li>Directory should contain <code>config.toml</code> (optional) and <code>.md</code> requirement files</li>
</ul>
<h2 id="commands-1"><a class="header" href="#commands-1">Commands</a></h2>
<h3 id="req-status"><a class="header" href="#req-status"><code>req status</code></a></h3>
<p>Display a quick summary of requirement counts and suspect links.</p>
<h4 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h4>
<pre><code>req status [OPTIONS]
</code></pre>
<h4 id="options"><a class="header" href="#options">Options</a></h4>
<p>None.</p>
<h4 id="behavior"><a class="header" href="#behavior">Behavior</a></h4>
<ol>
<li>Loads all requirements in the repository.</li>
<li>Prints a table listing each requirement kind with its count and the overall total.</li>
<li>Displays the total number of suspect links.</li>
<li>Exits with status code <code>1</code> when any suspect links are present, otherwise <code>0</code>.</li>
</ol>
<h4 id="examples-5"><a class="header" href="#examples-5">Examples</a></h4>
<p><strong>Summary view</strong>:</p>
<pre><code class="language-bash">req status
</code></pre>
<h3 id="req-add"><a class="header" href="#req-add"><code>req add</code></a></h3>
<p>Create a new requirement.</p>
<h4 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h4>
<pre><code>req add [OPTIONS] &lt;KIND&gt;
</code></pre>
<h4 id="arguments"><a class="header" href="#arguments">Arguments</a></h4>
<p><strong><code>&lt;KIND&gt;</code></strong> (required)</p>
<p>The kind of requirement to create. This becomes the KIND component of the HRID.</p>
<p>Examples: <code>USR</code>, <code>SYS</code>, <code>SWR</code>, <code>TST</code>, <code>AUTH-USR</code> (with namespace)</p>
<h4 id="options-1"><a class="header" href="#options-1">Options</a></h4>
<p><strong><code>-p, --parent &lt;PARENT&gt;...</code></strong></p>
<p>Specify parent requirement(s) by HRID. Can be specified multiple times or as comma-separated list.</p>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash"># Single parent
req add SYS --parent USR-001

# Multiple parents (multiple flags)
req add SYS --parent USR-001 --parent USR-002

# Multiple parents (comma-separated)
req add SYS --parents USR-001,USR-002

# Short form
req add SYS -p USR-001,USR-002
</code></pre>
<p><strong><code>-t, --title &lt;TITLE&gt;</code></strong></p>
<p>Set the title of the requirement. The title will be formatted as a markdown heading (<code># Title</code>).</p>
<p>If both <code>-t</code> and <code>-b</code> are provided, the title appears first, followed by a blank line, then the body.</p>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash"># Create with title only
req add USR -t "User Authentication"

# Create with title and body
req add USR -t "User Authentication" -b "The system shall authenticate users."
</code></pre>
<p><strong><code>-b, --body &lt;BODY&gt;</code></strong></p>
<p>Set the body content of the requirement. Can be any markdown text.</p>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash"># Create with body only
req add USR -b "The system shall validate user input."

# Create with multi-line body (using quotes)
req add USR -b "The system shall:
- Validate input
- Sanitize data
- Log attempts"
</code></pre>
<h4 id="behavior-1"><a class="header" href="#behavior-1">Behavior</a></h4>
<ol>
<li>Determines next available ID for the given KIND</li>
<li>Determines content:
<ul>
<li>If <code>-t</code> or <code>-b</code> flags are provided, uses that content</li>
<li>Otherwise, checks for a template file at <code>.req/templates/&lt;KIND&gt;.md</code></li>
<li>If no template file exists, uses empty content</li>
</ul>
</li>
<li>Creates requirement file <code>&lt;KIND&gt;-&lt;ID&gt;.md</code> with:
<ul>
<li>Automatically generated UUID</li>
<li>Current timestamp</li>
<li>Content (from flags, template, or empty)</li>
<li>Parent links (if specified)</li>
</ul>
</li>
<li>Prints the HRID of created requirement</li>
</ol>
<p><strong>Template Priority</strong>:</p>
<ul>
<li>CLI flags (<code>-t</code>, <code>-b</code>) always override templates</li>
<li>Templates are matched by KIND (e.g., <code>USR</code>, <code>AUTH-USR</code>)</li>
<li>Template files are stored in <code>.req/templates/</code> directory</li>
<li>See <a href="reference/../working-with-requirements/templates.html">Templates Guide</a> for template setup</li>
</ul>
<h4 id="examples-6"><a class="header" href="#examples-6">Examples</a></h4>
<p><strong>Create user requirement</strong>:</p>
<pre><code class="language-bash">req add USR
# Output: Added requirement USR-001
</code></pre>
<p><strong>Create system requirement with parent</strong>:</p>
<pre><code class="language-bash">req add SYS --parent USR-001
# Output: Added requirement SYS-001
</code></pre>
<p><strong>Create requirement with multiple parents</strong>:</p>
<pre><code class="language-bash">req add SWR --parents SYS-001,SYS-002
# Output: Added requirement SWR-001
</code></pre>
<p><strong>Create namespaced requirement</strong>:</p>
<pre><code class="language-bash">req add AUTH-USR
# Output: Added requirement AUTH-USR-001
</code></pre>
<p><strong>Create with title and body</strong>:</p>
<pre><code class="language-bash">req add USR -t "User Authentication" -b "The system shall authenticate users."
# Output: Added requirement USR-001
# Content: # User Authentication\n\nThe system shall authenticate users.
</code></pre>
<p><strong>Create with template</strong> (assuming <code>.req/templates/USR.md</code> exists):</p>
<pre><code class="language-bash">req add USR
# Output: Added requirement USR-001
# Content populated from .req/templates/USR.md
</code></pre>
<p><strong>Override template with CLI flags</strong>:</p>
<pre><code class="language-bash">req add USR -t "Custom Title"
# Output: Added requirement USR-001
# Content from -t flag, template ignored
</code></pre>
<h4 id="error-cases"><a class="header" href="#error-cases">Error Cases</a></h4>
<p><strong>Empty KIND</strong>:</p>
<pre><code class="language-bash">req add ""
# Error: Kind cannot be empty
</code></pre>
<p><strong>Invalid KIND</strong> (if <code>allowed_kinds</code> configured):</p>
<pre><code class="language-bash">req add INVALID
# Error: Kind 'INVALID' is not in the allowed list
</code></pre>
<p><strong>Parent not found</strong>:</p>
<pre><code class="language-bash">req add SYS --parent USR-999
# Error: Parent requirement USR-999 not found
</code></pre>
<h3 id="req-link"><a class="header" href="#req-link"><code>req link</code></a></h3>
<p>Create a parent-child link between two existing requirements.</p>
<h4 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h4>
<pre><code>req link &lt;CHILD&gt; &lt;PARENT&gt;
</code></pre>
<h4 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h4>
<p><strong><code>&lt;CHILD&gt;</code></strong> (required)</p>
<p>HRID of the child requirement (the requirement gaining a parent).</p>
<p><strong><code>&lt;PARENT&gt;</code></strong> (required)</p>
<p>HRID of the parent requirement (the upstream requirement).</p>
<h4 id="behavior-2"><a class="header" href="#behavior-2">Behavior</a></h4>
<ol>
<li>Loads both child and parent requirements</li>
<li>Adds parent reference to child's frontmatter:
<ul>
<li>Parent's UUID</li>
<li>Parent's current HRID</li>
<li>Parent's current fingerprint</li>
</ul>
</li>
<li>Saves updated child requirement</li>
<li>Prints confirmation message</li>
</ol>
<h4 id="examples-7"><a class="header" href="#examples-7">Examples</a></h4>
<p><strong>Link system to user requirement</strong>:</p>
<pre><code class="language-bash">req link SYS-001 USR-001
# Output: Linked SYS-001 to USR-001
</code></pre>
<p><strong>Link with namespaces</strong>:</p>
<pre><code class="language-bash">req link AUTH-SYS-001 AUTH-USR-001
# Output: Linked AUTH-SYS-001 to AUTH-USR-001
</code></pre>
<p><strong>Create second parent</strong> (multiple parents supported):</p>
<pre><code class="language-bash">req link SYS-001 USR-001  # First parent
req link SYS-001 USR-002  # Second parent
# SYS-001 now has two parents
</code></pre>
<h4 id="error-cases-1"><a class="header" href="#error-cases-1">Error Cases</a></h4>
<p><strong>Child not found</strong>:</p>
<pre><code class="language-bash">req link SYS-999 USR-001
# Error: Child requirement SYS-999 not found
</code></pre>
<p><strong>Parent not found</strong>:</p>
<pre><code class="language-bash">req link SYS-001 USR-999
# Error: Parent requirement USR-999 not found
</code></pre>
<p><strong>Invalid HRID format</strong>:</p>
<pre><code class="language-bash">req link INVALID USR-001
# Error: Invalid HRID format: INVALID
</code></pre>
<h3 id="req-suspect"><a class="header" href="#req-suspect"><code>req suspect</code></a></h3>
<p>List all suspect links in the requirement graph.</p>
<h4 id="synopsis-3"><a class="header" href="#synopsis-3">Synopsis</a></h4>
<pre><code>req suspect
</code></pre>
<h4 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h4>
<p>None.</p>
<h4 id="options-2"><a class="header" href="#options-2">Options</a></h4>
<p>None.</p>
<h4 id="behavior-3"><a class="header" href="#behavior-3">Behavior</a></h4>
<ol>
<li>Loads all requirements from the requirements directory</li>
<li>Compares stored parent fingerprints with current parent fingerprints</li>
<li>Lists all requirements with mismatched fingerprints (suspect links)</li>
<li>For each suspect link, displays:
<ul>
<li>Child HRID ‚Üí Parent HRID</li>
<li>Stored fingerprint (first 16 characters)</li>
<li>Current fingerprint (first 16 characters)</li>
</ul>
</li>
<li>Exits with code 1 if suspect links found (useful for CI/CD)</li>
<li>Exits with code 0 if no suspect links found</li>
</ol>
<h4 id="examples-8"><a class="header" href="#examples-8">Examples</a></h4>
<p><strong>Check for suspect links</strong>:</p>
<pre><code class="language-bash">req suspect
</code></pre>
<p>Example output when suspect links exist:</p>
<pre><code>Found 3 suspect link(s):

  SYS-001 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-002 ‚Üí USR-001
    Stored fingerprint:  e533784ff58c16cb
    Current fingerprint: c4020419ead000e9

  SYS-005 ‚Üí USR-004
    Stored fingerprint:  407c6e3413d5b3fa
    Current fingerprint: c28afe188a974322
</code></pre>
<p>Example output when no suspect links:</p>
<pre><code>No suspect links found.
</code></pre>
<p><strong>In CI/CD pipeline</strong>:</p>
<pre><code class="language-bash">req suspect &amp;&amp; echo "All links current" || echo "Review needed"
</code></pre>
<h4 id="use-cases-6"><a class="header" href="#use-cases-6">Use Cases</a></h4>
<ul>
<li><strong>Pre-commit validation</strong>: Check if parent requirements changed without updating children</li>
<li><strong>CI/CD integration</strong>: Fail builds when requirements need review</li>
<li><strong>Regular audits</strong>: Identify requirements needing review after upstream changes</li>
<li><strong>Change impact</strong>: See which requirements are affected by parent changes</li>
</ul>
<h4 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h4>
<ul>
<li><strong>0</strong>: No suspect links found (all fingerprints current)</li>
<li><strong>1</strong>: Suspect links found (some requirements need review)</li>
</ul>
<p>This exit code behavior makes the command useful in automation:</p>
<pre><code class="language-bash">#!/bin/bash
req suspect
if [ $? -ne 0 ]; then
    echo "ERROR: Requirements need review before release"
    exit 1
fi
</code></pre>
<h3 id="req-accept"><a class="header" href="#req-accept"><code>req accept</code></a></h3>
<p>Accept suspect links after review, updating fingerprints to current values.</p>
<h4 id="synopsis-4"><a class="header" href="#synopsis-4">Synopsis</a></h4>
<pre><code>req accept &lt;CHILD&gt; &lt;PARENT&gt;
req accept --all
</code></pre>
<h4 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h4>
<p><strong><code>&lt;CHILD&gt;</code></strong> (required unless <code>--all</code>)</p>
<p>HRID of the child requirement containing the suspect link.</p>
<p><strong><code>&lt;PARENT&gt;</code></strong> (required unless <code>--all</code>)</p>
<p>HRID of the parent requirement referenced by the suspect link.</p>
<h4 id="options-3"><a class="header" href="#options-3">Options</a></h4>
<p><strong><code>--all</code></strong></p>
<p>Accept all suspect links in the requirements directory. Updates all fingerprints to match current parent values.</p>
<h4 id="behavior-4"><a class="header" href="#behavior-4">Behavior</a></h4>
<p><strong>Single link mode</strong> (<code>req accept &lt;CHILD&gt; &lt;PARENT&gt;</code>):</p>
<ol>
<li>Loads the child and parent requirements</li>
<li>Verifies the link exists</li>
<li>Updates the stored fingerprint to match the parent's current fingerprint</li>
<li>Saves the updated child requirement</li>
<li>Prints confirmation or reports if link was already up to date</li>
</ol>
<p><strong>Bulk mode</strong> (<code>req accept --all</code>):</p>
<ol>
<li>Finds all suspect links</li>
<li>Updates all fingerprints to current values</li>
<li>Saves all affected requirements</li>
<li>Prints summary of updated links</li>
</ol>
<h4 id="examples-9"><a class="header" href="#examples-9">Examples</a></h4>
<p><strong>Accept a single suspect link</strong>:</p>
<pre><code class="language-bash">req accept SYS-001 USR-001
# Output: Accepted suspect link: SYS-001 ‚Üí USR-001
</code></pre>
<p><strong>Accept all suspect links</strong>:</p>
<pre><code class="language-bash">req accept --all
# Output:
# Accepted 3 suspect link(s):
#   SYS-001 ‚Üí USR-001
#   SYS-002 ‚Üí USR-001
#   SYS-005 ‚Üí USR-004
</code></pre>
<p><strong>Accept after no review needed</strong>:</p>
<pre><code class="language-bash">req accept SYS-001 USR-001
# Output: Link SYS-001 ‚Üí USR-001 is already up to date (not suspect).
</code></pre>
<h4 id="workflow"><a class="header" href="#workflow">Workflow</a></h4>
<p>Typical workflow for handling suspect links:</p>
<pre><code class="language-bash"># 1. Check for suspect links
req suspect

# 2. Review parent changes
vim USR-001.md  # Review what changed

# 3. Review child requirement
vim SYS-001.md  # Update if needed

# 4. Accept the link (marks as reviewed)
req accept SYS-001 USR-001

# 5. Verify no more suspect links
req suspect
</code></pre>
<h4 id="use-cases-7"><a class="header" href="#use-cases-7">Use Cases</a></h4>
<ul>
<li><strong>After review</strong>: Mark requirements as reviewed after verifying consistency with parent changes</li>
<li><strong>Bulk acceptance</strong>: Update all fingerprints after reviewing multiple changes</li>
<li><strong>Post-merge</strong>: Accept fingerprints after merging upstream requirement changes</li>
<li><strong>Release preparation</strong>: Clear all suspect links before release</li>
</ul>
<h4 id="error-cases-2"><a class="header" href="#error-cases-2">Error Cases</a></h4>
<p><strong>Link not found</strong>:</p>
<pre><code class="language-bash">req accept SYS-001 USR-999
# Error: Parent requirement USR-999 not found
</code></pre>
<p><strong>Child not found</strong>:</p>
<pre><code class="language-bash">req accept SYS-999 USR-001
# Error: Child requirement SYS-999 not found
</code></pre>
<p><strong>No link exists</strong>:</p>
<pre><code class="language-bash">req accept SYS-001 USR-001
# Error: link from SYS-001 to USR-001 not found
</code></pre>
<p><strong>No suspect links with --all</strong>:</p>
<pre><code class="language-bash">req accept --all
# Output: No suspect links to accept.
</code></pre>
<h3 id="req-list"><a class="header" href="#req-list"><code>req list</code></a></h3>
<p>List requirements with optional filtering, traversal, and output formatting.</p>
<h4 id="synopsis-5"><a class="header" href="#synopsis-5">Synopsis</a></h4>
<pre><code>req list [OPTIONS] [HRID...]
</code></pre>
<h4 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h4>
<p><strong><code>&lt;HRID&gt;</code></strong> <em>(optional, repeats)</em></p>
<p>Target requirements to anchor the listing. When omitted, the command starts from all
requirements (with the default view limited to top-level, parentless requirements).</p>
<h4 id="options-4"><a class="header" href="#options-4">Options</a></h4>
<ul>
<li><strong><code>--columns &lt;COL&gt;</code></strong>: Comma-separated list of columns (<code>hrid</code>, <code>title</code>, <code>kind</code>, <code>namespace</code>,
<code>parents</code>, <code>children</code>, <code>tags</code>, <code>path</code>, <code>created</code>). Default columns show HRID, title, kind,
parent count, child count, and tags. When <code>--quiet</code> is present without explicit columns, only
HRIDs are emitted.</li>
<li><strong><code>--sort &lt;FIELD&gt;</code></strong>: Sort output by <code>hrid</code> <em>(default)</em>, <code>kind</code>, <code>title</code>, or <code>created</code>.</li>
<li><strong><code>--output &lt;FORMAT&gt;</code></strong>: Choose <code>table</code> <em>(default)</em>, <code>json</code>, or <code>csv</code>. Table output is human
readable; JSON and CSV are machine friendly.</li>
<li><strong><code>--quiet</code></strong>: Suppress headers and format rows for shell pipelines. Defaults to one HRID per
line unless additional columns are requested.</li>
<li><strong><code>--kind &lt;KIND&gt;</code></strong>, <strong><code>--namespace &lt;SEG&gt;</code></strong>, <strong><code>--tag &lt;TAG&gt;</code></strong>: Filter by kind, namespace
segment, or tag (case-insensitive, commas or repeated flags allowed).</li>
<li><strong><code>--orphans</code></strong>, <strong><code>--leaves</code></strong>: Limit to requirements with no parents or no children.</li>
<li><strong><code>--contains &lt;TEXT&gt;</code></strong>, <strong><code>--regex &lt;PATTERN&gt;</code></strong>: Search requirement title/body with a
case-insensitive substring or Rust regular expression (mutually exclusive).</li>
<li><strong><code>--view &lt;MODE&gt;</code></strong>: Choose how to explore relationships. Options: <code>summary</code> <em>(default table)</em>,
<code>parents</code>, <code>children</code>, <code>ancestors</code>, <code>descendants</code>, <code>tree</code> (indented descendant view), and
<code>context</code> (base rows plus labelled neighbours).</li>
<li><strong><code>--depth &lt;N&gt;</code></strong>: Depth limit for the selected view (default <code>1</code> for parents/children/context,
unlimited for ancestors/descendants/tree). Use <code>0</code> for no limit.</li>
<li><strong><code>--limit &lt;N&gt;</code></strong>, <strong><code>--offset &lt;N&gt;</code></strong>: Paginate large result sets by skipping <code>offset</code> rows and
then truncating to <code>limit</code>. Defaults to 200 rows when omitted; pass <code>--limit 0</code> for no cap.</li>
</ul>
<h4 id="behavior-5"><a class="header" href="#behavior-5">Behavior</a></h4>
<ol>
<li>Loads all requirements and builds parent/child relationships.</li>
<li>Determines the working set:
<ul>
<li>If HRIDs are provided, they anchor traversal; otherwise all requirements are considered.</li>
<li>Without explicit filters or traversal flags, the default view lists every requirement sorted
by HRID and capped at the default limit.</li>
</ul>
</li>
<li>Applies requested filters and relationship traversal.</li>
<li>Formats output according to the selected layout.</li>
</ol>
<h4 id="examples-10"><a class="header" href="#examples-10">Examples</a></h4>
<p><strong>Top-level overview</strong>:</p>
<pre><code class="language-bash">req list
HRID     Title                              Kind  Parents  Children  Tags
USR-001  Plain Text Storage                 USR   0        2         
USR-004  Graph Analysis and Validation      USR   0        5         
</code></pre>
<p><strong>Filter by kind and tag</strong>:</p>
<pre><code class="language-bash">req list --kind SYS --tag navigation --output csv
</code></pre>
<p><strong>Descendants of a user requirement</strong>:</p>
<pre><code class="language-bash">req list USR-004 --view descendants --kind SYS
</code></pre>
<p><strong>Tree view</strong>:</p>
<pre><code class="language-bash">req list USR-004 --view tree --depth 2
</code></pre>
<h3 id="req-clean"><a class="header" href="#req-clean"><code>req clean</code></a></h3>
<p>Correct parent HRIDs in all requirements.</p>
<h4 id="synopsis-6"><a class="header" href="#synopsis-6">Synopsis</a></h4>
<pre><code>req clean
</code></pre>
<h4 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h4>
<p>None.</p>
<h4 id="options-5"><a class="header" href="#options-5">Options</a></h4>
<p>None.</p>
<h4 id="behavior-6"><a class="header" href="#behavior-6">Behavior</a></h4>
<ol>
<li>Loads all requirements from the requirements directory</li>
<li>For each requirement:
<ul>
<li>Checks parent HRIDs against actual parent filenames</li>
<li>If HRID is outdated, updates to current HRID</li>
<li>Saves requirement if changed</li>
</ul>
</li>
<li>Silent on success (no output if no corrections made)</li>
<li>With <code>-v</code>, logs each correction</li>
</ol>
<h4 id="examples-11"><a class="header" href="#examples-11">Examples</a></h4>
<p><strong>Validate/correct all requirements</strong>:</p>
<pre><code class="language-bash">req clean
# (no output = success, all HRIDs correct or corrected)
</code></pre>
<p><strong>Verbose output</strong>:</p>
<pre><code class="language-bash">req -v clean
# Output:
# INFO Corrected parent HRID in SYS-001: USR-001 ‚Üí USR-100
# INFO Corrected parent HRID in SYS-002: USR-001 ‚Üí USR-100
</code></pre>
<p><strong>With custom root</strong>:</p>
<pre><code class="language-bash">req --root /path/to/requirements clean
</code></pre>
<h4 id="use-cases-8"><a class="header" href="#use-cases-8">Use Cases</a></h4>
<ul>
<li>After renaming requirement files</li>
<li>After reorganizing requirements</li>
<li>Before committing changes (validation)</li>
<li>Regular maintenance</li>
</ul>
<h4 id="error-cases-3"><a class="header" href="#error-cases-3">Error Cases</a></h4>
<p><strong>Parent UUID not found</strong>:</p>
<pre><code class="language-bash">req clean
# Error: Parent requirement &lt;UUID&gt; not found!
</code></pre>
<p>This indicates a requirement references a parent that doesn't exist. Either restore the parent or manually remove the reference.</p>
<p><strong>Self-referential parent</strong>:</p>
<pre><code class="language-bash">req clean
# Error: Requirement &lt;UUID&gt; is its own parent!
</code></pre>
<p>This indicates a requirement lists itself as a parent. Manually remove the self-reference.</p>
<h2 id="common-workflows"><a class="header" href="#common-workflows">Common Workflows</a></h2>
<h3 id="creating-a-requirement-hierarchy"><a class="header" href="#creating-a-requirement-hierarchy">Creating a Requirement Hierarchy</a></h3>
<pre><code class="language-bash"># Create user requirements
req add USR  # USR-001
req add USR  # USR-002

# Create system requirements linked to user requirements
req add SYS --parent USR-001  # SYS-001
req add SYS --parent USR-002  # SYS-002

# Create software requirement satisfying multiple system requirements
req add SWR --parents SYS-001,SYS-002  # SWR-001

# Create test linked to software requirement
req add TST --parent SWR-001  # TST-001
</code></pre>
<h3 id="renaming-requirements"><a class="header" href="#renaming-requirements">Renaming Requirements</a></h3>
<pre><code class="language-bash"># Rename requirement file
mv USR-001.md USR-100.md

# Update parent references
req clean

# Verify
git diff  # See updated parent HRIDs
</code></pre>
<h3 id="linking-existing-requirements"><a class="header" href="#linking-existing-requirements">Linking Existing Requirements</a></h3>
<pre><code class="language-bash"># Requirements already exist
# USR-001.md
# SYS-001.md

# Create link
req link SYS-001 USR-001

# Add second parent
req link SYS-001 USR-002
</code></pre>
<h3 id="managing-requirement-changes"><a class="header" href="#managing-requirement-changes">Managing Requirement Changes</a></h3>
<pre><code class="language-bash"># Edit a parent requirement
vim USR-001.md  # Make changes

# Check for suspect links
req suspect
# Output: SYS-001 ‚Üí USR-001 (fingerprint mismatch)

# Review affected child
vim SYS-001.md  # Review and update if needed

# Accept the change
req accept SYS-001 USR-001

# Verify all links current
req suspect
# Output: No suspect links found.
</code></pre>
<h3 id="bulk-review-workflow"><a class="header" href="#bulk-review-workflow">Bulk Review Workflow</a></h3>
<pre><code class="language-bash"># After updating multiple parent requirements
req suspect
# Shows all suspect links

# Review and update children as needed
vim SYS-001.md
vim SYS-002.md
# ... review all affected requirements

# Accept all at once
req accept --all

# Commit changes
git add -A
git commit -m "Update requirements after USR changes"
</code></pre>
<h2 id="exit-codes-1"><a class="header" href="#exit-codes-1">Exit Codes</a></h2>
<p>Requiem uses standard exit codes:</p>
<ul>
<li><strong>0</strong>: Success</li>
<li><strong>Non-zero</strong>: Error</li>
</ul>
<p>Examples:</p>
<pre><code class="language-bash">req add USR &amp;&amp; echo "Success"  # Success
req add INVALID || echo "Failed"  # Failed (if KIND not allowed)
</code></pre>
<p>Use in scripts:</p>
<pre><code class="language-bash">#!/bin/bash
req clean
if [ $? -eq 0 ]; then
    echo "Requirements validated"
    git commit -am "Update requirements"
else
    echo "Validation failed"
    exit 1
fi
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<h3 id="rust_log"><a class="header" href="#rust_log"><code>RUST_LOG</code></a></h3>
<p>Control logging level (alternative to <code>-v</code> flags).</p>
<p><strong>Values</strong>:</p>
<ul>
<li><code>error</code>: Error messages only</li>
<li><code>warn</code>: Warnings and errors (default)</li>
<li><code>info</code>: Informational messages</li>
<li><code>debug</code>: Debug messages</li>
<li><code>trace</code>: Verbose trace messages</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code class="language-bash">RUST_LOG=info req clean
RUST_LOG=debug req add USR
RUST_LOG=trace req link SYS-001 USR-001
</code></pre>
<p><strong>Module-specific logging</strong>:</p>
<pre><code class="language-bash">RUST_LOG=requiem=debug req clean
RUST_LOG=requiem::storage=trace req add USR
</code></pre>
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<h3 id="standard-output"><a class="header" href="#standard-output">Standard Output</a></h3>
<p>Success messages go to stdout:</p>
<pre><code class="language-bash">req add USR
# Output: Added requirement USR-001
</code></pre>
<h3 id="standard-error"><a class="header" href="#standard-error">Standard Error</a></h3>
<p>Errors and logs go to stderr:</p>
<pre><code class="language-bash">req add INVALID 2&gt; errors.log
</code></pre>
<h3 id="json-output-planned"><a class="header" href="#json-output-planned">JSON Output (Planned)</a></h3>
<p>Machine-readable output:</p>
<pre><code class="language-bash">req add USR --format json
# {"success": true, "hrid": "USR-001", "uuid": "..."}
</code></pre>
<h2 id="shell-completion"><a class="header" href="#shell-completion">Shell Completion</a></h2>
<p>Generate shell completion scripts:</p>
<p><strong>Bash</strong>:</p>
<pre><code class="language-bash">req --generate-completion bash &gt; /etc/bash_completion.d/req
</code></pre>
<p><strong>Zsh</strong>:</p>
<pre><code class="language-bash">req --generate-completion zsh &gt; /usr/local/share/zsh/site-functions/_req
</code></pre>
<p><strong>Fish</strong>:</p>
<pre><code class="language-bash">req --generate-completion fish &gt; ~/.config/fish/completions/req.fish
</code></pre>
<p><strong>PowerShell</strong>:</p>
<pre><code class="language-powershell">req --generate-completion powershell &gt; req.ps1
</code></pre>
<p>(Note: Completion generation not yet implemented in current version)</p>
<h2 id="configuration-file-1"><a class="header" href="#configuration-file-1">Configuration File</a></h2>
<p>While not a CLI option, the <code>config.toml</code> file affects CLI behavior:</p>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS", "TST"]  # Restricts req add
digits = 3                              # Affects HRID formatting
allow_unrecognised = true               # Affects req clean behavior
</code></pre>
<p>See <a href="reference/./configuration.html">Configuration Reference</a> for details.</p>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="parallel-loading-1"><a class="header" href="#parallel-loading-1">Parallel Loading</a></h3>
<p>Requiem loads requirements in parallel for performance:</p>
<ul>
<li>100 requirements: &lt; 1 second</li>
<li>1000 requirements: ~2-3 seconds</li>
<li>10000 requirements: ~15-20 seconds</li>
</ul>
<h3 id="large-directories-1"><a class="header" href="#large-directories-1">Large Directories</a></h3>
<p>For very large requirement sets (1000+):</p>
<ul>
<li>Use subdirectories for organization</li>
<li><code>req clean</code> scales well due to parallelism</li>
<li>Consider namespaces to partition large sets</li>
</ul>
<h2 id="troubleshooting-8"><a class="header" href="#troubleshooting-8">Troubleshooting</a></h2>
<h3 id="command-not-found-1"><a class="header" href="#command-not-found-1">Command Not Found</a></h3>
<p><strong>Error</strong>: <code>req: command not found</code></p>
<p><strong>Solution</strong>:</p>
<pre><code class="language-bash"># Install Requiem
cargo install requirements-manager

# Verify installation
which req
req --version
</code></pre>
<h3 id="permission-denied-1"><a class="header" href="#permission-denied-1">Permission Denied</a></h3>
<p><strong>Error</strong>: <code>Permission denied</code> when creating/modifying files</p>
<p><strong>Solution</strong>: Ensure write permissions to requirements directory:</p>
<pre><code class="language-bash">chmod u+w *.md
chmod u+w .
</code></pre>
<h3 id="invalid-configuration"><a class="header" href="#invalid-configuration">Invalid Configuration</a></h3>
<p><strong>Error</strong>: <code>Failed to parse config file</code></p>
<p><strong>Solution</strong>: Check <code>config.toml</code> syntax:</p>
<pre><code class="language-bash"># Validate TOML
cat config.toml | python -c "import sys, toml; toml.load(sys.stdin)"
</code></pre>
<h3 id="unexpected-behavior-1"><a class="header" href="#unexpected-behavior-1">Unexpected Behavior</a></h3>
<p>Enable verbose logging:</p>
<pre><code class="language-bash">req -vv &lt;command&gt;
</code></pre>
<p>Check logs for detailed error messages.</p>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p><strong>Core commands</strong>:</p>
<ul>
<li><code>req add &lt;KIND&gt;</code> - Create requirement</li>
<li><code>req link &lt;CHILD&gt; &lt;PARENT&gt;</code> - Link requirements</li>
<li><code>req suspect</code> - List suspect links (fingerprint mismatches)</li>
<li><code>req accept &lt;CHILD&gt; &lt;PARENT&gt;</code> - Accept suspect link after review</li>
<li><code>req accept --all</code> - Accept all suspect links</li>
<li><code>req clean</code> - Correct parent HRIDs</li>
</ul>
<p><strong>Global options</strong>:</p>
<ul>
<li><code>-v, --verbose</code> - Increase logging</li>
<li><code>-r, --root &lt;PATH&gt;</code> - Specify requirements directory</li>
</ul>
<p><strong>Exit codes</strong>:</p>
<ul>
<li><code>0</code> - Success</li>
<li><code>1</code> - Suspect links found (req suspect only)</li>
<li>Non-zero - Error (other commands)</li>
</ul>
<p><strong>Getting help</strong>:</p>
<ul>
<li><code>req --help</code> - General help</li>
<li><code>req &lt;command&gt; --help</code> - Command-specific help</li>
</ul>
<h2 id="next-steps-27"><a class="header" href="#next-steps-27">Next Steps</a></h2>
<ul>
<li>See <a href="reference/./file-format.html">File Format Specification</a> for requirement file structure</li>
<li>See <a href="reference/./configuration.html">Configuration Reference</a> for <code>config.toml</code> options</li>
<li>Review <a href="reference/../working-with-requirements.html">Working with Requirements</a> for practical usage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-format-specification"><a class="header" href="#file-format-specification">File Format Specification</a></h1>
<p>Formal specification of the Requiem requirement file format.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>Requiem requirements are stored as Markdown files with YAML frontmatter. This document provides the formal specification.</p>
<h3 id="file-extension"><a class="header" href="#file-extension">File Extension</a></h3>
<p><code>.md</code> (Markdown)</p>
<h3 id="character-encoding"><a class="header" href="#character-encoding">Character Encoding</a></h3>
<p>UTF-8</p>
<h3 id="filename-format"><a class="header" href="#filename-format">Filename Format</a></h3>
<pre><code>{NAMESPACE-}*{KIND}-{ID}.md
</code></pre>
<p>Where:</p>
<ul>
<li><code>NAMESPACE</code>: Zero or more namespace segments (alphanumeric, hyphen-separated)</li>
<li><code>KIND</code>: Alphanumeric requirement kind (e.g., <code>USR</code>, <code>SYS</code>)</li>
<li><code>ID</code>: Positive integer (zero-padded to configured digits, default 3)</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code>USR-001.md
SYS-042.md
AUTH-USR-001.md
MOBILE-AUTH-LOGIN-SYS-005.md
</code></pre>
<p><strong>Validation Rules</strong>:</p>
<ul>
<li>Must end with <code>.md</code></li>
<li>NAMESPACE segments: non-empty, alphanumeric plus hyphen</li>
<li>KIND: non-empty, alphanumeric</li>
<li>ID: positive integer (1 or more), may have leading zeros</li>
<li>Segments separated by single hyphen <code>-</code></li>
<li>No consecutive hyphens <code>--</code></li>
<li>No leading or trailing hyphens</li>
</ul>
<h2 id="file-structure-1"><a class="header" href="#file-structure-1">File Structure</a></h2>
<p>Requirements consist of two parts:</p>
<ol>
<li><strong>YAML Frontmatter</strong>: Metadata enclosed in <code>---</code> delimiters</li>
<li><strong>Markdown Body</strong>: Requirement text in CommonMark format</li>
</ol>
<h3 id="general-structure"><a class="header" href="#general-structure">General Structure</a></h3>
<pre><code>---
&lt;YAML frontmatter&gt;
---
&lt;blank line optional&gt;
&lt;Markdown content&gt;
</code></pre>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
tags:
- authentication
- security
parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
---

The system shall validate user email addresses according to RFC 5322.

Email validation must occur before account creation.
</code></pre>
<h2 id="yaml-frontmatter-1"><a class="header" href="#yaml-frontmatter-1">YAML Frontmatter</a></h2>
<h3 id="delimiters"><a class="header" href="#delimiters">Delimiters</a></h3>
<ul>
<li><strong>Opening delimiter</strong>: <code>---</code> on first line</li>
<li><strong>Closing delimiter</strong>: <code>---</code> on its own line</li>
<li>Both required</li>
</ul>
<h3 id="schema-version-1"><a class="header" href="#schema-version-1">Schema Version 1</a></h3>
<p>Current version: <code>1</code></p>
<h4 id="required-fields-1"><a class="header" href="#required-fields-1">Required Fields</a></h4>
<h5 id="_version-1"><a class="header" href="#_version-1"><code>_version</code></a></h5>
<p><strong>Type</strong>: String (quoted)</p>
<p><strong>Format</strong>: <code>"1"</code></p>
<p><strong>Purpose</strong>: Schema version for forward/backward compatibility</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present</li>
<li>Must be string type (quoted in YAML)</li>
<li>Currently only <code>"1"</code> is valid</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">_version: '1'
</code></pre>
<h5 id="uuid-1"><a class="header" href="#uuid-1"><code>uuid</code></a></h5>
<p><strong>Type</strong>: UUID (string format)</p>
<p><strong>Format</strong>: UUID v4 (RFC 4122)</p>
<p><strong>Purpose</strong>: Globally unique, stable identifier</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present</li>
<li>Must be valid UUID format: <code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></li>
<li>Should be generated with <code>uuid::Uuid::new_v4()</code> or equivalent</li>
<li>Must be unique across all requirements (globally)</li>
<li>Must never change after creation</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
</code></pre>
<h5 id="created-1"><a class="header" href="#created-1"><code>created</code></a></h5>
<p><strong>Type</strong>: Timestamp (string format)</p>
<p><strong>Format</strong>: ISO 8601 with timezone (RFC 3339)</p>
<p><strong>Purpose</strong>: Requirement creation timestamp</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present</li>
<li>Must be valid ISO 8601 timestamp</li>
<li>Must include timezone (use UTC: <code>Z</code> suffix)</li>
<li>Format: <code>YYYY-MM-DDTHH:MM:SS.sssssssssZ</code></li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">created: 2025-07-22T12:19:56.950194157Z
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Nanosecond precision supported</li>
<li>Timezone must be UTC (<code>Z</code> suffix)</li>
<li>Set once at creation; never modified</li>
</ul>
<h4 id="optional-fields-1"><a class="header" href="#optional-fields-1">Optional Fields</a></h4>
<h5 id="tags"><a class="header" href="#tags"><code>tags</code></a></h5>
<p><strong>Type</strong>: Array of strings</p>
<p><strong>Format</strong>: YAML list</p>
<p><strong>Purpose</strong>: Categorize and tag requirements</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Optional (omit if no tags)</li>
<li>Array elements must be strings</li>
<li>Empty array allowed but should be omitted</li>
<li>No duplicate tags within same requirement</li>
<li>Tags are case-sensitive</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">tags:
- authentication
- security
- high-priority
</code></pre>
<p><strong>Omission</strong>:</p>
<pre><code class="language-yaml"># No tags field = no tags
_version: '1'
uuid: ...
# tags field omitted
</code></pre>
<p><strong>Serialization</strong>:</p>
<ul>
<li>Include only if non-empty: <code>skip_serializing_if = "BTreeSet::is_empty"</code></li>
<li>Stored as <code>BTreeSet</code> internally (sorted, unique)</li>
</ul>
<h5 id="parents-1"><a class="header" href="#parents-1"><code>parents</code></a></h5>
<p><strong>Type</strong>: Array of parent objects</p>
<p><strong>Format</strong>: YAML list of objects</p>
<p><strong>Purpose</strong>: Link to parent (upstream) requirements</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Optional (omit if no parents, e.g., root requirements)</li>
<li>Array elements must be parent objects (see Parent Object Schema)</li>
<li>Empty array allowed but should be omitted</li>
<li>Duplicate parent UUIDs allowed (though unusual)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
- uuid: 7a8f9e2b-1c3d-4e5f-6a7b-8c9d0e1f2a3b
  fingerprint: a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456
  hrid: USR-003
</code></pre>
<p><strong>Omission</strong>:</p>
<pre><code class="language-yaml"># No parents field = no parents (root requirement)
_version: '1'
uuid: ...
# parents field omitted
</code></pre>
<p><strong>Serialization</strong>:</p>
<ul>
<li>Include only if non-empty: <code>skip_serializing_if = "Vec::is_empty"</code></li>
</ul>
<h4 id="parent-object-schema"><a class="header" href="#parent-object-schema">Parent Object Schema</a></h4>
<p>Each parent object has three fields:</p>
<h5 id="uuid-2"><a class="header" href="#uuid-2"><code>uuid</code></a></h5>
<p><strong>Type</strong>: UUID (string format)</p>
<p><strong>Format</strong>: UUID v4</p>
<p><strong>Purpose</strong>: Stable reference to parent requirement</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present in parent object</li>
<li>Must be valid UUID format</li>
<li>Should match <code>uuid</code> field of an existing requirement</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
</code></pre>
<h5 id="fingerprint"><a class="header" href="#fingerprint"><code>fingerprint</code></a></h5>
<p><strong>Type</strong>: String (hex-encoded SHA256 hash)</p>
<p><strong>Format</strong>: 64-character hexadecimal string</p>
<p><strong>Purpose</strong>: Content hash of parent for change detection</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present in parent object</li>
<li>Must be 64-character hexadecimal string</li>
<li>Generated by hashing parent's content and tags with SHA256</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
</code></pre>
<p><strong>Generation</strong>:</p>
<pre><code>1. Collect parent's content (markdown body) and tags
2. Serialize with Borsh encoding
3. Hash with SHA256
4. Encode as hexadecimal string (64 characters)
</code></pre>
<h5 id="hrid"><a class="header" href="#hrid"><code>hrid</code></a></h5>
<p><strong>Type</strong>: String (HRID format)</p>
<p><strong>Format</strong>: <code>{NAMESPACE-}*{KIND}-{ID}</code></p>
<p><strong>Purpose</strong>: Human-readable reference to parent (convenience field)</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present in parent object</li>
<li>Must be valid HRID format</li>
<li>Should match parent's filename (without <code>.md</code> extension)</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-yaml">hrid: USR-001
</code></pre>
<p><strong>Notes</strong>:</p>
<ul>
<li>Convenience field for human readability</li>
<li>May become outdated if parent is renamed</li>
<li>Corrected by <code>req clean</code> command</li>
<li>UUID is authoritative; HRID is informational</li>
</ul>
<h3 id="schema-evolution"><a class="header" href="#schema-evolution">Schema Evolution</a></h3>
<p>Future schema versions (e.g., <code>_version: "2"</code>) will be backward-compatible:</p>
<ul>
<li>New optional fields may be added</li>
<li>Required fields will not be removed</li>
<li>Field semantics will not change incompatibly</li>
</ul>
<p>Parsers should:</p>
<ul>
<li>Ignore unknown fields</li>
<li>Provide defaults for missing optional fields</li>
<li>Reject unknown <code>_version</code> values (fail-safe)</li>
</ul>
<h2 id="markdown-body-1"><a class="header" href="#markdown-body-1">Markdown Body</a></h2>
<h3 id="format-1"><a class="header" href="#format-1">Format</a></h3>
<p>CommonMark (Markdown specification)</p>
<h3 id="location-1"><a class="header" href="#location-1">Location</a></h3>
<p>Everything after the closing frontmatter delimiter (<code>---</code>) is the markdown body.</p>
<h3 id="content"><a class="header" href="#content">Content</a></h3>
<p>Free-form Markdown:</p>
<ul>
<li>Headings (<code>#</code>, <code>##</code>, etc.)</li>
<li>Paragraphs</li>
<li>Lists (ordered, unordered)</li>
<li>Code blocks (fenced, indented)</li>
<li>Emphasis (bold, italic)</li>
<li>Links</li>
<li>Images</li>
<li>Blockquotes</li>
<li>Tables</li>
<li>Any CommonMark-compliant content</li>
</ul>
<h3 id="whitespace-1"><a class="header" href="#whitespace-1">Whitespace</a></h3>
<ul>
<li>Leading/trailing whitespace: preserved</li>
<li>Empty lines between frontmatter and body: ignored</li>
<li>Empty body: valid (empty string)</li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-markdown">---
_version: '1'
uuid: ...
created: ...
---

The system shall validate user email addresses.

## Rationale

Email validation ensures...

## Acceptance Criteria

- Valid email format
- Rejects invalid emails
- Provides clear error messages
</code></pre>
<h2 id="parsing-rules-1"><a class="header" href="#parsing-rules-1">Parsing Rules</a></h2>
<h3 id="frontmatter-parsing"><a class="header" href="#frontmatter-parsing">Frontmatter Parsing</a></h3>
<ol>
<li>First line must be <code>---</code></li>
<li>Read lines until next <code>---</code> on its own line</li>
<li>Parse collected lines as YAML</li>
<li>Validate against schema</li>
<li>Remaining lines are markdown body</li>
</ol>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p><strong>Missing opening delimiter</strong>:</p>
<pre><code>Error: Expected frontmatter starting with '---'
</code></pre>
<p><strong>Missing closing delimiter</strong>:</p>
<pre><code>Error: Unexpected EOF while parsing frontmatter
</code></pre>
<p><strong>Invalid YAML</strong>:</p>
<pre><code>Error: Failed to parse YAML: &lt;syntax error details&gt;
</code></pre>
<p><strong>Missing required field</strong>:</p>
<pre><code>Error: Missing required field '&lt;field_name&gt;'
</code></pre>
<p><strong>Invalid UUID format</strong>:</p>
<pre><code>Error: Invalid UUID format: '&lt;value&gt;'
</code></pre>
<p><strong>Invalid timestamp format</strong>:</p>
<pre><code>Error: Invalid timestamp format: '&lt;value&gt;'
</code></pre>
<p><strong>Unknown _version</strong>:</p>
<pre><code>Error: Unknown schema version: '&lt;value&gt;'
</code></pre>
<h3 id="strict-vs-permissive"><a class="header" href="#strict-vs-permissive">Strict vs. Permissive</a></h3>
<p>Requiem parsing is strict by default:</p>
<ul>
<li>All required fields must be present</li>
<li>All fields must be valid</li>
<li>Unknown fields in schema version 1 cause errors (currently)</li>
</ul>
<p>Controlled by <code>allow_invalid</code> config option:</p>
<ul>
<li><code>allow_invalid = false</code> (default): Strict parsing, fail on errors</li>
<li><code>allow_invalid = true</code>: Skip invalid requirements with warnings</li>
</ul>
<h2 id="serialization-rules"><a class="header" href="#serialization-rules">Serialization Rules</a></h2>
<h3 id="field-order"><a class="header" href="#field-order">Field Order</a></h3>
<p>Fields serialized in this order:</p>
<ol>
<li><code>_version</code></li>
<li><code>uuid</code></li>
<li><code>created</code></li>
<li><code>tags</code> (if present)</li>
<li><code>parents</code> (if present)</li>
</ol>
<h3 id="omission-rules"><a class="header" href="#omission-rules">Omission Rules</a></h3>
<ul>
<li><code>tags</code>: Omitted if empty</li>
<li><code>parents</code>: Omitted if empty</li>
</ul>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<ul>
<li>YAML indentation: 2 spaces</li>
<li>String quoting: Single quotes for strings containing special characters</li>
<li>Array formatting: One element per line with <code>-</code> prefix</li>
<li>Object formatting: Indented key-value pairs</li>
</ul>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code class="language-yaml">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
tags:
- authentication
- security
parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
---

Requirement text here.
</code></pre>
<h2 id="validation-2"><a class="header" href="#validation-2">Validation</a></h2>
<h3 id="syntactic-validation"><a class="header" href="#syntactic-validation">Syntactic Validation</a></h3>
<ul>
<li>Valid YAML frontmatter</li>
<li>Valid Markdown body (CommonMark)</li>
<li>Correct delimiters</li>
</ul>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic Validation</a></h3>
<ul>
<li>Required fields present</li>
<li>Field types correct</li>
<li>UUID format valid</li>
<li>Timestamp format valid</li>
<li>HRID format valid (in parent references)</li>
<li>Fingerprint format valid (64-char hex)</li>
</ul>
<h3 id="referential-integrity"><a class="header" href="#referential-integrity">Referential Integrity</a></h3>
<ul>
<li>Parent UUIDs reference existing requirements</li>
<li>No self-references (requirement is not its own parent)</li>
<li>No duplicate UUIDs across all requirements</li>
</ul>
<h3 id="configuration-based-validation"><a class="header" href="#configuration-based-validation">Configuration-Based Validation</a></h3>
<ul>
<li>HRID KIND in <code>allowed_kinds</code> (if configured)</li>
<li>File follows naming convention (if <code>allow_unrecognised = false</code>)</li>
</ul>
<h2 id="canonical-example"><a class="header" href="#canonical-example">Canonical Example</a></h2>
<pre><code class="language-markdown">---
_version: '1'
uuid: 4bfeb7d5-d168-44a7-b0f1-e292c1c89b9a
created: 2025-07-22T12:19:56.950194157Z
tags:
- authentication
- security
- high-priority
parents:
- uuid: 3fc6800c-5acc-457e-baf9-a29b42b663fd
  fingerprint: c4020419ead000e9b5f9cfd4ebf6192e73f905c27e6897548d8f6e12fd7f1356
  hrid: USR-001
- uuid: 7a8f9e2b-1c3d-4e5f-6a7b-8c9d0e1f2a3b
  fingerprint: a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456
  hrid: USR-003
---

The system shall validate user email addresses according to RFC 5322.

## Rationale

Email validation ensures that user accounts can be contacted and that
authentication tokens can be delivered reliably.

## Acceptance Criteria

- Email addresses must match RFC 5322 format
- Invalid email addresses must be rejected with clear error message
- Validation must occur before account creation

## References

- RFC 5322: Internet Message Format
- OWASP Email Validation Guidelines
</code></pre>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p><strong>File format</strong>:</p>
<ul>
<li>Markdown (<code>.md</code>) files with UTF-8 encoding</li>
<li>YAML frontmatter enclosed in <code>---</code> delimiters</li>
<li>CommonMark markdown body</li>
</ul>
<p><strong>Required frontmatter fields</strong>:</p>
<ul>
<li><code>_version</code>: Schema version (currently <code>"1"</code>)</li>
<li><code>uuid</code>: Unique identifier (UUID v4)</li>
<li><code>created</code>: Creation timestamp (ISO 8601 with UTC)</li>
</ul>
<p><strong>Optional frontmatter fields</strong>:</p>
<ul>
<li><code>tags</code>: Array of tags</li>
<li><code>parents</code>: Array of parent objects (uuid, fingerprint, hrid)</li>
</ul>
<p><strong>Validation</strong>:</p>
<ul>
<li>Strict by default</li>
<li>Controlled by <code>allow_invalid</code> config option</li>
<li>Includes syntactic, semantic, and referential checks</li>
</ul>
<h2 id="next-steps-28"><a class="header" href="#next-steps-28">Next Steps</a></h2>
<ul>
<li>See <a href="reference/./cli.html">CLI Command Reference</a> for working with requirements</li>
<li>See <a href="reference/./configuration.html">Configuration Reference</a> for config options</li>
<li>Review <a href="reference/../working-with-requirements/file-format.html">Working with Requirements</a> for practical examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h1>
<p>Complete reference for Requiem's <code>config.toml</code> configuration file.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>The <code>config.toml</code> file configures Requiem's behavior. It must be located in the root of your requirements directory.</p>
<h3 id="file-location"><a class="header" href="#file-location">File Location</a></h3>
<pre><code>requirements/
‚îú‚îÄ‚îÄ config.toml    ‚Üê Configuration file
‚îú‚îÄ‚îÄ USR-001.md
‚îú‚îÄ‚îÄ USR-002.md
‚îî‚îÄ‚îÄ SYS-001.md
</code></pre>
<h3 id="file-format-1"><a class="header" href="#file-format-1">File Format</a></h3>
<p>TOML (Tom's Obvious Minimal Language)</p>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<p>Configuration file is optional. If absent, Requiem uses defaults.</p>
<h2 id="schema-version-1-1"><a class="header" href="#schema-version-1-1">Schema Version 1</a></h2>
<p>Current schema version: <code>1</code></p>
<h3 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h3>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS", "SWR", "TST"]
digits = 3
allow_unrecognised = false
allow_invalid = false
subfolders_are_namespaces = false
</code></pre>
<h2 id="configuration-fields"><a class="header" href="#configuration-fields">Configuration Fields</a></h2>
<h3 id="_version-required-1"><a class="header" href="#_version-required-1"><code>_version</code> (required)</a></h3>
<p>Schema version for forward/backward compatibility.</p>
<p><strong>Type</strong>: String (quoted)</p>
<p><strong>Required</strong>: Yes</p>
<p><strong>Default</strong>: N/A (must be explicitly specified)</p>
<p><strong>Valid Values</strong>: <code>"1"</code></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">_version = "1"
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Enables future schema changes</li>
<li>Allows old Requiem versions to detect incompatible configs</li>
<li>Allows new Requiem versions to handle old configs</li>
</ul>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be present</li>
<li>Must be quoted string</li>
<li>Must be <code>"1"</code> in current version</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Missing:</p>
<pre><code class="language-toml"># config.toml
allowed_kinds = ["USR"]
</code></pre>
<pre><code>Error: Failed to parse config file: missing field '_version'
</code></pre>
<p>Wrong type:</p>
<pre><code class="language-toml">_version = 1  # Wrong: integer instead of string
</code></pre>
<pre><code>Error: Failed to parse config file: invalid type: integer, expected a string
</code></pre>
<h3 id="allowed_kinds"><a class="header" href="#allowed_kinds"><code>allowed_kinds</code></a></h3>
<p>Restrict which requirement kinds are permitted.</p>
<p><strong>Type</strong>: Array of strings</p>
<p><strong>Required</strong>: No</p>
<p><strong>Default</strong>: <code>[]</code> (empty array = all kinds allowed)</p>
<p><strong>Valid Values</strong>: Array of non-empty strings</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["USR", "SYS", "SWR", "TST"]
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Enforce project conventions</li>
<li>Prevent typos (USR vs UST)</li>
<li>Document allowed requirement types</li>
</ul>
<p><strong>Behavior</strong>:</p>
<p><strong>Empty array (default)</strong>:</p>
<pre><code class="language-toml">allowed_kinds = []
# OR omit field entirely
</code></pre>
<p>All kinds accepted: <code>USR-001</code>, <code>SYS-001</code>, <code>CUSTOM-001</code>, etc.</p>
<p><strong>Non-empty array</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["USR", "SYS"]
</code></pre>
<p>Only listed kinds accepted:</p>
<ul>
<li><code>req add USR</code> ‚úì Succeeds</li>
<li><code>req add SYS</code> ‚úì Succeeds</li>
<li><code>req add TST</code> ‚úó Fails (TST not in allowed list)</li>
</ul>
<p><strong>With namespaces</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["AUTH-USR", "AUTH-SYS", "PAYMENT-USR"]
</code></pre>
<p>Exact match required:</p>
<ul>
<li><code>req add AUTH-USR</code> ‚úì Succeeds</li>
<li><code>req add USR</code> ‚úó Fails (USR not in allowed list)</li>
</ul>
<p><strong>Examples</strong>:</p>
<p>Aerospace project (DO-178C):</p>
<pre><code class="language-toml">allowed_kinds = ["URQT", "SRQT", "SWRQT", "HWRQT", "TRQT"]
</code></pre>
<p>Software project:</p>
<pre><code class="language-toml">allowed_kinds = ["USR", "SYS", "SWR", "TST", "DOC"]
</code></pre>
<p>Multi-component with namespaces:</p>
<pre><code class="language-toml">allowed_kinds = [
    "AUTH-USR", "AUTH-SYS",
    "PAYMENT-USR", "PAYMENT-SYS",
    "REPORTING-USR", "REPORTING-SYS"
]
</code></pre>
<p><strong>Validation</strong>:</p>
<ul>
<li>Each element must be non-empty string</li>
<li>Duplicates allowed (but pointless)</li>
<li>Case-sensitive matching</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Empty string in array:</p>
<pre><code class="language-toml">allowed_kinds = ["USR", ""]
</code></pre>
<pre><code>Error: Failed to parse config file: empty strings not allowed in allowed_kinds
</code></pre>
<h3 id="digits"><a class="header" href="#digits"><code>digits</code></a></h3>
<p>Number of digits in HRID numbering (with zero-padding).</p>
<p><strong>Type</strong>: Unsigned integer</p>
<p><strong>Required</strong>: No</p>
<p><strong>Default</strong>: <code>3</code></p>
<p><strong>Valid Values</strong>: Any positive integer (typically 3-5)</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">digits = 3
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Control HRID formatting</li>
<li>Accommodate projects with many requirements per kind</li>
</ul>
<p><strong>Behavior</strong>:</p>
<p><strong>digits = 3</strong> (default):</p>
<pre><code>USR-001
USR-002
USR-010
USR-099
USR-100  # Expands beyond 3 digits when needed
USR-1000
</code></pre>
<p><strong>digits = 4</strong>:</p>
<pre><code>USR-0001
USR-0002
USR-0010
USR-0999
USR-1000
USR-10000  # Expands beyond 4 digits when needed
</code></pre>
<p><strong>digits = 2</strong>:</p>
<pre><code>USR-01
USR-02
USR-99
USR-100  # Expands beyond 2 digits when needed
</code></pre>
<p><strong>Parsing</strong>:</p>
<ul>
<li>Requirements can have any number of digits when parsing</li>
<li><code>USR-1</code>, <code>USR-01</code>, <code>USR-001</code> all parse as ID 1</li>
<li>Display/creation uses configured padding</li>
</ul>
<p><strong>Recommendations</strong>:</p>
<ul>
<li><code>digits = 3</code>: &lt; 1000 requirements per kind (most projects)</li>
<li><code>digits = 4</code>: 1000-9999 requirements per kind</li>
<li><code>digits = 5</code>: Very large projects</li>
</ul>
<p><strong>Examples</strong>:</p>
<p>Small project:</p>
<pre><code class="language-toml">digits = 2
</code></pre>
<p>Medium project (default):</p>
<pre><code class="language-toml">digits = 3
</code></pre>
<p>Large project:</p>
<pre><code class="language-toml">digits = 4
</code></pre>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be positive integer</li>
<li>Zero or negative not allowed</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Zero:</p>
<pre><code class="language-toml">digits = 0
</code></pre>
<pre><code>Error: Failed to parse config file: digits must be positive
</code></pre>
<h3 id="allow_unrecognised"><a class="header" href="#allow_unrecognised"><code>allow_unrecognised</code></a></h3>
<p>Allow markdown files that don't match HRID pattern.</p>
<p><strong>Type</strong>: Boolean</p>
<p><strong>Required</strong>: No</p>
<p><strong>Default</strong>: <code>false</code></p>
<p><strong>Valid Values</strong>: <code>true</code>, <code>false</code></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">allow_unrecognised = true
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Enable mixing requirements with other documentation</li>
<li>Control strictness of file validation</li>
</ul>
<p><strong>Behavior</strong>:</p>
<p><strong>allow_unrecognised = false</strong> (default, strict):</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ USR-001.md     ‚Üê Loaded (valid HRID)
‚îú‚îÄ‚îÄ USR-002.md     ‚Üê Loaded (valid HRID)
‚îî‚îÄ‚îÄ README.md      ‚Üê ERROR: Not a valid HRID
</code></pre>
<p>Error during <code>req clean</code>:</p>
<pre><code>Error: Unrecognised file: README.md
</code></pre>
<p><strong>allow_unrecognised = true</strong> (permissive):</p>
<pre><code>docs/
‚îú‚îÄ‚îÄ config.toml
‚îú‚îÄ‚îÄ USR-001.md     ‚Üê Loaded (valid HRID)
‚îú‚îÄ‚îÄ USR-002.md     ‚Üê Loaded (valid HRID)
‚îî‚îÄ‚îÄ README.md      ‚Üê Ignored (not a valid HRID)
</code></pre>
<p>No error; <code>README.md</code> is silently skipped.</p>
<p><strong>Use Cases</strong>:</p>
<p><strong>Use <code>false</code> (default)</strong>:</p>
<ul>
<li>Dedicated requirements directory</li>
<li>Strict validation desired</li>
<li>Catch typos in filenames</li>
</ul>
<p><strong>Use <code>true</code></strong>:</p>
<ul>
<li>Requirements mixed with MdBook/Sphinx content</li>
<li>Documentation and requirements in same directory</li>
<li>Legacy projects with existing non-requirement files</li>
</ul>
<p><strong>Examples</strong>:</p>
<p>Strict requirements-only:</p>
<pre><code class="language-toml">_version = "1"
allow_unrecognised = false
</code></pre>
<p>Mixed documentation:</p>
<pre><code class="language-toml">_version = "1"
allow_unrecognised = true  # Allow chapter1.md, README.md, etc.
</code></pre>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be boolean</li>
<li>Case-sensitive: <code>true</code> or <code>false</code> (lowercase)</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Wrong case:</p>
<pre><code class="language-toml">allow_unrecognised = True  # Wrong: uppercase
</code></pre>
<pre><code>Error: Failed to parse config file: invalid value
</code></pre>
<h3 id="subfolders_are_namespaces"><a class="header" href="#subfolders_are_namespaces"><code>subfolders_are_namespaces</code></a></h3>
<p>Control whether subfolder paths contribute to requirement namespaces.</p>
<p><strong>Type</strong>: Boolean</p>
<p><strong>Required</strong>: No</p>
<p><strong>Default</strong>: <code>false</code></p>
<p><strong>Valid Values</strong>: <code>true</code>, <code>false</code></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">subfolders_are_namespaces = true
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Choose between filename-based and path-based directory organization</li>
<li>Enable cleaner filenames in hierarchical structures</li>
<li>Align folder structure with namespace hierarchy</li>
</ul>
<p><strong>Behavior</strong>:</p>
<p><strong>subfolders_are_namespaces = false</strong> (default, filename-based):</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ custom/folder/
‚îÇ   ‚îî‚îÄ‚îÄ system-auth-REQ-001.md   ‚Üí HRID: system-auth-REQ-001
‚îî‚îÄ‚îÄ any/path/
    ‚îî‚îÄ‚îÄ payment-USR-002.md       ‚Üí HRID: payment-USR-002
</code></pre>
<ul>
<li><strong>HRID</strong>: Fully encoded in filename</li>
<li><strong>Folders</strong>: Purely organizational, don't affect HRID</li>
<li><strong>Flexibility</strong>: Move files freely without changing HRIDs</li>
</ul>
<p><strong>subfolders_are_namespaces = true</strong> (path-based):</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ system/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îú‚îÄ‚îÄ REQ-001.md           ‚Üí HRID: system-auth-REQ-001
‚îÇ       ‚îî‚îÄ‚îÄ USR/
‚îÇ           ‚îî‚îÄ‚îÄ 002.md           ‚Üí HRID: system-auth-USR-002
‚îî‚îÄ‚îÄ payment/
    ‚îî‚îÄ‚îÄ USR-003.md               ‚Üí HRID: payment-USR-003
</code></pre>
<ul>
<li><strong>HRID</strong>: Namespace from folder path + KIND-ID from filename</li>
<li><strong>Folders</strong>: Encode namespace segments</li>
<li><strong>Format inference</strong>:
<ul>
<li>Numeric filename (<code>002.md</code>) ‚Üí KIND from parent folder</li>
<li>KIND-ID filename (<code>USR-003.md</code>) ‚Üí KIND from filename</li>
</ul>
</li>
<li><strong>Constraint</strong>: Moving files changes their HRID</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<p><strong>Use <code>false</code> (default)</strong>:</p>
<ul>
<li>Maximum folder flexibility</li>
<li>Arbitrary organizational schemes</li>
<li>Frequent folder reorganization</li>
<li>Explicit namespaces in every filename</li>
</ul>
<p><strong>Use <code>true</code></strong>:</p>
<ul>
<li>Hierarchical component structures</li>
<li>Folder structure mirrors system architecture</li>
<li>Cleaner, shorter filenames</li>
<li>Enforced namespace-folder alignment</li>
</ul>
<p><strong>Examples</strong>:</p>
<p>Filename-based (flexible organization):</p>
<pre><code class="language-toml">_version = "1"
subfolders_are_namespaces = false
</code></pre>
<p>Path-based (structured hierarchy):</p>
<pre><code class="language-toml">_version = "1"
subfolders_are_namespaces = true
</code></pre>
<p><strong>Migration</strong>:</p>
<p>To convert from filename-based to path-based:</p>
<ol>
<li>Set <code>subfolders_are_namespaces = true</code></li>
<li>Reorganize files to match namespace structure</li>
<li>Rename files to remove namespace prefix</li>
</ol>
<p>To convert from path-based to filename-based:</p>
<ol>
<li>Move files and encode full HRID in filename</li>
<li>Set <code>subfolders_are_namespaces = false</code></li>
<li>Optionally flatten directory structure</li>
</ol>
<p>See <a href="reference/../configuration/directory-structure.html">Directory Structure</a> for detailed migration guide.</p>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be boolean</li>
<li>Case-sensitive: <code>true</code> or <code>false</code> (lowercase)</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Wrong type:</p>
<pre><code class="language-toml">subfolders_are_namespaces = "yes"  # Wrong: string instead of boolean
</code></pre>
<pre><code>Error: Failed to parse config file: invalid type: string, expected a bool
</code></pre>
<h3 id="allow_invalid"><a class="header" href="#allow_invalid"><code>allow_invalid</code></a></h3>
<p>Allow requirements with invalid YAML frontmatter or formatting.</p>
<p><strong>Type</strong>: Boolean</p>
<p><strong>Required</strong>: No</p>
<p><strong>Default</strong>: <code>false</code></p>
<p><strong>Valid Values</strong>: <code>true</code>, <code>false</code></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-toml">allow_invalid = true
</code></pre>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Control strictness of requirement validation</li>
<li>Enable partial loading during migration or recovery</li>
</ul>
<p><strong>Behavior</strong>:</p>
<p><strong>allow_invalid = false</strong> (default, strict):</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md    ‚Üê Valid frontmatter, loaded
‚îú‚îÄ‚îÄ USR-002.md    ‚Üê Invalid frontmatter (missing uuid)
‚îî‚îÄ‚îÄ USR-003.md    ‚Üê Valid frontmatter
</code></pre>
<p>Error during <code>req clean</code>:</p>
<pre><code>Error: Invalid requirement USR-002.md: missing required field 'uuid'
</code></pre>
<p>Loading fails; no requirements processed.</p>
<p><strong>allow_invalid = true</strong> (permissive):</p>
<pre><code>requirements/
‚îú‚îÄ‚îÄ USR-001.md    ‚Üê Valid, loaded
‚îú‚îÄ‚îÄ USR-002.md    ‚Üê Invalid, skipped with warning
‚îî‚îÄ‚îÄ USR-003.md    ‚Üê Valid, loaded
</code></pre>
<p>Warning during <code>req clean</code>:</p>
<pre><code>Warning: Skipping invalid requirement USR-002.md: missing required field 'uuid'
Successfully loaded 2 requirements (1 skipped)
</code></pre>
<p>Loading continues; valid requirements processed.</p>
<p><strong>Use Cases</strong>:</p>
<p><strong>Use <code>false</code> (default)</strong>:</p>
<ul>
<li>Production use</li>
<li>Ensure data quality</li>
<li>Catch errors immediately</li>
</ul>
<p><strong>Use <code>true</code></strong>:</p>
<ul>
<li>Migrating from another tool (gradual fix-up)</li>
<li>Recovering from manual editing errors</li>
<li>Development/debugging</li>
<li>Partial validation during cleanup</li>
</ul>
<p><strong>Examples</strong>:</p>
<p>Production (strict):</p>
<pre><code class="language-toml">_version = "1"
allow_invalid = false
</code></pre>
<p>Migration (permissive):</p>
<pre><code class="language-toml">_version = "1"
allow_invalid = true  # Temporarily allow invalid requirements
</code></pre>
<p><strong>Validation</strong>:</p>
<ul>
<li>Must be boolean</li>
<li>Case-sensitive: <code>true</code> or <code>false</code> (lowercase)</li>
</ul>
<p><strong>Errors</strong>:</p>
<p>Wrong type:</p>
<pre><code class="language-toml">allow_invalid = "yes"  # Wrong: string instead of boolean
</code></pre>
<pre><code>Error: Failed to parse config file: invalid type: string, expected a bool
</code></pre>
<h2 id="minimal-configuration"><a class="header" href="#minimal-configuration">Minimal Configuration</a></h2>
<p>Smallest valid configuration:</p>
<pre><code class="language-toml">_version = "1"
</code></pre>
<p>All other fields use defaults:</p>
<ul>
<li><code>allowed_kinds = []</code> (all kinds allowed)</li>
<li><code>digits = 3</code></li>
<li><code>allow_unrecognised = false</code></li>
<li><code>allow_invalid = false</code></li>
<li><code>subfolders_are_namespaces = false</code></li>
</ul>
<h2 id="default-configuration"><a class="header" href="#default-configuration">Default Configuration</a></h2>
<p>If <code>config.toml</code> is absent, equivalent to:</p>
<pre><code class="language-toml">_version = "1"
allowed_kinds = []
digits = 3
allow_unrecognised = false
allow_invalid = false
subfolders_are_namespaces = false
</code></pre>
<h2 id="configuration-examples-1"><a class="header" href="#configuration-examples-1">Configuration Examples</a></h2>
<h3 id="small-project"><a class="header" href="#small-project">Small Project</a></h3>
<pre><code class="language-toml">_version = "1"
digits = 3
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h3 id="large-project"><a class="header" href="#large-project">Large Project</a></h3>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS", "SWR", "HWR", "TST", "DOC"]
digits = 4  # Expect 1000+ requirements per kind
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h3 id="integrated-documentation"><a class="header" href="#integrated-documentation">Integrated Documentation</a></h3>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["USR", "SYS"]
digits = 3
allow_unrecognised = true  # Allow MdBook/Sphinx files
allow_invalid = false
</code></pre>
<h3 id="migration-project"><a class="header" href="#migration-project">Migration Project</a></h3>
<pre><code class="language-toml">_version = "1"
digits = 3
allow_unrecognised = true   # Mixed content during migration
allow_invalid = true         # Some requirements may be incomplete
</code></pre>
<h3 id="aerospace-do-178c"><a class="header" href="#aerospace-do-178c">Aerospace (DO-178C)</a></h3>
<pre><code class="language-toml">_version = "1"
allowed_kinds = ["URQT", "SRQT", "SWRQT", "HWRQT", "TRQT"]
digits = 4
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h3 id="multi-component-system-1"><a class="header" href="#multi-component-system-1">Multi-Component System</a></h3>
<pre><code class="language-toml">_version = "1"
allowed_kinds = [
    "CORE-USR", "CORE-SYS",
    "AUTH-USR", "AUTH-SYS",
    "PAYMENT-USR", "PAYMENT-SYS",
    "REPORTING-USR", "REPORTING-SYS"
]
digits = 3
allow_unrecognised = false
allow_invalid = false
</code></pre>
<h2 id="validation-3"><a class="header" href="#validation-3">Validation</a></h2>
<h3 id="parsing-errors"><a class="header" href="#parsing-errors">Parsing Errors</a></h3>
<p><strong>Missing _version</strong>:</p>
<pre><code class="language-toml">allowed_kinds = ["USR"]
</code></pre>
<pre><code>Error: Failed to parse config file: missing field '_version'
</code></pre>
<p><strong>Invalid TOML syntax</strong>:</p>
<pre><code class="language-toml">_version = "1
allowed_kinds = ["USR"]
</code></pre>
<pre><code>Error: Failed to parse config file: expected '"', got newline
</code></pre>
<p><strong>Wrong type</strong>:</p>
<pre><code class="language-toml">_version = 1  # Should be string
</code></pre>
<pre><code>Error: Failed to parse config file: invalid type: integer, expected a string
</code></pre>
<p><strong>Unknown field</strong> (future-proofing):</p>
<pre><code class="language-toml">_version = "1"
unknown_field = "value"
</code></pre>
<p>Currently allowed (forward compatibility), but may be rejected in strict mode.</p>
<h3 id="runtime-validation"><a class="header" href="#runtime-validation">Runtime Validation</a></h3>
<p>Configuration is loaded at:</p>
<ul>
<li><code>req add</code></li>
<li><code>req link</code></li>
<li><code>req clean</code></li>
</ul>
<p>Errors reported immediately:</p>
<pre><code class="language-bash">req clean
# Error: Failed to load config: missing field '_version'
</code></pre>
<h2 id="schema-evolution-1"><a class="header" href="#schema-evolution-1">Schema Evolution</a></h2>
<h3 id="version-1-current"><a class="header" href="#version-1-current">Version 1 (Current)</a></h3>
<p>Fields:</p>
<ul>
<li><code>_version</code> (required)</li>
<li><code>allowed_kinds</code> (optional)</li>
<li><code>digits</code> (optional)</li>
<li><code>allow_unrecognised</code> (optional)</li>
<li><code>allow_invalid</code> (optional)</li>
<li><code>subfolders_are_namespaces</code> (optional)</li>
</ul>
<h3 id="future-versions"><a class="header" href="#future-versions">Future Versions</a></h3>
<p>Planned fields (not yet implemented):</p>
<p><strong>Version 2</strong> (hypothetical):</p>
<pre><code class="language-toml">_version = "2"

# Existing fields
allowed_kinds = ["USR", "SYS"]
digits = 3
allow_unrecognised = false
allow_invalid = false

# New fields
[namespaces]
required = true
allowed = ["AUTH", "PAYMENT"]

[review]
auto_flag = true
notify = "team@example.com"

[coverage]
minimum = 95
</code></pre>
<p><strong>Compatibility</strong>:</p>
<ul>
<li>Old Requiem: Rejects <code>_version = "2"</code> (unknown version)</li>
<li>New Requiem: Reads <code>_version = "1"</code> (backward compatible)</li>
</ul>
<h2 id="troubleshooting-9"><a class="header" href="#troubleshooting-9">Troubleshooting</a></h2>
<h3 id="config-not-recognized"><a class="header" href="#config-not-recognized">Config Not Recognized</a></h3>
<p><strong>Problem</strong>: Changes to <code>config.toml</code> don't take effect.</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Ensure file is named exactly <code>config.toml</code> (lowercase, no extension)</li>
<li>Ensure file is in requirements root directory</li>
<li>Verify TOML syntax with validator</li>
</ul>
<h3 id="parse-errors-1"><a class="header" href="#parse-errors-1">Parse Errors</a></h3>
<p><strong>Problem</strong>: <code>Error: Failed to parse config file</code></p>
<p><strong>Diagnosis</strong>:</p>
<ol>
<li>Check TOML syntax</li>
<li>Ensure strings are quoted</li>
<li>Ensure arrays use square brackets</li>
<li>Check for typos in field names</li>
</ol>
<p><strong>Solution</strong>: Validate TOML:</p>
<pre><code class="language-bash"># Python
python -c "import sys, toml; toml.load(open('config.toml'))"

# Online validator
# Copy config to https://www.toml-lint.com/
</code></pre>
<h3 id="requirements-rejected"><a class="header" href="#requirements-rejected">Requirements Rejected</a></h3>
<p><strong>Problem</strong>: <code>req add</code> fails with "Kind not in allowed list"</p>
<p><strong>Diagnosis</strong>: Check <code>allowed_kinds</code> in config.</p>
<p><strong>Solution</strong>: Add kind to <code>allowed_kinds</code> or use empty array:</p>
<pre><code class="language-toml">allowed_kinds = []  # Allow all kinds
</code></pre>
<h3 id="files-ignored-unexpectedly"><a class="header" href="#files-ignored-unexpectedly">Files Ignored Unexpectedly</a></h3>
<p><strong>Problem</strong>: Valid requirement files not loaded.</p>
<p><strong>Diagnosis</strong>: Check filename matches HRID pattern.</p>
<p><strong>Solution</strong>:</p>
<ul>
<li>Ensure filename is <code>{KIND}-{ID}.md</code></li>
<li>Set <code>allow_unrecognised = false</code> to get error messages</li>
</ul>
<h2 id="summary-14"><a class="header" href="#summary-14">Summary</a></h2>
<p><strong>Configuration file</strong>:</p>
<ul>
<li>Location: <code>config.toml</code> in requirements root</li>
<li>Format: TOML</li>
<li>Optional: Uses defaults if absent</li>
</ul>
<p><strong>Required fields</strong>:</p>
<ul>
<li><code>_version</code>: Schema version (currently <code>"1"</code>)</li>
</ul>
<p><strong>Optional fields</strong>:</p>
<ul>
<li><code>allowed_kinds</code>: Restrict requirement kinds (default: <code>[]</code>, allow all)</li>
<li><code>digits</code>: HRID digit padding (default: <code>3</code>)</li>
<li><code>allow_unrecognised</code>: Allow non-HRID files (default: <code>false</code>)</li>
<li><code>allow_invalid</code>: Allow invalid requirements (default: <code>false</code>)</li>
<li><code>subfolders_are_namespaces</code>: Use path-based structure (default: <code>false</code>)</li>
</ul>
<p><strong>Defaults</strong>:</p>
<ul>
<li>All kinds allowed</li>
<li>3-digit HRID padding</li>
<li>Strict file validation</li>
<li>Strict requirement validation</li>
<li>Filename-based directory structure</li>
</ul>
<h2 id="next-steps-29"><a class="header" href="#next-steps-29">Next Steps</a></h2>
<ul>
<li>See <a href="reference/./cli.html">CLI Command Reference</a> for commands affected by configuration</li>
<li>See <a href="reference/./file-format.html">File Format Specification</a> for requirement format</li>
<li>Review <a href="reference/../configuration/config-file.html">Configuration File</a> for detailed explanations</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
